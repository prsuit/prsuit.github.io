<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言本文是介绍Android中的Binder机制。 目录一、Binder是什么Binder 是 Android 系统进程间的一种通信机制，官方介绍：  Base class for a remotable object, the core part of a lightweight remote procedure call mechanism defined by IBinder. This c">
<meta property="og:type" content="article">
<meta property="og:title" content="Binder机制">
<meta property="og:url" content="http://yoursite.com/2020/08/12/Binder%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="SongHang&#39;s Blog">
<meta property="og:description" content="前言本文是介绍Android中的Binder机制。 目录一、Binder是什么Binder 是 Android 系统进程间的一种通信机制，官方介绍：  Base class for a remotable object, the core part of a lightweight remote procedure call mechanism defined by IBinder. This c">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghuz8xxeeej30zk0n675v.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghv0v787nwj30zk0ogn0j.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghv2qmtimuj30zk0pdwis.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghv3pv6tj0j30zk0kv77j.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghv4ottvlkj30pl0cgjuv.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghw4y8di3ij30a107qq37.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghw5dr45igj30zk0iwjtm.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghxfotybjhj30zs0dy75l.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghyk9gwafcj30qo0t5qc1.jpg">
<meta property="article:published_time" content="2020-08-12T14:42:35.000Z">
<meta property="article:modified_time" content="2020-08-25T15:04:57.284Z">
<meta property="article:author" content="prsuit">
<meta property="article:tag" content="Android进阶">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1ghuz8xxeeej30zk0n675v.jpg">

<link rel="canonical" href="http://yoursite.com/2020/08/12/Binder%E6%9C%BA%E5%88%B6/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Binder机制 | SongHang's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SongHang's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目录"><span class="nav-number">2.</span> <span class="nav-text">目录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、Binder是什么"><span class="nav-number">2.1.</span> <span class="nav-text">一、Binder是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、为什么要用Binder"><span class="nav-number">2.2.</span> <span class="nav-text">二、为什么要用Binder</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#性能"><span class="nav-number">2.2.1.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#稳定性"><span class="nav-number">2.2.2.</span> <span class="nav-text">稳定性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#安全性"><span class="nav-number">2.2.3.</span> <span class="nav-text">安全性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三-Linux下传统的进程间通信原理"><span class="nav-number">2.3.</span> <span class="nav-text">三. Linux下传统的进程间通信原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本概念介绍"><span class="nav-number">2.3.1.</span> <span class="nav-text">基本概念介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程隔离"><span class="nav-number">2.3.2.</span> <span class="nav-text">进程隔离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程空间划分：用户空间-User-Space-内核空间-Kernel-Space"><span class="nav-number">2.3.3.</span> <span class="nav-text">进程空间划分：用户空间(User Space)&#x2F;内核空间(Kernel Space)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#系统调用：用户态与内核态"><span class="nav-number">2.3.4.</span> <span class="nav-text">系统调用：用户态与内核态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#传统-IPC-通信原理"><span class="nav-number">2.3.5.</span> <span class="nav-text">传统 IPC 通信原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、Binder跨进程通信原理"><span class="nav-number">2.4.</span> <span class="nav-text">四、Binder跨进程通信原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#动态内核可加载模块-amp-amp-内存映射"><span class="nav-number">2.4.1.</span> <span class="nav-text">动态内核可加载模块 &amp;&amp; 内存映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Binder-IPC-实现原理"><span class="nav-number">2.4.2.</span> <span class="nav-text">Binder IPC 实现原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、Binder-通信模型"><span class="nav-number">2.5.</span> <span class="nav-text">五、Binder 通信模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Client-Server-ServiceManager-驱动"><span class="nav-number">2.5.1.</span> <span class="nav-text">Client&#x2F;Server&#x2F;ServiceManager&#x2F;驱动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Binder通信过程"><span class="nav-number">2.5.2.</span> <span class="nav-text">Binder通信过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#C-S模式"><span class="nav-number">2.5.3.</span> <span class="nav-text">C&#x2F;S模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Binder通信中的代理模式"><span class="nav-number">2.5.4.</span> <span class="nav-text">Binder通信中的代理模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Binder的完整定义"><span class="nav-number">2.5.5.</span> <span class="nav-text">Binder的完整定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#六、AIDL"><span class="nav-number">2.6.</span> <span class="nav-text">六、AIDL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#各Java类职责描述"><span class="nav-number">2.6.1.</span> <span class="nav-text">各Java类职责描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AIDL语法"><span class="nav-number">2.6.2.</span> <span class="nav-text">AIDL语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用步骤"><span class="nav-number">2.6.3.</span> <span class="nav-text">使用步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#原理分析"><span class="nav-number">2.6.4.</span> <span class="nav-text">原理分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">prsuit</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/12/Binder%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="prsuit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SongHang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Binder机制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-12 22:42:35" itemprop="dateCreated datePublished" datetime="2020-08-12T22:42:35+08:00">2020-08-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Android进阶</span></a>
                </span>
            </span>

          
            <span id="/2020/08/12/Binder%E6%9C%BA%E5%88%B6/" class="post-meta-item leancloud_visitors" data-flag-title="Binder机制" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android中的Binder机制。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、Binder是什么"><a href="#一、Binder是什么" class="headerlink" title="一、Binder是什么"></a>一、Binder是什么</h4><p>Binder 是 Android 系统进程间的一种通信机制，官方介绍：</p>
<blockquote>
<p>Base class for a remotable object, the core part of a lightweight remote procedure call mechanism defined by <code>IBinder</code>. This class is an implementation of IBinder that provides standard local implementation of such an object.</p>
</blockquote>
<p>远程对象的基类，它是 IBinder 定义的轻量级远程过程调用机制的核心部分。此类是 IBinder 的实现，它提供此类本地对象的标准实现。</p>
<a id="more"></a>

<p>我们知道 Android 应用程序是由 Activity、Service、Broadcast Receiver 和 Content Provider 四大组件中的一个或者多个组成的。有时这些组件运行在同一进程，有时运行在不同的进程。这些进程间的通信就依赖于 Binder IPC 机制。不仅如此，Android 系统对应用层提供的各种服务如：ActivityManagerService、PackageManagerService 等都是基于 Binder IPC 机制来实现的。Binder 机制在 Android 中的位置非常重要。</p>
<h4 id="二、为什么要用Binder"><a href="#二、为什么要用Binder" class="headerlink" title="二、为什么要用Binder"></a>二、为什么要用Binder</h4><p>Android 系统是基于 Linux 内核的，Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制。那为什么 Android 还要提供 Binder 来实现 IPC 呢？主要是基于<strong>性能</strong>、<strong>稳定性</strong>和<strong>安全性</strong>几方面的原因。</p>
<h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。<strong>Binder 只需要一次数据拷贝</strong>，性能上仅次于共享内存。注：各种IPC方式数据拷贝次数，此表来源于<a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android Binder 设计与实现 - 设计篇</a></p>
<table>
<thead>
<tr>
<th>IPC方式</th>
<th><strong>数据拷贝次数</strong></th>
</tr>
</thead>
<tbody><tr>
<td>共享内存</td>
<td>0</td>
</tr>
<tr>
<td>Binder</td>
<td>1</td>
</tr>
<tr>
<td>Socket/管道/消息队</td>
<td>2</td>
</tr>
</tbody></table>
<h5 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h5><p>再说说稳定性，<strong>Binder 基于 C/S 架构</strong>，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</p>
<h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><p>另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。<strong>Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志</strong>。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 <strong>Binder 既支持实名 Binder，又支持匿名 Binder</strong>，安全性高。</p>
<p>基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是 Binder。</p>
<h4 id="三-Linux下传统的进程间通信原理"><a href="#三-Linux下传统的进程间通信原理" class="headerlink" title="三. Linux下传统的进程间通信原理"></a>三. Linux下传统的进程间通信原理</h4><p>了解 Linux IPC 相关的概念和原理有助于我们理解 Binder 通信原理。因此，在介绍 Binder 跨进程通信原理之前，我们先聊聊 Linux 系统下传统的进程间通信是如何实现。</p>
<h5 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h5><p>这里我们先从 Linux 中进程间通信涉及的一些基本概念开始介绍，然后逐步展开，向大家说明传统的进程间通信的原理。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghuz8xxeeej30zk0n675v.jpg" alt=""></p>
<p>上图展示了 Liunx 中跨进程通信涉及到的一些基本概念：</p>
<ul>
<li>进程隔离</li>
<li>进程空间划分：用户空间(User Space)/内核空间(Kernel Space)</li>
<li>系统调用：用户态/内核态</li>
</ul>
<h5 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h5><p>简单的说就是操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）。</p>
<h5 id="进程空间划分：用户空间-User-Space-内核空间-Kernel-Space"><a href="#进程空间划分：用户空间-User-Space-内核空间-Kernel-Space" class="headerlink" title="进程空间划分：用户空间(User Space)/内核空间(Kernel Space)"></a>进程空间划分：用户空间(User Space)/内核空间(Kernel Space)</h5><p>现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。</p>
<p><strong>内核空间</strong>：是系统内核运行的空间，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。<strong>数据可共享，所有进程共用1个内核空间</strong>。</p>
<p><strong>用户空间</strong>：是用户程序运行的空间，没有接触物理内存或设备的权限。<strong>数据不可共享</strong>。</p>
<h5 id="系统调用：用户态与内核态"><a href="#系统调用：用户态与内核态" class="headerlink" title="系统调用：用户态与内核态"></a>系统调用：用户态与内核态</h5><p>虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助<strong>系统调用</strong>来实现。<strong>系统调用是用户空间访问内核空间的唯一方式</strong>，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p>
<p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于<strong>内核运行态（内核态）</strong>。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</p>
<p>当进程在执行用户自己的代码的时候，我们称其处于<strong>用户运行态（用户态）</strong>。此时处理器在特权级最低的（3级）用户代码中运行。</p>
<p>系统调用主要通过如下两个函数来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user() &#x2F;&#x2F;将数据从用户空间拷贝到内核空间</span><br><span class="line">copy_to_user() &#x2F;&#x2F;将数据从内核空间拷贝到用户空间</span><br></pre></td></tr></table></figure>

<h5 id="传统-IPC-通信原理"><a href="#传统-IPC-通信原理" class="headerlink" title="传统 IPC 通信原理"></a>传统 IPC 通信原理</h5><p>传统的 IPC 的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copy_from_user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghv0v787nwj30zk0ogn0j.jpg" alt=""></p>
<p>这种传统的 IPC 通信方式有两个问题：</p>
<ol>
<li>性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</li>
<li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。</li>
</ol>
<h4 id="四、Binder跨进程通信原理"><a href="#四、Binder跨进程通信原理" class="headerlink" title="四、Binder跨进程通信原理"></a>四、Binder跨进程通信原理</h4><h5 id="动态内核可加载模块-amp-amp-内存映射"><a href="#动态内核可加载模块-amp-amp-内存映射" class="headerlink" title="动态内核可加载模块 &amp;&amp; 内存映射"></a>动态内核可加载模块 &amp;&amp; 内存映射</h5><p>正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的<strong>动态内核可加载模块</strong>（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<blockquote>
<p>在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 <strong>Binder 驱动</strong>（Binder Dirver）。</p>
</blockquote>
<p>那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？这就不得不通道 Linux 下的另一个概念：<strong>内存映射</strong>。</p>
<p>Binder IPC 机制中涉及到的内存映射通过 <strong>mmap()</strong> 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是<strong>将用户空间的一块内存区域映射到内核空间</strong>。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</p>
<p><strong>内存映射能减少数据拷贝次数</strong>，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。mmap能够让虚拟内存和<strong>指定</strong>物理空间（磁盘/内存）映射起来。</p>
<h5 id="Binder-IPC-实现原理"><a href="#Binder-IPC-实现原理" class="headerlink" title="Binder IPC 实现原理"></a>Binder IPC 实现原理</h5><p>Binder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。</p>
<p>比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘–&gt;内核空间–&gt;用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。</p>
<p>而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是<strong>用来在内核空间创建数据接收的缓存空间</strong>。</p>
<p>一次完整的 Binder IPC 通信过程通常是这样：</p>
<ol>
<li>首先 Binder 驱动在内核空间创建一个<strong>数据接收缓存区</strong>；</li>
<li>接着在内核空间开辟一块<strong>内核缓存区</strong>，建立<strong>内核缓存区</strong>和<strong>内核中数据接收缓存区</strong>之间的映射关系，以及<strong>内核中数据接收缓存区</strong>和<strong>接收进程用户空间地址</strong>的映射关系；</li>
<li>发送方进程通过系统调用 copy_from_user() 将数据 copy 到内核中的<strong>内核缓存区</strong>，由于<strong>内核缓存区和接收进程的用户空间都映射到数据接收缓存区，所以两者也存在内存映射关系</strong>，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li>
</ol>
<p>如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghv2qmtimuj30zk0pdwis.jpg" alt=""></p>
<p><strong>总结</strong>：</p>
<ol>
<li>Linux的虚拟内存机制导致内存的隔离，进而导致进程隔离</li>
<li>进程隔离的出现导致对内存的操作被划分为用户空间和内核空间</li>
<li>用户空间需要跨权限去访问内核空间，必须使用系统调用去实现</li>
<li>系统调用需要借助内核模块/驱动去完成</li>
</ol>
<p>前三步决定了进程间通讯需要借助<strong>内核模块/驱动</strong>去实现，而 Binder 驱动就是内核模块/驱动中用来实现进程间通讯的。</p>
<h4 id="五、Binder-通信模型"><a href="#五、Binder-通信模型" class="headerlink" title="五、Binder 通信模型"></a>五、Binder 通信模型</h4><p>介绍完 Binder IPC 的底层通信原理，接下来我们看看实现层面是如何设计的。</p>
<p>一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程（Client）和服务端进程（Server），由于进程隔离机制的存在，通信双方必然需要借助 Binder 来实现。</p>
<h5 id="Client-Server-ServiceManager-驱动"><a href="#Client-Server-ServiceManager-驱动" class="headerlink" title="Client/Server/ServiceManager/驱动"></a>Client/Server/ServiceManager/驱动</h5><p>前面我们介绍过，Binder 是基于 C/S 架构的。由一系列的组件组成，包括Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghv3pv6tj0j30zk0kv77j.jpg" alt=""></p>
<p>Client、Server、ServiceManager、Binder 驱动这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之前的关系。</p>
<p><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android Binder 设计与实现</a>一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：</p>
<blockquote>
<p><strong>Binder 驱动</strong><br>Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。 </p>
<p><strong>ServiceManager 与实名 Binder</strong><br>ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。</p>
<p>细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER_SET_CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（<strong>这就是那只预先造好的那只鸡</strong>）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。</p>
<p><strong>Client 获得实名 Binder 的引用</strong><br>Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。</p>
</blockquote>
<ul>
<li><strong>Client</strong>：客户端。</li>
<li><strong>Server</strong>：服务端。</li>
<li><strong>ServiceManager</strong>（如同DNS域名服务器）：服务的管理者，提供服务的注册和查询。将 Binder 名字转换为 Client 中对该 Binder 的引用，使得 Client 可以通过 Binder 名字获得 Server 中 Binder 实体的引用，本身也是一个 Binder 服务。</li>
<li><strong>Binder驱动</strong>（如同路由器）：进程通信的介质，负责进程之间 binder 通信的建立，传递，计数管理以及数据的传递交互等底层支持。</li>
</ul>
<h5 id="Binder通信过程"><a href="#Binder通信过程" class="headerlink" title="Binder通信过程"></a>Binder通信过程</h5><p>至此，我们大致能总结出 Binder 通信过程：</p>
<ol>
<li>首先，一个进程使用 BINDER_SET_CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>
<li>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>
</ol>
<p>架构图如下所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghv4ottvlkj30pl0cgjuv.jpg" alt=""></p>
<p>可以看出无论是注册服务和获取服务的过程都需要ServiceManager，需要注意的是此处的Service Manager是指Native层的ServiceManager（C++），并非指framework层的ServiceManager(Java)。ServiceManager是整个Binder通信机制的大管家，是Android进程间通信机制Binder的守护进程，要掌握Binder机制，首先需要了解系统是如何首次<a href="http://gityuan.com/2015/11/07/binder-start-sm/" target="_blank" rel="noopener">启动Service Manager</a>。当Service Manager启动之后，Client端和Server端通信时都需要先<a href="http://gityuan.com/2015/11/08/binder-get-sm/" target="_blank" rel="noopener">获取Service Manager</a>接口，才能开始通信服务。</p>
<p>图中Client/Server/ServiceManage之间的相互通信都是基于Binder机制。既然基于Binder机制通信，那么同样也是C/S架构，则图中的3大步骤都有相应的Client端与Server端。</p>
<ol>
<li><strong><a href="http://gityuan.com/2015/11/14/binder-add-service/" target="_blank" rel="noopener">注册服务(addService)</a></strong>：Server进程要先注册Service到ServiceManager。该过程：Server是客户端，ServiceManager是服务端。</li>
<li><strong><a href="http://gityuan.com/2015/11/15/binder-get-service/" target="_blank" rel="noopener">获取服务(getService)</a></strong>：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。该过程：Client是客户端，ServiceManager是服务端。</li>
<li><strong>使用服务</strong>：Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互。该过程：client是客户端，server是服务端。</li>
</ol>
<p>图中的Client,Server,Service Manager之间交互都是虚线表示，是由于它们彼此之间不是直接交互的，而是都通过与<a href="http://gityuan.com/2015/11/01/binder-driver/" target="_blank" rel="noopener">Binder驱动</a>进行交互的，从而实现IPC通信方式。其中Binder驱动位于内核空间，Client,Server,Service Manager位于用户空间。Binder驱动和Service Manager可以看做是Android平台的基础架构，而Client和Server是Android的应用层，开发人员只需自定义实现client、Server端，借助Android的基本平台架构便可以直接进行IPC通信。</p>
<p>注意：</p>
<ul>
<li>每个 Binder 的 Server 进程会创建很多线程来处理 Binder 请求</li>
<li>Binder 模型的线程管理 采用 Binder 驱动的线程池，并由 Binder 驱动自身进行管理，而不是由 Server 进程来管理的</li>
<li>一个进程的 Binder 线程数默认最大是16，超过的请求会被阻塞等待空闲的 Binder 线程。如使用ContentProvider 时，它的 CRUD 方法只能同时有16个线程同时工作。</li>
</ul>
<h5 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h5><p>BpBinder(客户端)和 BBinder(服务端)都是 Android 中 Binder 通信相关的代表，它们都从 IBinder 类中派生而来，它们属于 Native 层，关系图如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghw4y8di3ij30a107qq37.jpg" alt=""></p>
<ul>
<li>client端：BpBinder.transact()来发送事务请求，是 Binder 引用对象；</li>
<li>server端：BBinder.onTransact()会接收到相应事务，是 Binder 实体对象。</li>
</ul>
<h5 id="Binder通信中的代理模式"><a href="#Binder通信中的代理模式" class="headerlink" title="Binder通信中的代理模式"></a>Binder通信中的代理模式</h5><p>我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程 没法直接使用 B 进程中的 object。</p>
<p>前面我们介绍过跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。</p>
<p>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghw5dr45igj30zk0iwjtm.jpg" alt=""></p>
<ul>
<li>Binder对象：Binder机制中进行进程间通讯的对象，对于Server端为Binder本地对象，对于Client端为Binder代理对象。</li>
<li>Binder驱动：Binder机制中进行进程间通讯的介质，Binder驱动会对具有跨进程传递能力的对象做特殊处理，自动完成代理对象和本地对象的转换。因此在驱动中保存了每一个跨越进程的Binder对象的相关信息，Binder本地对象（或Binder实体）保存在binder_node的数据结构，Binder代理对象（或Binder引用/句柄）保存在binder_ref的数据结构。</li>
</ul>
<h5 id="Binder的完整定义"><a href="#Binder的完整定义" class="headerlink" title="Binder的完整定义"></a>Binder的完整定义</h5><p>现在我们可以对 Binder 做个更加全面的定义了：</p>
<ul>
<li>从进程间通信的角度看，Binder 是一种进程间通信的机制；</li>
<li>从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象；</li>
<li>从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理；</li>
<li>从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象做特殊处理，自动完成代理对象和本地对象之间的转换；</li>
<li>从 Android Driver 层的角度看，Binder 是一种虚拟的物理设备，它的设备驱动是 /dev/binder；</li>
<li>从 Android Framework 来讲，Binder是 Service Manager 连接各种 Manager 和对应的 ManagerService 的桥梁。</li>
</ul>
<h4 id="六、AIDL"><a href="#六、AIDL" class="headerlink" title="六、AIDL"></a>六、AIDL</h4><p>通常我们在做开发时，实现进程间通信用的最多的就是 AIDL——Android接口定义语言。当我们定义好 AIDL 文件，在编译时编译器会帮我们生成代码实现 IPC 通信。借助 AIDL 编译以后的代码能帮助我们进一步理解 Binder IPC 的通信原理。基于Binder，Android还实现了其他的IPC方式，比如 Messenger 和 ContentProvider 。</p>
<p>但是无论是从可读性还是可理解性上来看，编译器生成的代码对开发者并不友好。比如一个 BookManager.aidl 文件对应会生成一个 BookManager.java 文件，这个 java 文件包含了一个 BookManager 接口、一个 Stub 静态的抽象类和一个 Proxy 静态类。Proxy 是 Stub 的静态内部类，Stub 又是 BookManager 的静态内部类，这就造成了可读性和可理解性的问题。</p>
<blockquote>
<p>Android 之所以这样设计其实是有道理的，因为当有多个 AIDL 文件的时候把 BookManager、Stub、Proxy 放在同一个文件里能有效避免 Stub 和 Proxy 重名的问题。</p>
</blockquote>
<h5 id="各Java类职责描述"><a href="#各Java类职责描述" class="headerlink" title="各Java类职责描述"></a>各Java类职责描述</h5><p>在正式编码实现跨进程调用之前，先介绍下实现过程中用到的一些类。了解了这些类的职责，有助于我们更好的理解和实现跨进程通信。</p>
<ul>
<li><strong>IBinder</strong>：是一个接口，定义了Java层Binder通信的一些规则；提供了transact方法来调用远程服务，代表了一种跨进程通信的能力。只要实现了这个接口，这个对象就能跨进程传输。这是 Binder 驱动底层支持的，Binder 驱动会自动完成不同进程 Binder 本地对象以及Binder 代理对象的转换。</li>
<li><strong>IInterface</strong>：Client 端与 Server 端的调用契约，代表了 Server 进程对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口方法），所有的服务提供者，必须继承这个接口。</li>
<li><strong>Binder</strong>：Java 层的 Binder 类，代表的就是 Binder 本地对象。BinderProxy 类是代表远程进程的 Binder 本地对象的代理；这两个类都继承自 IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换。</li>
<li><strong>Stub</strong>：AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类；这个类继承了 Binder，说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。这里使用了策略模式。</li>
<li><strong>Proxy</strong>：服务端 Binder 本地对象代理，客户端通过这个类调用服务端的方法。</li>
<li><strong>Parcel</strong>：是一个容器，它主要用于存储序列化数据，然后可以通过 Binder 在进程间传递这些数据。</li>
</ul>
<h5 id="AIDL语法"><a href="#AIDL语法" class="headerlink" title="AIDL语法"></a>AIDL语法</h5><ul>
<li><p>文件类型：用AIDL书写的文件的后缀是 .aidl，而不是 .java。</p>
</li>
<li><p>数据类型：AIDL默认支持一些数据类型，在使用这些数据类型的时候是不需要导包的，但是除了这些类型之外的数据类型，在使用之前必须导包，<strong>就算目标文件与当前正在编写的 .aidl 文件在同一个包下</strong>——在 Java 中，这种情况是不需要导包的。比如，现在我们编写了两个文件，一个叫做 <strong>Book.java</strong> ，另一个叫做 <strong>BookManager.aidl</strong>，它们都在 <strong>com.prsuit.androidlearnsample</strong> 包下 ，现在我们需要在 .aidl 文件里使用 Book 对象，那么我们就必须在 .aidl 文件里面写上 <strong><code>import com.prsuit.androidlearnsample.Book;</code></strong> 哪怕 .java 文件和 .aidl 文件就在一个包下。<br>默认支持的数据类型包括： </p>
<ul>
<li>Java 中的基本数据类型( byte，short(不支持short，编译不通过)，int，long，float，double，boolean，char)，String 和 CharSequence类型。</li>
<li>List 和 Map：元素必须是 AIDL 支持的数据类型之一，Server 端具体的类里必须是 ArrayList 或者 HashMap。</li>
<li>AILD：其他 AIDL 生成的接口。</li>
<li>除了默认支持的数据类型外，AIDL 还支持自定义实现 Parcelable 接口的数据类型。</li>
</ul>
</li>
<li><p>定向tag：方法内如果有传输载体，就必须指明定向 tag (<a href="http://blog.csdn.net/luoyanglizi/article/details/51958091" target="_blank" rel="noopener">in,out,inout</a>)。</p>
<ul>
<li>in：<strong>客户端数据对象流向服务端</strong>，并且服务端对该数据对象的修改不会影响到客户端。</li>
<li>out： <strong>数据对象由服务端流向客户端</strong>，（客户端传递的数据对象此时服务端收到的对象内容为空，服务端可以对该数据对象修改，并传给客户端）。</li>
<li>inout：<strong>数据可在服务端与客户端之间双向流通</strong>，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。（但是不建议用此 tag，会增加开销）。</li>
</ul>
</li>
<li><p>两种AIDL文件：<strong>一类是用来定义 parcelable 对象</strong>，以供其他 AIDL 文件使用非默认支持的数据类型。<strong>一类是用来定义方法接口</strong>，以供系统使用来完成跨进程通信的。<strong>所有的非默认支持数据类型必须通过第一类AIDL文件定义才能被使用。</strong></p>
</li>
</ul>
<h5 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h5><p><strong>创建实体类</strong></p>
<p>实体类要实现 Parcelable 接口，且要手动添加 <code>readFromParcel</code> 方法（不然只支持 in 的定向tag）。</p>
<p>注：<strong>若AIDL文件中涉及到的所有数据类型均为默认支持的数据类型，则无此步骤。因为默认支持的那些数据类型都是可序列化的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = in.readString();</span><br><span class="line">        <span class="keyword">this</span>.price = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Book&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法不是Parcelable自动生成的，需要自己手动添加，</span></span><br><span class="line">    <span class="comment">// 如果不添加，则在使用AIDL时只支持 in 的定向tag</span></span><br><span class="line">    <span class="comment">// 如果添加了，则支持 out、inout</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFromParcel</span><span class="params">(Parcel dest)</span></span>&#123;</span><br><span class="line">      <span class="comment">//注意，此处的读值顺序应当是和writeToParcel()方法中一致的</span></span><br><span class="line">        name = dest.readString();</span><br><span class="line">        price = dest.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">//get set方法</span></span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建定义parcelable对象的AIDL文件</strong></p>
<p>因为AIDL这个语言的规范就是 aidl 文件，所以我们必须将<code>Book</code>实体类转为 aidl 文件，供其它 aidl 的调用与交互。<strong>Book.aidl与Book.java的包名要是一样的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Book.aidl</span></span><br><span class="line"><span class="comment">//第一类AIDL文件</span></span><br><span class="line"><span class="comment">//这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用</span></span><br><span class="line"><span class="comment">//注意：Book.aidl与Book.java的包名应当是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.prsuit.androidlearnsample;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"><span class="comment">//注意parcelable是小写</span></span><br><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure>

<p>如何在保证两个文件包名一样的情况下，让系统能够找到我们的 java 文件？思路：要么让系统来 aidl 包里面来找 java 文件，要么把 java 文件放到系统能找到的地方去，也即放到 java 包里面去。这两种方式具体做法：</p>
<ul>
<li><p>修改 build.gradle 文件，通过 sourceSets 配置把 java 的访问路径设置成了 java 包和 aidl 包，在 android{} 中加上下面的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        java.srcDirs = [<span class="string">'src/main/java'</span>, <span class="string">'src/main/aidl'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把 java 文件放到 java 包下去：把 Book.java 放到 java 包里任意一个包下，保持其包名不变，与 Book.aidl 一致。只要它的包名不变，Book.aidl 就能找到 Book.java ，而只要 Book.java 在 java 包下，那么系统也是能找到它的。注意在移植相关 .aidl 文件时，不能直接把整个 aidl 文件夹拿过去完事了，还要单独将 .java 文件放到 java 文件夹里去。</p>
</li>
</ul>
<p><strong>创建定义方法接口的AIDL文件</strong></p>
<p>该文件是 Client 端与 Server 端的调用契约，定义 Server 进程对象具备什么样的能力。</p>
<p>注：<strong>接口方法 aidl 中不能存在同方法名不同参数的方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.prsuit.androidlearnsample;</span><br><span class="line"><span class="keyword">import</span> com.prsuit.androidlearnsample.Book;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//有返回值前都不需要加任何东西，不管是什么数据类型</span></span><br><span class="line">  <span class="function">List&lt;Book&gt; <span class="title">getBooks</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Java基本类型以及String，CharSequence的 tag 默认且只能是 in</span></span><br><span class="line">  <span class="comment">//传参时除了Java基本类型以及String，CharSequence之外的类型</span></span><br><span class="line">  <span class="comment">//如果有传输对象载体，就必须指明定向tag(in,out,inout)</span></span><br><span class="line">  <span class="function">Book <span class="title">addBookIn</span><span class="params">(in Book book)</span></span>;<span class="comment">//客户端-&gt;服务端</span></span><br><span class="line">  <span class="comment">//out和inout都需要重写MessageBean的readFromParcel方法</span></span><br><span class="line">  <span class="function">Book <span class="title">addBookOut</span><span class="params">(out Book book)</span></span>;<span class="comment">//服务端-&gt;客户端</span></span><br><span class="line">  <span class="function">Book <span class="title">addBookInOut</span><span class="params">(inout Book book)</span></span>;<span class="comment">//客户端&lt;-&gt;服务端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编写服务端代码</strong></p>
<p>在我们写完AIDL文件并 Make Project 项目之后，编译器会根据AIDL文件为我们生成一个与AIDL文件同名的 .java 文件，这个 .java 文件才是与我们的跨进程通信密切相关的东西。在服务端实现AIDL中定义的方法接口的具体逻辑，创建一个服务，用来处理客户端发来的请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 服务端的AIDLService.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIDLService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = <span class="string">"AIDLService"</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; mBooks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由AIDL文件生成的IBookManager</span></span><br><span class="line">    <span class="keyword">private</span> IBookManager.Stub mBookManager = <span class="keyword">new</span> IBookManager.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBooks</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"getBooks: "</span>+ mBooks.toString());</span><br><span class="line">            <span class="keyword">if</span> (mBooks != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> mBooks;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">addBookIn</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookIn: 接收到的对象--&gt;"</span>+book.toString() );</span><br><span class="line">            <span class="keyword">if</span> (book == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"addBookIn: book is null in In"</span>);</span><br><span class="line">                book = <span class="keyword">new</span> Book();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尝试修改book的参数，主要是为了观察其到客户端的反馈</span></span><br><span class="line">            book.setPrice(<span class="number">2333</span>);</span><br><span class="line">            <span class="keyword">if</span> (!mBooks.contains(book))&#123;</span><br><span class="line">                mBooks.add(book);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookIn: now the list is "</span>+mBooks.toString() );</span><br><span class="line">            <span class="keyword">return</span> book;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">addBookOut</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookOut: 接收到的对象--&gt;"</span>+book.toString() );</span><br><span class="line">            <span class="keyword">if</span> (book == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"addBookOut: book is null in Out"</span>);</span><br><span class="line">                book = <span class="keyword">new</span> Book();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尝试修改book的参数，主要是为了观察其到客户端的反馈</span></span><br><span class="line">            book.setPrice(<span class="number">2333</span>);</span><br><span class="line">            <span class="keyword">if</span> (!mBooks.contains(book))&#123;</span><br><span class="line">                mBooks.add(book);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookOut: now the list is "</span>+ mBooks.toString());</span><br><span class="line">            <span class="keyword">return</span> book;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">addBookInOut</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookInOut: 接收到的对象--&gt;"</span>+book.toString() );</span><br><span class="line">            <span class="keyword">if</span> (book == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"addBookInOut: book is null in InOut"</span>);</span><br><span class="line">                book = <span class="keyword">new</span> Book();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尝试修改book的参数，主要是为了观察其到客户端的反馈</span></span><br><span class="line">            book.setPrice(<span class="number">2333</span>);</span><br><span class="line">            <span class="keyword">if</span> (!mBooks.contains(book))&#123;</span><br><span class="line">                mBooks.add(book);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookInOut: now the list is "</span>+ mBooks.toString());</span><br><span class="line">            <span class="keyword">return</span> book;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"onCreate: AIDLService"</span> );</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setName(<span class="string">"Android 开发艺术探索"</span>);</span><br><span class="line">        book.setPrice(<span class="number">20</span>);</span><br><span class="line">        mBooks.add(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"onBind: AIDLService"</span> );</span><br><span class="line">        <span class="keyword">return</span> mBookManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体的代码结构很清晰，大致可以分为三块：第一块是<strong>初始化</strong>。在 onCreate() 方法里面我进行了一些数据的初始化操作。第二块是<strong>重写 IBookManager.Stub 中的方法</strong>。在这里面提供AIDL里面定义的方法接口的具体实现逻辑。第三块是<strong>重写 onBind() 方法</strong>，返回 IBookManager.Stub 对象。</p>
<p>接下来在 Manefest 文件里面注册这个我们写好的 Service ，添加 action 以便客户端可以隐式启动该服务。如果在同一个项目中可通过设置<code>android:process</code> 处于不同进程。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">    android:name=<span class="string">".service.AIDLService"</span></span><br><span class="line">    android:process=<span class="string">":remote"</span></span><br><span class="line">    android:exported=<span class="string">"true"</span>&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=<span class="string">"com.prsuit.aidl.bookmanager"</span>/&gt;</span><br><span class="line">            &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>

<p><strong>编写客户端代码</strong></p>
<p>如果是在不同项目中，则需要拷贝 AIDL 文件夹和相关 Java 文件，aidl 移植完后，客户端主要工作是连接上服务端，调用服务端的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端的AIDLActivity.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIDLActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = <span class="string">"AIDLActivity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IBookManager mBookManager = <span class="keyword">null</span>;<span class="comment">//服务端binder对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mBound = <span class="keyword">false</span>;<span class="comment">//是否连接上服务端</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; mBooks;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mServiceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            mBookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line">            mBound = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (mBookManager != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  mBooks = mBookManager.getBooks();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_a_i_d_l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用服务端的addBookIn方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBookIn</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mBound)&#123;</span><br><span class="line">            toBindService();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mBookManager == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setName(<span class="string">"App 开发In"</span>);</span><br><span class="line">        book.setPrice(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获得服务端执行方法的返回值，并打印输出</span></span><br><span class="line">            Book returnBook = mBookManager.addBookIn(book);</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookIn: Client book："</span>+book.toString() );</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookIn: server 返回book："</span>+returnBook.toString() );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用服务端的addBookOut方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBookOut</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mBound)&#123;</span><br><span class="line">            toBindService();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mBookManager == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setName(<span class="string">"App 开发Out"</span>);</span><br><span class="line">        book.setPrice(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获得服务端执行方法的返回值，并打印输出</span></span><br><span class="line">            Book returnBook = mBookManager.addBookOut(book);</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookOut: Client book："</span>+book.toString() );</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookOut: server 返回book："</span>+returnBook.toString() );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用服务端的addBookInOut方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBookInOut</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mBound)&#123;</span><br><span class="line">            toBindService();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mBookManager == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setName(<span class="string">"App 开发InOut"</span>);</span><br><span class="line">        book.setPrice(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获得服务端执行方法的返回值，并打印输出</span></span><br><span class="line">            Book returnBook = mBookManager.addBookInOut(book);</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookInOut: Client book："</span>+book.toString() );</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookInOut: server 返回book："</span>+returnBook.toString() );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        <span class="keyword">if</span> (!mBound)&#123;</span><br><span class="line">            toBindService();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试与服务端建立连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toBindService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setAction(<span class="string">"com.prsuit.aidl.bookmanager"</span>);</span><br><span class="line">        <span class="comment">//5.0版本后隐式启动服务报错，必须给Intent设置包名</span></span><br><span class="line">        intent.setPackage(<span class="string">"com.prsuit.androidlearnsample"</span>);</span><br><span class="line">        bindService(intent,mServiceConnection,BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        <span class="keyword">if</span> (mBound)&#123;</span><br><span class="line">            unbindService(mServiceConnection);</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样很清晰，首先建立连接，然后在 ServiceConnection 里面获取 IBookManager 对象，接着通过它来调用服务端的方法。</p>
<h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p>先用一张图整体描述这个AIDL从客户端(Client)发起请求至服务端(Server)相应的工作流程，我们可以看出整体的核心就是Binder。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghxfotybjhj30zs0dy75l.jpg" alt=""></p>
<p>首先看下客户端的 IBookManager 对象是怎么来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">           mBookManager = IBookManager.Stub.asInterface(service);</span><br></pre></td></tr></table></figure>

<p><strong>asInterface()</strong>：</p>
<blockquote>
<p>用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的【如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象】</p>
</blockquote>
<p>注意到方法的传参：IBinder service ，这是个 BinderProxy 对象，接下来顺藤摸瓜去看下这个 BookManager.Stub.asInterface() 是怎么回事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.prsuit.androidlearnsample.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">    <span class="comment">//验空</span></span><br><span class="line">     <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="comment">//DESCRIPTOR = "com.prsuit.androidlearnsample.IBookManager"，搜索本地是否有可用的对象</span></span><br><span class="line">   <span class="comment">//如果找到了就说明 Client 和 Server 在同一进程，那么这个 binder 本身就是 Binder 本地对象</span></span><br><span class="line">     android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">     <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.prsuit.androidlearnsample.IBookManager))) &#123;</span><br><span class="line">       <span class="keyword">return</span> ((com.prsuit.androidlearnsample.IBookManager)iin);</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="comment">//如果本地没有的话，说明是 binder 是个远程对象，就新建一个代理对象Proxy返回</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> com.prsuit.androidlearnsample.IBookManager.Stub.Proxy(obj);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出通过<code>DESCRIPTOR</code>标识去查找本地是否有可用对象，如果有则是同一进程，那么就返回Stub对象本身，如果没找到则是不同进程，返回Stub的代理内部类Proxy。</p>
<p><strong>Proxy</strong>：</p>
<p>看看Stub的代理内部类IBookManager.Stub.Proxy 类，客户端最终是通过这个类与服务端进行通信。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">prsuit</span>.<span class="title">androidlearnsample</span>.<span class="title">IBookManager</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">      Proxy(android.os.IBinder remote)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//此处的 remote 正是前面我们提到的 IBinder service</span></span><br><span class="line">        mRemote = remote;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DESCRIPTOR;<span class="comment">//Binder的唯一标识</span></span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">      <span class="meta">@Override</span> </span><br><span class="line">   <span class="keyword">public</span> java.util.List&lt;com.prsuit.androidlearnsample.Book&gt; getBooks() <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//_data用来存储流向服务端的数据流</span></span><br><span class="line">        android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">        <span class="comment">//_reply用来存储服务端流回客户端的数据流</span></span><br><span class="line">        android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">        java.util.List&lt;com.prsuit.androidlearnsample.Book&gt; _result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">          <span class="comment">//调用 transact() 方法将方法id和两个 Parcel 容器传过去</span></span><br><span class="line">          <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getBooks, _data, _reply, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getDefaultImpl().getBooks();</span><br><span class="line">          &#125;</span><br><span class="line">          _reply.readException();</span><br><span class="line">           <span class="comment">//从_reply中取出服务端执行方法的结果</span></span><br><span class="line">          _result = _reply.createTypedArrayList(com.prsuit.androidlearnsample.Book.CREATOR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          _reply.recycle();</span><br><span class="line">          _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将结果返回</span></span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span> </span><br><span class="line">   <span class="keyword">public</span> com.prsuit.androidlearnsample.<span class="function">Book <span class="title">addBookIn</span><span class="params">(com.prsuit.androidlearnsample.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">       <span class="comment">//省略</span></span><br><span class="line">      &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>transact()</strong> ：</p>
<blockquote>
<p><code>transact</code>方法运行在客户端，首先它创建该方法所需要的输入型Parcel对象_data、输出型Parcel对象_reply;<br>接着调用绑定服务传来的IBinder对象的transact方法来发起远程过程调用（RPC）请求，同时当前线程挂起;<br>然后服务端的<code>onTransact</code>方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，也就是返回_reply中的数据。</p>
</blockquote>
<p>这是客户端和服务端通信的核心方法。调用这个方法之后，客户端将会挂起当前线程，等候服务端执行完相关任务后通知并接收返回的 _reply 数据流。关于这个方法的传参，这里需要说明的地方：</p>
<ul>
<li><p>方法 ID ：transact() 方法的第一个参数是一个方法 ID ，这个是客户端与服务端约定好的给方法的编码，彼此一一对应。在AIDL文件转化为 .java 文件的时候，系统将会自动给AIDL文件里面的每一个方法自动分配一个方法 ID。</p>
</li>
<li><p>关于 _data 与 _reply 对象：一般来说，我们会将方法的传参的数据存入_data 中，而将方法的返回值的数据存入 _reply 中——在没涉及定向 tag 的情况下。</p>
</li>
<li><p>第四个参数：transact() 方法的第四个参数是一个 int 值，它的作用是设置进行 IPC 的模式，为 0 表示数据可以双向流通，即 _reply 流可以正常的携带数据回来，如果为 1 的话那么数据将只能单向流通，从服务端回来的 _reply 流将不携带任何数据。 </p>
</li>
<li><p>关于 Parcel ：简单的来说，Parcel 是一个用来存放和读取数据的容器。我们可以用它来进行客户端和服务端之间的数据传输，当然，它能传输的只能是可序列化的数据。</p>
<p>注：AIDL生成的 .java 文件的这个参数均为 0。</p>
</li>
</ul>
<p>客户端的一般工作流程：</p>
<ol>
<li>生成 _data 和 _reply 数据流，并向 _data 中存入客户端的数据。</li>
<li>通过 transact() 方法将它们传递给服务端，并请求服务端调用指定方法。</li>
<li>接收 _reply 数据流，并从中取出服务端传回来的数据。</li>
</ol>
<p><strong>Stub</strong>：</p>
<p>接下来看服务端Stub类，在服务端有一个方法<code>onTransact()</code>来接收客户端传过来的参数并进行处理。这个<code>onTransact</code>方法就是服务端处理的核心，接收到客户端的请求，并且通过客户端携带的参数，执行完服务端的方法，返回结果。IBookManager.Stub类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">prsuit</span>.<span class="title">androidlearnsample</span>.<span class="title">IBookManager</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.prsuit.androidlearnsample.IBookManager"</span>;</span><br><span class="line">    <span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">    &#125; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line">      <span class="keyword">switch</span> (code)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">          reply.writeString(descriptor);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_getBooks:</span><br><span class="line">        &#123;</span><br><span class="line">          data.enforceInterface(descriptor);</span><br><span class="line">          <span class="comment">//调用 this.getBooks() 方法，在这里开始执行具体的事务逻辑</span></span><br><span class="line">          <span class="comment">//result 列表为调用 getBooks() 方法的返回值</span></span><br><span class="line">          java.util.List&lt;com.prsuit.androidlearnsample.Book&gt; _result = <span class="keyword">this</span>.getBooks();</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          <span class="comment">//将方法执行的结果写入 reply </span></span><br><span class="line">          reply.writeTypedList(_result);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_addBookIn:</span><br><span class="line">        &#123;</span><br><span class="line">          data.enforceInterface(descriptor);</span><br><span class="line">          com.prsuit.androidlearnsample.Book _arg0;</span><br><span class="line">          <span class="keyword">if</span> ((<span class="number">0</span>!=data.readInt())) &#123;</span><br><span class="line">            _arg0 = com.prsuit.androidlearnsample.Book.CREATOR.createFromParcel(data);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            _arg0 = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          com.prsuit.androidlearnsample.Book _result = <span class="keyword">this</span>.addBookIn(_arg0);</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          <span class="keyword">if</span> ((_result!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">            reply.writeInt(<span class="number">1</span>);</span><br><span class="line">            _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            reply.writeInt(<span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>onTransact()</strong>：</p>
<blockquote>
<p><code>onTransact</code>方法运行在服务端中的Binder线程池中<br>客户端发起跨进程请求时，远程请求会通过系统底层封装后交给此方法来处理。<br>如果此方法返回false,那么客户端的请求就会失败。</p>
</blockquote>
<p>在 onTransact 方法中直接调用服务端的具体方法实现，如果目标方法有参数的话，就从data取出目标方法所需的参数，当目标方法执行完毕后，如果目标方法有返回值，就向reply中写入返回值。</p>
<p>服务端的一般工作流程：</p>
<ol>
<li>获取客户端传过来的数据，根据方法 ID 执行相应操作。</li>
<li>将传过来的数据取出来，调用本地写好的对应方法。</li>
<li>将需要回传的数据写入 reply 流，传回客户端。</li>
</ol>
<p><strong>Stub与Proxy区别</strong></p>
<p>Proxy与Stub不一样，虽然他们都既是Binder又是IInterface，不同的是Stub采用的是继承（is 关系），Proxy采用的是组合（has 关系）。他们均实现了所有的IInterface函数，不同的是，Stub又使用策略模式调用的是虚函数（待子类实现），而Proxy则使用组合模式。为什么Stub采用继承而Proxy采用组合？事实上，Stub本身is一个IBinder（Binder），它本身就是一个能跨越进程边界传输的对象，所以它得继承IBinder实现transact这个函数从而得到跨越进程的能力（这个能力由驱动赋予）。Proxy类使用组合，是因为他不关心自己是什么，它也不需要跨越进程传输，它只需要拥有这个能力即可，要拥有这个能力，只需要保留一个对IBinder的引用。在Stub类里面，asBinder返回this，在Proxy里面返回的是持有的组合类IBinder的引用。</p>
<p>一个需要跨进程传递的对象一定继承自 IBinder，如果是 Binder 本地对象，那么一定继承 Binder 实现IInterface，如果是代理对象，那么就实现了 IInterface 并持有了 IBinder 引用。</p>
<p><strong>Binder传输数据的大小限制</strong></p>
<p>普通的由Zygote孵化而来的用户进程，所映射的<strong>Binder内存大小是不到1M的</strong>，准确说是 1x1024x1024) - (4096 x2)，这个限制定义在ProcessState类中，如果传输说句超过这个大小，系统就会报错，而在内核中，其实也有个限制，是4M，不过由于APP中已经限制了不到1M。</p>
<p>有个特殊的进程ServiceManager进程，它为自己申请的Binder内核空间是128K，这个同ServiceManager的用途是分不开的，ServcieManager主要面向系统Service，只是简单的提供一些addServcie，getService的功能，不涉及多大的数据传输，因此不需要申请多大的内存。</p>
<p><strong>ServiceManager addService的限制</strong></p>
<p>ServiceManager 其实主要的面向对象是<strong>系统服务</strong>，比如AMS、WMS、PKMS服务等，并非所有服务都能通过addService 添加到 ServiceManager，在通过ServiceManager添加服务的时候，是有些权限校验的，大部分系统服务都是由 SystemServer 进程中添加到ServiceManager中去的。而APP通过的 bindService 启动的 Binder 服务其实是*<em>由 SystemServer 的 ActivityManagerService *</em>负责管理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Binder通信的实质是利用内存映射，将用户进程的内存地址和内核的内存地址映射为同一块物理地址，也就是说他们使用的同一块物理空间。 </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghyk9gwafcj30qo0t5qc1.jpg" alt=""></p>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://juejin.im/post/6844903589635162126" target="_blank" rel="noopener">写给 Android 应用工程师的 Binder 原理剖析</a></p>
<p><a href="https://www.jianshu.com/p/4ee3fd07da14" target="_blank" rel="noopener">图文详解 Android Binder跨进程通信的原理</a></p>
<p><a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列—开篇</a></p>
<p><a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android Bander设计与实现 - 设计篇</a></p>
<p><a href="https://www.jianshu.com/p/485233919c15" target="_blank" rel="noopener">Android跨进程通信IPC之13——Binder总结</a></p>
<p><a href="https://blog.csdn.net/qian520ao/article/details/78072250" target="_blank" rel="noopener">Android 深入浅出AIDL（一）</a></p>
<p><a href="https://blog.csdn.net/qian520ao/article/details/78074983" target="_blank" rel="noopener">Android 深入浅出AIDL（二）</a></p>
<p><a href="https://blog.csdn.net/luoyanglizi/article/details/51958091" target="_blank" rel="noopener">你真的理解AIDL中的in，out，inout么？</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android%E8%BF%9B%E9%98%B6/" rel="tag"># Android进阶</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/10/Handler%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="prev" title="Handler常见面试题">
      <i class="fa fa-chevron-left"></i> Handler常见面试题
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/14/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8-%E7%BB%BC%E8%BF%B0/" rel="next" title="Android系统启动-综述">
      Android系统启动-综述 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">prsuit</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"wcHVHcMfvijlbh1aHD87HwFg-gzGzoHsz","app_key":"LuS6lIabezmhCePy6QOd6WnR","server_url":"https://prsuit.github.io/","security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
