<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Activity必备基础</title>
    <url>/2020/07/23/Activity%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android的四大组件之一的Activity。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、Activity是什么"><a href="#一、Activity是什么" class="headerlink" title="一、Activity是什么"></a>一、Activity是什么</h4><p>我们都知道android中有四大组件（Activity 活动，Service 服务，BroadcastReceiver 广播接收器，Content Provider 内容提供者），Activity是用的最多也是最基本的组件，Activity 提供窗口来和用户进行交互的组件。官方是这么介绍的：</p>
<a id="more"></a>

<blockquote>
<p>An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View).</p>
<p>一个activity是一个单独的，用来处理用户操作的窗口。几乎所有的activity都是用来和用户交互的，所以activity类会创建了一个窗口，你可以通过setContentView(View)显示你的UI在窗口上。</p>
</blockquote>
<ul>
<li>Activity是一个应用程序组件，提供一个屏幕，用户可以用来交互为了完成某项任务。</li>
<li>Activity中所有操作都与用户密切相关，是一个负责与用户交互的组件，可以通过setContentView(View)来显示指定控件。</li>
</ul>
<h4 id="二、Activity状态及转换"><a href="#二、Activity状态及转换" class="headerlink" title="二、Activity状态及转换"></a>二、Activity状态及转换</h4><p>在android 中，Activity 拥有四种基本状态：</p>
<p>1.<strong>Active/Running</strong></p>
<p>​    一个新 Activity 启动入栈后，它显示在屏幕最前端，处理是处于栈的最顶端（Activity栈顶），此时它处于可见并可和用户交互的激活状态，叫做活动状态或者运行状态（active or running）。</p>
<p>2.<strong>Paused</strong></p>
<p>​    当 Activity 失去焦点，被另一个透明或者 Dialog 样式非全屏的 Activity 覆盖时的状态，叫做暂停状态（Paused）。此时它依然与窗口管理器保持连接，系统继续维护其内部状态，所以它仍然可见，但它已经失去了焦点故不可与用户交互。</p>
<p>3.<strong>Stopped</strong></p>
<p>​    当 Activity 被另外一个 Activity 完全覆盖掉，不可再见时的状态叫做停止状态（Stopped）。</p>
<p>4.<strong>Killed</strong></p>
<p>​    Activity 被系统杀死回收或者没有被启动时的状态，叫做被杀死的状态（Killed）。</p>
<p>下图说明了 Activity 在不同状态间转换的时机和条件：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5lxx3ssej308n081dfu.jpg" alt=""></p>
<h4 id="三、Activity栈"><a href="#三、Activity栈" class="headerlink" title="三、Activity栈"></a>三、Activity栈</h4><p>Android 是通过一种 Activity 栈的方式来管理 Activity 的，一个 Activity 的实例的状态决定它在栈中的位置。处于前台的 Activity 总是在栈的顶端，当前台的 Activity 因为异常或其它原因被销毁时，处于栈第二层的 Activity 将被激活，上浮到栈顶。当新的 Activity 启动入栈时，原 Activity 会被压入到栈的第二层。一个 Activity 在栈中的位置变化反映了它在不同状态间的转换。Activity 的状态与它在栈中的位置关系如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5m9bc21zj308w05r748.jpg" alt=""></p>
<p>如上所示，除了最顶层即处在 Active 状态的 Activity 外，其它的 Activity 都有可能在系统内存不足时被回收，一个 Activity 的实例越是处在栈的底层，它被系统回收的可能性越大。系统负责管理栈中 Activity 的实例，它根据 Activity 所处的状态来改变其在栈中的位置。</p>
<h4 id="四、Activity生命周期"><a href="#四、Activity生命周期" class="headerlink" title="四、Activity生命周期"></a>四、Activity生命周期</h4><p>生命周期函数，常用的7个如下：</p>
<p><strong>onCreate()</strong>：表示 Activity <strong>正在被创建</strong>，常用来<strong>初始化工作</strong>，比如调用 setContentView 加载界面布局资源，初始化 Activity 所需数据等；</p>
<p><strong>onReStart()</strong>：表示 Activity <strong>正在重新启动</strong>，当前 Acitivty 从不可见重新变为可见时，onRestart 就会被调用；</p>
<p><strong>onStart()</strong>：表示 Activity <strong>正在被启动</strong>，此时 Activity <strong>可见但不在前台</strong>，还处于后台，无法与用户交互；</p>
<p><strong>onResume()</strong>：表示 Activity <strong>获得焦点</strong>，此时 Activity <strong>可见且在前台</strong>并开始活动，位于活动堆栈的顶部，这是与onStart的区别所在；</p>
<p><strong>onPause()</strong>：表示 Activity <strong>正在停止</strong>，<strong>可见但不在前台</strong>，此时可做一些<strong>存储数据、停止动画</strong>等工作，但是不能太耗时，因为这会影响到新 Activity 的显示，onPause 必须先执行完，新 Activity 的 onResume 才会执行；</p>
<p><strong>onStop()</strong>：表示 Activity <strong>即将停止</strong>，被新 activity 覆盖了，对用户<strong>不可见</strong>，可以做一些稍微重量级的回收工作，比如注销广播接收器、关闭网络连接等，同样不能太耗时；</p>
<p><strong>onDestroy()</strong>：表示 Activity <strong>即将被销毁</strong>，这是 Activity 生命周期中的最后一个回调，常做<strong>回收工作、资源释放</strong>；</p>
<ul>
<li>延伸：从<strong>整个生命周期</strong>来看，<strong>onCreate</strong> 和 <strong>onDestroy</strong> 是配对的，分别标识着 Activity 的创建和销毁，并且只可能有<strong>一次调用</strong>； 从 Activity <strong>是否可见</strong>来说，<strong>onStart</strong> 和 <strong>onStop</strong> 是配对的，这两个方法可能被<strong>调用多次</strong>； 从 Activity <strong>是否在前台</strong>来说，<strong>onResume</strong> 和 <strong>onPause</strong> 是配对的，这两个方法可能被<strong>调用多次</strong>； 除了这种区别，在实际使用中没有其他明显区别。</li>
</ul>
<p>Activity 生命周期循环图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5o2g5wxnj30e90if75q.jpg" alt=""></p>
<p><strong>onSaveInstanceState()</strong>：发生条件在系统配置发生改变（例如屏幕方向）导致 Activity 被杀死并重新创建、资源内存不足导致低优先级的 Activity 被杀死，系统会调用 <strong>onSaveInstanceState</strong> 来保存当前 Activity 的状态，此方法调用在 onStop 之后 和 onDestory 之前；</p>
<p><strong>onRestoreInstanceState()</strong>： 当 Activity 被重建后，系统会调用 <strong>onRestoreInstanceState</strong>，并且把onSaveInstanceState 方法所保存的 Bundle 对象<strong>同时传参</strong>给 onRestoreInstanceState() 和 onCreate() ，因此可以通过这两个方法判断 Activity <strong>是否被重建</strong>，调用在 onStart 之后，可使用 onSaveInstanceState() 和onRestoreInstanceState()（或onCreate()）来保存和恢复 Activity 活动状态。</p>
<h4 id="五、Activity启动和通信"><a href="#五、Activity启动和通信" class="headerlink" title="五、Activity启动和通信"></a>五、Activity启动和通信</h4><p><strong>Intent</strong>是一种消息传递的机制，它负责对操作的动作、动作涉及数据、附加数据进行描述。Android 则根据此Intent的描述，负责找到对应的组件，将 Intent 传递给调用的组件，并完成组件的调用。</p>
<h5 id="显式Intent"><a href="#显式Intent" class="headerlink" title="显式Intent"></a>显式Intent</h5><p>通过指定具体的组件类，通知应用启动对应的组件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClass(MainActivity.<span class="keyword">this</span>,SecondAcvivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">intent.putExtra(<span class="string">"values"</span>,<span class="string">"传个值"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<h5 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h5><p>通过指定了一系列更为抽象的 action 和 category 等信息，然后交由系统去分析这个 Intent，并帮我们找出合适的活动去启动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.administrator.ACTION_START"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>要在清单文件中<code>&lt;activity&gt;</code>标签下配置<code>&lt;intent-filter&gt;</code>的内容，可以指定当前活动能够响应的 action<br>和 category，如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".SecondActivity"</span> &gt;</span><br><span class="line">	&lt;intent-filter&gt;</span><br><span class="line">		&lt;action android:name=<span class="string">"com.example.administrator.ACTION_START"</span> /&gt;</span><br><span class="line">		&lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">	&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Intent-Filter"><a href="#Intent-Filter" class="headerlink" title="Intent Filter"></a>Intent Filter</h5><p>描述了一个组件愿意接收什么样的 Intent 对象，Android 将其抽象为 android.content.IntentFilter 类。 Activity 通过指定其 Intent Filter告诉系统该 Activity 可以响应什么类型的 Intent，有三大属性Action、URL、Category可以配置。</p>
<p>Activity 中 Intent Filter 匹配的过程：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh6iwqed6kj30890bvmxc.jpg" alt=""></p>
<p><strong>Action 匹配</strong></p>
<p>是一个用户定义的字符串，一个 Intent Filter 可以包含多个 Action，用于标示 Activity 所能接受的”动作”。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter &gt;</span><br><span class="line"> 	&lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line"> 	&lt;action android:name=<span class="string">"com.xx.myaction"</span> /&gt;</span><br><span class="line">	......</span><br><span class="line"> &lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<p><strong>URI 数据匹配</strong></p>
<p>通过 URI 携带外部数据给目标组件，在<code>&lt;intent-filter&gt;</code>标签中配置一个<code>&lt;data&gt;</code>标签。</p>
<p>mimeType 属性指定携带外部数据的数据类型，scheme 指定协议，host、port、path 指定数据的位置、端口、和路径。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">	&lt;data android:mimeType=<span class="string">"mimeType"</span> android:scheme=<span class="string">"scheme"</span></span><br><span class="line"> 				android:host=<span class="string">"host"</span> android:port=<span class="string">"port"</span> android:path=<span class="string">"path"</span>/&gt;</span><br><span class="line">&lt;/intent-filter</span><br></pre></td></tr></table></figure>

<p>只有<code>&lt;data&gt;</code>标签中指定的内容和 Intent 中携带的 Data 完全一致时，当前活动才能够响应该 Intent。不过一般在<code>&lt;data&gt;</code>标签中都不会指定过多的内容。</p>
<p><strong>Category 类别匹配</strong></p>
<p>为组件定义一个 Category 类别列表，当 Intent 中包含这个列表的所有项目时 Category 类别匹配才会成功。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">	&lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<p>android.intent.category.DEFAULT 是一种默认的 category，在调用startActivity()方法的时候会自动将这个 category 添加到 Intent 中。</p>
<p><strong>接收上一个Activity返回数据</strong></p>
<p><strong>startActivityForResult()</strong>方法也是用于启动 Activity 的，这个方法可以 Activity 销毁的时候能够返回一个结果给上一个活动。该方法接收两个参数，第一个参数还是 Intent，第二个参数是请求码，用于在之后的回调中判断数据的来源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">startActivityForResult(intent, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>返回代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"data_return"</span>, <span class="string">"Hello MainActivity"</span>);</span><br><span class="line">setResult(RESULT_OK, intent);</span><br><span class="line">finish();</span><br></pre></td></tr></table></figure>

<p><strong>setResult()</strong>方法接收两个参数，第一个参数用于向上一个活动返回处理结果，一般只使用<strong>RESULT_OK</strong>或<strong>RESULT_CANCELED</strong>，第二个参数则是把带有数据的 Intent 传递回去，然后调用了 finish()方法来销毁当前活动。</p>
<p>在需要接收返回数据的 Activity 中重写<strong>onActivityResult()</strong>方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	<span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">		String returnedData = data.getStringExtra(<span class="string">"data_return"</span>);</span><br><span class="line">		Log.d(<span class="string">"FirstActivity"</span>, returnedData);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onActivityResult()方法带有三个参数：</p>
<p>第一个参数 requestCode，即我们在启动活动时传入的请求码。</p>
<p>第二个参数 resultCode，即我们在返回数据时传入的处理结果。</p>
<p>第三个参数 data，即携带着返回数据的 Intent。</p>
<h4 id="六、Activity启动模式"><a href="#六、Activity启动模式" class="headerlink" title="六、Activity启动模式"></a>六、Activity启动模式</h4><h5 id="使用-manifest-文件"><a href="#使用-manifest-文件" class="headerlink" title="使用 manifest 文件"></a>使用 manifest 文件</h5><p>在 manifest 文件中通过给<code>&lt;activity&gt;</code>标签的<strong>android:launchMode</strong>属性来指定恰当的启动模式。</p>
<p>1.<strong>standard标准模式</strong></p>
<p>​        每次启动一个 Activity 都会重新创建一个新的实例，不管这个实例是否已经存在，此模式的 Activity 默认会进入启动它的 Activity 所属的任务栈中；</p>
<p>2.<strong>singleTop栈顶复用模式</strong></p>
<p>​        如果新 Activity 已经位于任务栈的栈顶，那么此 Activity 不会被重新创建，同时会回调 <strong>onNewIntent</strong> 方法，如果已经存在但不在栈顶，那么 Activity 依然会被重新创建；一般用于推送消息跳转界面。</p>
<p>3.<strong>singleTask栈内复用模式</strong></p>
<p>​        Activity 在同一个Task内只有一个实例。每次启动该 Activity 时系统首先会在返回栈中检查是否存在该Activity 的实例，如果发现已经存在则直接使用该实例，回调其<strong>onNewIntent</strong>方法，并把在这个 Activity 之上的所有 Activity 统统出栈；如果没有发现就会创建一个新的 Activity 实例，并将其加入Task栈顶，一般项目的主页面用该启动模式。</p>
<p>4.<strong>singleInstance单实例模式</strong></p>
<p>Activity只能单独地位于一个任务栈中，且此任务栈中只有唯一一个实例，在不同app之间的共享活动实例，一般用于系统功能界面。</p>
<h5 id="使用-Intent-标志"><a href="#使用-Intent-标志" class="headerlink" title="使用 Intent 标志"></a>使用 Intent 标志</h5><p>Activity常用的标记位Flags</p>
<ul>
<li><strong>FLAG_ACTIVITY_NEW_TASK</strong>：对应 singleTask 启动模式。</li>
<li><strong>FLAG_ACTIVITY_SINGLE_TOP</strong>：对应 singleTop 启动模式。</li>
<li><strong>FLAG_ACTIVITY_CLEAR_TOP</strong>：在同一个任务栈中所有位于它上面的 Activity 都要出栈。这个标记位一般会和 singleTask 模式一起出现，在这种情况下，被启动Activity的实例如果已经存在，那么系统就会回调onNewIntent。如果被启动的 Activity 采用 standard 模式启动，那么它以及连同它之上的 Activity 都要出栈，系统会创建新的 Activity 实例并放入栈中。</li>
<li><strong>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS :</strong> 具有这个标记的 Activity 不会出现在历史 Activity 列表中。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以此文记录 Android 中 Activity 的基础知识，便于对 Activity 的理解和学习。</p>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Git入门指南</title>
    <url>/2020/07/21/Git%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要是学习和记录在工作中经常用到的一些Git命令。这里推荐几个练习和学习Git命令的网站：</p>
<blockquote>
<p><strong><a href="https://learngitbranching.js.org/?locale=zh_CN" target="_blank" rel="noopener">Learn Git Branching</a></strong>、<strong><a href="https://git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository" target="_blank" rel="noopener">《Git文档》</a></strong>、<strong><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">《廖雪峰的Git教程》</a></strong></p>
</blockquote>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、基础必读"><a href="#一、基础必读" class="headerlink" title="一、基础必读"></a>一、基础必读</h4><h5 id="Git是什么"><a href="#Git是什么" class="headerlink" title="Git是什么"></a>Git是什么</h5><blockquote>
<p>Git is a <a href="https://git-scm.com/about/free-and-open-source" target="_blank" rel="noopener">free and open source</a> distributed version control system designed to handle everything from small to very large projects with speed and efficiency. </p>
<p>Git是一个免费和开源的分布式版本控制系统，致力于高效和快速的处理任何小或者大的项目。</p>
</blockquote>
<a id="more"></a>

<h5 id="Git中的几个概念"><a href="#Git中的几个概念" class="headerlink" title="Git中的几个概念"></a>Git中的几个概念</h5><p><strong>工作区、暂存区、版本库</strong></p>
<ul>
<li>工作区：就是在电脑里能够看到的目录，存放项目的文件夹。</li>
<li>暂存区：是在版本库<code>.git</code>目录下的<code>index</code>文件，称为stage（或者叫index）的暂存区。</li>
<li>版本库：工作区有一个隐藏目录<code>.git</code>，就是Git的版本库，主要存放暂存区和分支，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</li>
</ul>
<p>三者的关系如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3mg3awoxj30cq06iaa8.jpg" alt=""></p>
<p><code>git add</code> 命令把文件修改从工作目录添加到暂存区，<code>git commit</code> 命令把暂存区的所有内容提交到版本库当前分支。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3mizv2xbj30yg0ktgn7.jpg" alt=""><center>Git的过程</center></p>
<h5 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h5><p>如果我们想看一下工作区和暂存区文件的状态，可以使用命令 <code>git status</code>，</p>
<ul>
<li><code>Changes to be committed</code>：暂存区的文件。</li>
<li><code>Changes not staged for commit</code>：工作区的文件，还未保存到暂存区。</li>
<li><code>Untracked files</code>：指那些第一次创建，还没有加入版本更新的文件。</li>
</ul>
<p>对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。</p>
<h5 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h5><p>分支是多人协作开发中必不可少的角色，因为在我们的开发过程中，至少会有两个分支：</p>
<ul>
<li>正式版本的分支：线上代码版本保存的分支，需要稳定的运行。</li>
<li>开发主线的分支：下个版本需求的开发分支。</li>
<li>Bug分支：修复Bug的分支。</li>
</ul>
<h4 id="二、基础命令"><a href="#二、基础命令" class="headerlink" title="二、基础命令"></a>二、基础命令</h4><h5 id="暂存区相关"><a href="#暂存区相关" class="headerlink" title="暂存区相关"></a>暂存区相关</h5><h6 id="添加进暂存区"><a href="#添加进暂存区" class="headerlink" title="添加进暂存区"></a>添加进暂存区</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add .       <span class="comment"># 添加全部文件</span></span><br><span class="line">$ git add &lt;file&gt;  <span class="comment"># 添加某个文件</span></span><br></pre></td></tr></table></figure>

<h6 id="撤销工作区的修改"><a href="#撤销工作区的修改" class="headerlink" title="撤销工作区的修改"></a>撤销工作区的修改</h6><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -- &lt;file&gt;  <span class="comment"># 把工作区指定文件的修改全部撤销</span></span><br></pre></td></tr></table></figure>

<p>这里有两种情况：</p>
<p>一种是<code>file</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>file</code>已经添加到暂存区后，又作了修改，现在撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<h6 id="撤销暂存区的修改"><a href="#撤销暂存区的修改" class="headerlink" title="撤销暂存区的修改"></a>撤销暂存区的修改</h6><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD &lt;file&gt;  <span class="comment"># 把暂存区的修改撤销掉（unstage），重新放回工作区</span></span><br></pre></td></tr></table></figure>

<h5 id="版本库相关"><a href="#版本库相关" class="headerlink" title="版本库相关"></a>版本库相关</h5><h6 id="提交到版本库"><a href="#提交到版本库" class="headerlink" title="提交到版本库"></a>提交到版本库</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m &lt;message&gt;  <span class="comment"># message描述提交信息</span></span><br></pre></td></tr></table></figure>

<h6 id="撤销提交"><a href="#撤销提交" class="headerlink" title="撤销提交"></a>撤销提交</h6><p>在没有上传到远程分支时，进行版本库的撤销。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD~1  <span class="comment"># HEAD 代表当前的头结点，HEAD~n 代表当前节点的前n个节点</span></span><br></pre></td></tr></table></figure>

<h6 id="查看改动"><a href="#查看改动" class="headerlink" title="查看改动"></a>查看改动</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff HEAD -- &lt;file&gt;  <span class="comment"># 比较当前工作区和上一个版本的差异</span></span><br></pre></td></tr></table></figure>

<h6 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h6><p>直接在文件管理器中把文件删了，或者执行<code>rm</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm file  <span class="comment"># 仅从工作区删除文件</span></span><br></pre></td></tr></table></figure>

<p>在Git中删除也是一个修改操作，要想从版本库中删除文件，需执行两步。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm &lt;file&gt;  <span class="comment"># 从工作区删除文件并add到了暂存区</span></span><br><span class="line">$ git commit -m <span class="string">'remove file'</span>  <span class="comment"># 提交到版本库中</span></span><br></pre></td></tr></table></figure>

<h5 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h5><h6 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch  <span class="comment"># 查看本地所有分支，*是当前分支</span></span><br></pre></td></tr></table></figure>

<h6 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch &lt;name&gt;  <span class="comment"># name 分支名</span></span><br></pre></td></tr></table></figure>

<p>在本地创建和远程分支对应的分支，本地和远程分支的名称最好一致，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b branch-name origin/branch-name</span><br></pre></td></tr></table></figure>

<h6 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout &lt;name&gt;  <span class="comment"># 切换到name分支 或者 git switch &lt;name&gt;</span></span><br><span class="line">$ git checkout -b &lt;name&gt; <span class="comment"># 创建并切换name分支 或者 git switch -c &lt;name&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h6><p>合并保留之前的提交顺序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge &lt;name&gt;  <span class="comment"># 合并分支name到当前分支</span></span><br></pre></td></tr></table></figure>

<p>得到的提交历史更加线性，看着更加简洁。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rebase &lt;name&gt;  <span class="comment"># 合并分支name到当前分支</span></span><br></pre></td></tr></table></figure>

<h6 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d &lt;name&gt; <span class="comment"># 删除name分支</span></span><br></pre></td></tr></table></figure>

<h4 id="三、远程命令"><a href="#三、远程命令" class="headerlink" title="三、远程命令"></a>三、远程命令</h4><h5 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h5><p>远程仓库的默认名称是<code>origin</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote -v  <span class="comment"># -v 查看详细信息</span></span><br></pre></td></tr></table></figure>

<h5 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h5><h6 id="拉取最新代码"><a href="#拉取最新代码" class="headerlink" title="拉取最新代码"></a>拉取最新代码</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull &lt;origin&gt; &lt;branch-name&gt;  <span class="comment"># origin是我们远程分支的别名</span></span><br></pre></td></tr></table></figure>

<h6 id="上传代码"><a href="#上传代码" class="headerlink" title="上传代码"></a>上传代码</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push &lt;origin&gt; &lt;branch-name&gt; <span class="comment"># 推送到指定分支</span></span><br></pre></td></tr></table></figure>

<p>在上面的更新/推送命令中，默认了远程仓库的分支和当前的分支名一致，比如 <code>git push origin master</code>，本地分支名和远程分支的名称都为 <code>master</code>，如果不一致，则需要给定名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push/pull &lt;origin&gt; &lt;本地分支:远程分支&gt;</span><br></pre></td></tr></table></figure>

<h5 id="进阶命令"><a href="#进阶命令" class="headerlink" title="进阶命令"></a>进阶命令</h5><h6 id="追加更新"><a href="#追加更新" class="headerlink" title="追加更新"></a>追加更新</h6><p>更新上次 commit 的代码，避免再次生成一个 commit 记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<h6 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h6><p>建立本地分支和远程分支的关联。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream branch-name origin/branch-name</span><br></pre></td></tr></table></figure>

<h6 id="上一个版本"><a href="#上一个版本" class="headerlink" title="上一个版本"></a>上一个版本</h6><p>指定当前版本的上一个版本，比如想在 <code>master</code> 分支上一个版本的基础上对代码进行修改，我可以输入 <code>git checkout -b bugfix master^</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HEAD^</span><br><span class="line">分支^</span><br><span class="line">Hash值^</span><br></pre></td></tr></table></figure>

<h6 id="工作现场暂存和恢复"><a href="#工作现场暂存和恢复" class="headerlink" title="工作现场暂存和恢复"></a>工作现场暂存和恢复</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash  <span class="comment"># 把当前工作现场“储藏”起来，等以后恢复现场后继续工作</span></span><br><span class="line">$ git stash pop  <span class="comment"># 恢复工作现场，同时把stash内容也删了</span></span><br></pre></td></tr></table></figure>

<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>
<h6 id="复制一个特定的提交到当前分支"><a href="#复制一个特定的提交到当前分支" class="headerlink" title="复制一个特定的提交到当前分支"></a>复制一个特定的提交到当前分支</h6><p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;commit&gt;  <span class="comment"># commit 某次提交</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Git命令暂时先学习这些，掌握了这些可以胜任平时的开发，对于一些复杂的命令，使用的时候再查。</p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://juejin.im/post/5a2cdfe26fb9a0452936b07f" target="_blank" rel="noopener">《🛠Git 常用操作总结》</a><br><a href="https://juejin.im/post/5ba3aad7f265da0a8e6d801c" target="_blank" rel="noopener">《关于Android Studio使用Git的总结》</a><br><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">《廖雪峰的Git教程》</a></p>
<p><a href="https://juejin.im/post/5f0281aaf265da230f2838ba#heading-30" target="_blank" rel="noopener">《团队协作Git入门指南》</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 搭建博客教程</title>
    <url>/2020/07/20/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要是介绍在Mac上如何使用Hexo+GitHub搭建个人博客。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是-Hexo"><a href="#一、什么是-Hexo" class="headerlink" title="一、什么是 Hexo"></a>一、什么是 Hexo</h4><blockquote>
<p><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<a id="more"></a>

<h4 id="二、配置环境"><a href="#二、配置环境" class="headerlink" title="二、配置环境"></a>二、配置环境</h4><h5 id="申请GitHub"><a href="#申请GitHub" class="headerlink" title="申请GitHub"></a>申请GitHub</h5><p><a href="https://github.com/" target="_blank" rel="noopener">Github</a>注册账号，用作博客的远程仓库和部署服务器。</p>
<h5 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h5><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网下载</a>并安装，安装完成后可用<code>node -v</code>查看版本号。</p>
<h5 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h5><p>Mac 安装 Xcode 自带有 Git，也可去<a href="https://git-scm.com/" target="_blank" rel="noopener">官网下载</a>，安装完成后可用<code>git --version</code>查看版本号。</p>
<p>需要设置你 Github 的用户名密码和email，在命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure>

<h5 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h5><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h5 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h5><p>安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml  &#x2F;&#x2F; 配置信息，你可以在此配置大部分的参数</span><br><span class="line">├── package.json &#x2F;&#x2F; 应用程序的信息</span><br><span class="line">├── public       &#x2F;&#x2F; 执行 hexo generate 命令，输出的静态网页内容目录</span><br><span class="line">├── scaffolds    &#x2F;&#x2F; 模板文件夹。当你新建文章时，Hexo会根据scaffold来建立文件 </span><br><span class="line">├── scripts      &#x2F;&#x2F; 存放自定义 javascript 脚本</span><br><span class="line">├── source       &#x2F;&#x2F; 存放用户资源的地方</span><br><span class="line">|   ├── _drafts  &#x2F;&#x2F; 草稿文章</span><br><span class="line">|   └── _posts   &#x2F;&#x2F; 发布文章</span><br><span class="line">└── themes       &#x2F;&#x2F; 存放博客的主题，Hexo会根据主题来生成静态页面</span><br></pre></td></tr></table></figure>

<p>执行下列命令，会生成静态页面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate  <span class="comment"># 或者 hexo g</span></span><br></pre></td></tr></table></figure>

<p>启动本地服务，打开浏览器输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 即可访问。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server <span class="comment"># 或者 hexo s</span></span><br></pre></td></tr></table></figure>

<h4 id="三、部署到Github"><a href="#三、部署到Github" class="headerlink" title="三、部署到Github"></a>三、部署到Github</h4><h5 id="配置-SSH-Key，将本地目录与-Github-关联"><a href="#配置-SSH-Key，将本地目录与-Github-关联" class="headerlink" title="配置 SSH Key，将本地目录与 Github 关联"></a>配置 SSH Key，将本地目录与 Github 关联</h5><p>配置SSH Key是让本地 git 项目与远程仓库建立联系。SSH Keys不配置的话每次项目有改动提交的时候就要手动输入账号密码，配置了就不需要了。</p>
<p>首先检查是否已经有SSH Key，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure>

<p>如果没有目录.ssh，则要生成一个新的SSH Key，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your e-mail"</span></span><br></pre></td></tr></table></figure>

<p>接下来几步都直接按回车键，然后系统会要你输入密码。这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。</p>
<p>成功后进入到.shh文件夹中再输入ls，查看是否有id_rsa.pub文件，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>打开id_rsa.pub文件，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>复制SSH Key后，登录GitHub账号，在Setting-&gt;SSH keys-&gt;add SSH key，将其添加到Add SSH Key里。</p>
<h5 id="测试-SSH-Key-是否配置成功"><a href="#测试-SSH-Key-是否配置成功" class="headerlink" title="测试 SSH Key 是否配置成功"></a>测试 SSH Key 是否配置成功</h5><p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>如配置了密码则要输入密码，输完按回车。如果显示以下内容，则说明Github中的 ssh 配置成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hi username! You have successfully authenticated, but GitHub does not</span><br><span class="line">provide shell access.</span><br></pre></td></tr></table></figure>

<h5 id="创建仓库-Github-Pages"><a href="#创建仓库-Github-Pages" class="headerlink" title="创建仓库 Github Pages"></a>创建仓库 Github Pages</h5><p>登录GitHub账号后，新建 New repository，建立与你github用户名对应的仓库，名称必须为username.github.io，如prsuit.github.io。</p>
<h5 id="修改Hexo的-config-yml文件"><a href="#修改Hexo的-config-yml文件" class="headerlink" title="修改Hexo的_config.yml文件"></a>修改Hexo的<code>_config.yml</code>文件</h5><p>根目录<code>_config.yml</code>是博客的配置文件，用文本编辑器打开此文件，在文件最后部分，修改deploy配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/yourname/yourname.github.io.git <span class="comment">#yourname替换成你的Github账户名</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p><strong>注意：在<code>.yml</code>文件中，冒号后面都是要带空格的。</strong></p>
<h5 id="将博客项目上传到仓库"><a href="#将博客项目上传到仓库" class="headerlink" title="将博客项目上传到仓库"></a>将博客项目上传到仓库</h5><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">$ hexo d <span class="comment">#部署到远程仓库</span></span><br><span class="line"><span class="comment"># 或者 $ hexo g -d</span></span><br></pre></td></tr></table></figure>

<p>此时，通过访问 <a href="https://yourname.github.io/" target="_blank" rel="noopener">https://yourname.github.io</a> 可以看到默认的 Hexo 首页。</p>
<p>一些常用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">"postName"</span> <span class="comment"># 新建文章</span></span><br><span class="line"></span><br><span class="line">hexo new page <span class="string">"pageName"</span> <span class="comment"># 新建页面</span></span><br><span class="line"></span><br><span class="line">hexo generate <span class="comment"># 生成静态页面至public目录，markdown转html</span></span><br><span class="line"></span><br><span class="line">hexo server <span class="comment"># 开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line"></span><br><span class="line">hexo deploy <span class="comment"># 将.deploy目录部署到GitHub</span></span><br><span class="line"></span><br><span class="line">hexo clean <span class="comment"># 清除public文件夹和db.json，清除缓存数据</span></span><br><span class="line"></span><br><span class="line">hexo <span class="built_in">help</span> <span class="comment"># 查看帮助</span></span><br><span class="line"></span><br><span class="line">hexo version <span class="comment"># 查看Hexo的版本</span></span><br><span class="line"></span><br><span class="line">hexo n == hexo new</span><br><span class="line"></span><br><span class="line">hexo g == hexo generate</span><br><span class="line"></span><br><span class="line">hexo s == hexo server</span><br><span class="line"></span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>

<h4 id="四、更换Hexo主题"><a href="#四、更换Hexo主题" class="headerlink" title="四、更换Hexo主题"></a>四、更换Hexo主题</h4><p>Hexo 中有很多主题，可以在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网</a>查看。 推荐使用<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">hexo-theme-next</a>，更换主题步骤：</p>
<h5 id="下载主题资源"><a href="#下载主题资源" class="headerlink" title="下载主题资源"></a>下载主题资源</h5><p>终端cd到初始化博客文件夹目录下，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h5 id="配置使用下载的主题"><a href="#配置使用下载的主题" class="headerlink" title="配置使用下载的主题"></a>配置使用下载的主题</h5><p>修改博客目录下<code>_config.yml</code>里的theme的名称<code>landscape</code>更改为<code>next</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<h5 id="主题的其他配置"><a href="#主题的其他配置" class="headerlink" title="主题的其他配置"></a>主题的其他配置</h5><p>可在<code>/theme/{theme}/_config.yml</code> 主题的配置文件下进行主题的配置。</p>
<h5 id="添加分类"><a href="#添加分类" class="headerlink" title="添加分类"></a>添加分类</h5><p>新建一个页面，命名为 categories，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>

<p>在 source 目录下会生成 categories 目录，修改 source/categories 目录的 index.md 如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-07-19 20:24:49</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"categories"</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>在主题<code>/theme/{theme}/_config.yml</code> 中将<code>menu</code>的<code>catagories</code>取消注释，把前面的<code>#</code>去掉即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br></pre></td></tr></table></figure>

<p>给模板添加分类属性，打开scarffolds文件夹里的post.md文件，给它的头部加上categories:，这样我们创建的所有新的文章都会自带这个属性，我们只需要往里填分类，就可以自动在网站上形成分类了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories: 分类名 <span class="comment"># 多个分类，数组形式[分类名1，分类名2]</span></span><br><span class="line"><span class="comment"># 短横线形式</span></span><br><span class="line"><span class="comment"># - 分类名1</span></span><br><span class="line"><span class="comment"># - 分类名2</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h5 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h5><p>新建一个页面，命名为 tags，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>

<p>在 source 目录下会生成 tags 目录，修改 source/tags 目录的 index.md如下 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-07-19 20:28:30</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>同样，在主题<code>/theme/{theme}/_config.yml</code> 中将<code>menu</code>的<code>tags</code>取消注释，同上。</p>
<p>以后写文章时，在要分类的文章顶部加入 tags 属性，值为标签名:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories: 分类名</span><br><span class="line">tags: [标签a,标签b] <span class="comment"># 数组形式，添加a和b两个标签</span></span><br><span class="line"><span class="comment"># 短横线形式</span></span><br><span class="line"><span class="comment"># - 标签a</span></span><br><span class="line"><span class="comment"># - 标签b</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>至此，完成以上配置，可以执行调试命令查看效果。以后就可以使用Hexo发布文章了，当然还可以添加其他配置如文章阅读统计、评论等，可自行探索。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>万事开头难，但总算开头了💔，从此开启自己的博客生涯。第一次写Blog，写作思路不是很清晰流畅，花费了比较多的时间，希望以后会越来越好，Fighting！！！</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Service必备基础</title>
    <url>/2020/07/25/Service%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android的四大组件之一的Service。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是Service"><a href="#一、什么是Service" class="headerlink" title="一、什么是Service"></a>一、什么是Service</h4><p>Service 是一个应用程序组件，它能在后台执行一些耗时较长的操作，并且不提供用户界面。服务能被其他应用程序的组件启动，即使用户切换到另外的应用时还能保持后台运行。此外，应用程序组件还能与服务绑定，并与服务进行交互，甚至能进行进程间通信（IPC）。 比如，服务可以处理网络传输、音乐播放、执行文件I/O、或者与 content provider 进行交互，所有这些都是后台进行的。</p>
<a id="more"></a>

<ul>
<li><p>运行完全不依赖UI的，只要进程还在，Service 就可以继续运行，可以和其他组件组件交互；</p>
</li>
<li><p>一般运行在与创建服务时所在的应用程序进程中，要运行在单独的进程当中，在声明时需指定 <code>android:process</code>；</p>
</li>
<li><p>服务不会自动开启线程，我们需要在服务的内部手动创建子线程，并在这里执行具体的耗时任务。</p>
</li>
</ul>
<h4 id="二、Service分类"><a href="#二、Service分类" class="headerlink" title="二、Service分类"></a>二、Service分类</h4><h5 id="按运行分类"><a href="#按运行分类" class="headerlink" title="按运行分类"></a>按运行分类</h5><p><strong>前台服务</strong>：指那些经常会被用户关注的服务，因此内存过低时它不会成为被杀的对象。 前台服务必须提供一个状态栏通知，比较不容易被系统回收。</p>
<p><strong>后台服务</strong>：指在后台默默工作，提供数据运算等的服务，它优先级还是比较低的，当系统出现内存不足情况时，就有可能会回收掉正在后台运行的Service。</p>
<h5 id="按使用分类"><a href="#按使用分类" class="headerlink" title="按使用分类"></a>按使用分类</h5><p><strong>本地服务</strong>：用于应用程序内部，实现一些耗时任务，并不占用应用程序所属线程，而是单开线程后台执行。 </p>
<p><strong>远程服务</strong>：用于 Android 系统内部的应用程序之间，可被其他应用程序复用，比如天气预报服务，其他应用程序不需要再写这样的服务，调用已有的即可。</p>
<h4 id="三、Service启动状态"><a href="#三、Service启动状态" class="headerlink" title="三、Service启动状态"></a>三、Service启动状态</h4><h5 id="启动状态-Started"><a href="#启动状态-Started" class="headerlink" title="启动状态(Started)"></a>启动状态(Started)</h5><p>当应用组件（如 Activity）通过调用 <strong>startService()</strong> 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响，除非外部手动调用 <strong>stopService()</strong> 或内部调用 <strong>stopSelf()</strong> 才能停止服务， 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。</p>
<h5 id="绑定状态-Bound"><a href="#绑定状态-Bound" class="headerlink" title="绑定状态(Bound)"></a>绑定状态(Bound)</h5><p>当应用组件通过调用 <strong>bindService()</strong> 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器 <strong>IBinder</strong> 接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</p>
<h4 id="四、Service生命周期"><a href="#四、Service生命周期" class="headerlink" title="四、Service生命周期"></a>四、Service生命周期</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh7ysawqzfj30at0e3abt.jpg" alt=""></p>
<p><strong>onCreate()</strong>：首次创建服务时，将调用此方法，如果服务已在运行，则不会调用此方法，该方法只调用一次；</p>
<p><strong>onStartComand()</strong>：服务通过 <strong>startService()</strong> 启动时会调用，多次执行 <strong>startService()</strong> 方法，该方法也会相应的多次调用；</p>
<p><strong>onBind()</strong>：服务通过 <strong>bindService()</strong> 启动且服务是第一次创建时会调用，在此方法必须返回 一个 IBinder 接口的实现类对象，供客户端用来与服务进行通信，服务在启动状态的情况下可返回 null ；</p>
<p><strong>onUnBind()</strong>：服务通过 <strong>unbindService()</strong> 被解绑时调用；</p>
<p><strong>onDestroy()</strong>：服务停止或被解绑后调用；</p>
<h4 id="五、Service使用"><a href="#五、Service使用" class="headerlink" title="五、Service使用"></a>五、Service使用</h4><h5 id="Service在清单文件中的声明"><a href="#Service在清单文件中的声明" class="headerlink" title="Service在清单文件中的声明"></a>Service在清单文件中的声明</h5><p>通过继承Service基类自定义而来，都需要在AndroidManifest.xml中声明，Service在AndroidManifest.xml中的声明语法，其格式如下(不是所有都必填)：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;service android:enabled=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:exported=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:icon=<span class="string">"drawable resource"</span></span><br><span class="line">    android:isolatedProcess=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:label=<span class="string">"string resource"</span></span><br><span class="line">    android:name=<span class="string">"string"</span></span><br><span class="line">    android:permission=<span class="string">"string"</span></span><br><span class="line">    android:process=<span class="string">"string"</span> &gt;</span><br><span class="line">    . . .</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>android:exported：代表是否能被其他应用隐式调用，其默认值是由 service 中有无 intent-filter 决定的，如果有 intent-filter ，默认值为 true ，否则为 false 。为 false 的情况下，即使有 intent-filter 匹配，也无法打开，即无法被其他应用隐式调用。</li>
<li>android:name：对应 Service 类名，唯一必需的属性。</li>
<li>android:permission：申明此服务的权限。</li>
<li>android:process：是否需要在单独的进程中运行，当设置为 android:process=”:remote” 时，代表Service 在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以 “remote” 和 ”:remote” 不是同一个意思，前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。</li>
<li>android:isolatedProcess ：设置 true 意味着，服务会在一个特殊的进程下运行，这个进程与系统其他进程分开且没有自己的权限。与其通信的唯一途径是通过服务的API(bind and start)。</li>
<li>android:enabled：是否可以被系统实例化，默认为 true因为父标签 也有 enable 属性，所以必须两个都为默认值 true 的情况下服务才会被激活，否则不会激活。</li>
</ul>
<h5 id="通过startService启动"><a href="#通过startService启动" class="headerlink" title="通过startService启动"></a>通过startService启动</h5><ul>
<li><p>service 会一直无限期运行下去，只有外部调用了 stopService() 或 stopSelf() 方法时，该 Service 才会停止运行并销毁。</p>
</li>
<li><p>多次 startService 不会重复执行onCreate回调，但每次都会执行 onStartCommand 回调</p>
</li>
<li><p><strong>onStartCommand()</strong> 方法的返回值int类型才值得注意的，它有三种可选值：</p>
<p>START_STICKY：“黏性的”，当 Service 因内存不足而被系统 kill 后，一段时间后内存再次空闲时，系统将会尝试重新创建此 Service ，一旦创建成功后将回调 onStartCommand 方法，但其中的 Intent 将是null，除非有挂起的Intent，如pendingintent，比较适用于不执行命令、但无限期运行并等待作业的媒体播放器或类似服务。</p>
<p>START_NOT_STICKY：“非黏性的”，当 Service 因内存不足而被系统kill后，即使系统内存再次空闲时，系统也不会尝试重新创建此Service。</p>
<p>START_REDELIVER_INTENT：当 Service 因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，任何挂起 Intent 均依次传递。与 START_STICKY 不同的是，其中的传递的 Intent 将是非空，是最后一次调用 startService 中的 intent 。这个值适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</p>
</li>
</ul>
<h5 id="通过bindService启动"><a href="#通过bindService启动" class="headerlink" title="通过bindService启动"></a>通过bindService启动</h5><ul>
<li><p>该启动方式的调用者和服务之间是典型的 <strong>client-server</strong> 模式。调用者是 client ，service 则是 server 端。<strong>service 只有一个</strong>，但绑定到 service 上面的 client 可以有一个或很多个。这里所提到的 client 指的是组件，比如某个Activity。</p>
</li>
<li><p><strong>client 可以通过 IBinder 接口获取 Service 实例</strong>，从而实现在 client 端直接调用 Service 中的方法以实现交互。</p>
</li>
<li><p>启动服务的生命周期与其绑定的 client 息息相关。当 client 销毁时，client 会自动与 Service 解除绑定。当然，client 也可以明确调用 Context的 <strong>unbindService()</strong> 方法与 Service 解除绑定。<strong>当没有任何 client 与 Service 绑定时，Service 会自行销毁</strong>。</p>
</li>
<li><p><strong>onBind()</strong> 方法必须返回一个 IBinder接口的实现类对象，该类用以提供客户端用来与服务进行交互的编程接口，该接口可以通过三种方法定义接口：</p>
<p><strong>扩展 Binder 类</strong> ：如果服务是提供给自有应用专用的，并且 Service (服务端)与客户端相同的进程中运行，即客户端和服务位于<strong>同一应用和进程</strong>内才有效。通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中以及 Service 中可用的公共方法。如果我们的服务只是自有应用的后台工作线程，则优先采用这种方法。不采用该方式创建接口的唯一原因是，服务被其他应用或不同的进程调用。</p>
<p><strong>使用 Messenger</strong> ：通过它可以在<strong>不同的进程</strong>中共传递Message对象(Handler中的Messager，因此 Handler 是 Messenger 的基础)，在Message中可以存放我们需要传递的数据，然后在进程间传递。因为 Messenger 会在单一线程中创建包含所有请求的队列，也就是说Messenger是以串行的方式处理客户端发来的消息，这样我们就不必对服务进行线程安全设计了。</p>
<p><strong>使用 AIDL</strong> ：由于 Messenger 是以串行的方式处理客户端发来的消息，如果当前有大量消息同时发送到Service(服务端)，Service 仍然只能一个个处理，这也就是 Messenger 跨进程通信的缺点了，因此如果有大量并发请求，Messenger 就会显得力不从心了，这时 AIDL（Android Interface Definition Language） Android 接口定义语言就派上用场了，但实际上 Messenger 的跨进程方式其底层实现就是AIDL，只不过 android 系统帮我们封装成透明的 Messenger 罢了。如果我们想让服务同时处理多个请求，则应该使用 AIDL。它可以用于让某个 Service 与多个应用程序组件之间进行跨进程通信，从而可以实现<strong>多个应用程序共享同一个 Service</strong> 的功能。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务端LocalService部分代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> MyBinder mBinder = <span class="keyword">new</span> MyBinder();</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//建Binder对象，返回给客户端使用，提供数据交换的接口</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line"> 	    <span class="comment">// 声明一个方法，getService。（提供给客户端调用）</span></span><br><span class="line">    <span class="function">LocalService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回当前对象LocalService,这样我们就可在客户端调用Service的公共方法了</span></span><br><span class="line">      <span class="keyword">return</span> LocalService.<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//定义交互方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端--绑定服务实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BindActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ServiceConnection conn;</span><br><span class="line">  <span class="keyword">private</span> LocalService.MyBinder mBinder;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Overrid</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_bind);</span><br><span class="line">        btnBind = (Button) findViewById(R.id.BindService);</span><br><span class="line">        btnUnBind = (Button) findViewById(R.id.unBindService);</span><br><span class="line">        btnGetDatas = (Button) findViewById(R.id.getServiceDatas);</span><br><span class="line">        <span class="comment">//创建绑定对象</span></span><br><span class="line">        <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LocalService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 开启绑定</span></span><br><span class="line">        btnBind.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"绑定调用：bindService"</span>);</span><br><span class="line">                <span class="comment">//调用绑定方法</span></span><br><span class="line">                bindService(intent, conn, Service.BIND_AUTO_CREATE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 解除绑定</span></span><br><span class="line">        btnUnBind.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"解除绑定调用：unbindService"</span>);</span><br><span class="line">                <span class="comment">// 解除绑定</span></span><br><span class="line">                <span class="keyword">if</span>(mBinder!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    mBinder = <span class="keyword">null</span>;</span><br><span class="line">                    unbindService(conn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="comment">// 获取数据</span></span><br><span class="line">        btnGetDatas.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mBinder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 通过绑定服务传递的Binder对象，获取Binder暴露出来的数据</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"从服务端获取数据："</span> + mBinder.getCount());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"还没绑定呢，先绑定,无法从服务端获取数据"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">       conn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 与服务器端交互的接口方法 绑定服务的时候被回调，在这个方法获取绑定Service传递过来的IBinder对象，</span></span><br><span class="line"><span class="comment">             * 通过这个IBinder对象，实现宿主和Service的交互。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"绑定成功调用：onServiceConnected"</span>);</span><br><span class="line">                <span class="comment">// 获取Binder</span></span><br><span class="line">                mBinder = (LocalService.LocalBinder) service;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当取消绑定的时候被回调。但正常情况下是不被调用的，它的调用时机是当Service服务被意外销毁时，</span></span><br><span class="line"><span class="comment">             * 例如内存的资源不足时这个方法才被自动调用。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">                mBinder = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>onServiceConnected(ComponentName name, IBinder service)</strong><br>服务绑定成功后系统会调用该方法以传递服务的 onBind() 方法返回的 IBinder。其中 service 便是服务端返回的 IBinder 实现类对象，ComponentName 是一个封装了组件信息的类。</p>
</li>
<li><p><strong>onServiceDisconnected(ComponentName name)</strong><br>系统会在与服务的连接意外中断时（例如<strong>当服务崩溃或被终止</strong>时）调用该方法。<span style="color:red">注意:当客户端取消绑定时，系统“绝对不会”调用该方法</span>。</p>
</li>
<li><p><strong>bindService(Intent service, ServiceConnection conn, int flags)</strong></p>
<p>其中 Intent 是我们要绑定的服务的意图，而 ServiceConnection 代表与服务的连接，它只有两个方法，前面已分析过，flags 则是指定绑定时是否自动创建 Service 。0代表不自动创建、BIND_AUTO_CREATE 则代表自动创建。</p>
</li>
<li><p><strong>unbindService(ServiceConnection conn)</strong><br>该方法执行解除绑定的操作，其中 ServiceConnection 代表与服务的连接。</p>
</li>
</ul>
<h4 id="六、启动服务与绑定服务间的转换问题"><a href="#六、启动服务与绑定服务间的转换问题" class="headerlink" title="六、启动服务与绑定服务间的转换问题"></a>六、启动服务与绑定服务间的转换问题</h4><p>​        虽然服务的状态有启动和绑定两种，但实际上一个服务可以同时是这两种状态，它既可以是启动服务（以无限期运行），也可以是绑定服务。有点需要注意的是 Android 系统仅会为一个 Service 创建一个实例对象，所以不管是启动服务还是绑定服务，操作的是同一个 Service 实例，而且由于绑定服务或者启动服务执行顺序问题将会出现以下两种情况：<strong>（启动服务的优先级比绑定服务高一些）</strong></p>
<ul>
<li><p><strong>先绑定服务后启动服务</strong></p>
<p>如果当前 Service 实例先以绑定状态运行，然后再以启动状态运行，那么绑定服务将会转为启动服务运行，这时如果之前绑定的宿主（Activity）被销毁了，也不会影响服务的运行，服务还是会一直运行下去，指定收到调用停止服务或者内存不足时才会销毁该服务。</p>
</li>
<li><p><strong>先启动服务后绑定服务</strong></p>
<p>如果当前 Service 实例先以启动状态运行，然后再以绑定状态运行，当前启动服务并不会转为绑定服务，但是还是会与宿主绑定，只是即使宿主解除绑定后，服务依然按启动服务的生命周期在后台运行，直到有 Context调用了 stopService() 或是服务本身调用了 stopSelf() 方法抑或内存不足时才会销毁服务。</p>
</li>
</ul>
<h4 id="七、前台服务"><a href="#七、前台服务" class="headerlink" title="七、前台服务"></a>七、前台服务</h4><p>前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。前台服务必须为状态栏提供通知，设置服务运行于前台的方法。</p>
<h5 id="设置服务运行于前台"><a href="#设置服务运行于前台" class="headerlink" title="设置服务运行于前台"></a>设置服务运行于前台</h5><ul>
<li><p><strong>startForeground(int id, Notification notification)</strong></p>
<p>在 Service 创建 onCreate 时调用，该方法的作用是把当前服务设置为前台服务，其中id参数代表唯一标识通知的整型数，需要注意的是提供给 startForeground() 的整型 ID 不得为 0，而notification是一个状态栏的通知。Android 8.0之后对于通知栏也进行了整改，增加了通知渠道，通知组的概念。</p>
</li>
<li><p><strong>stopForeground(boolean removeNotification)</strong> </p>
<p>在 Service 销毁时调用，该方法是用来从前台删除服务，removeNotification 是否也删除状态栏通知。</p>
</li>
</ul>
<h5 id="启动前台服务"><a href="#启动前台服务" class="headerlink" title="启动前台服务"></a>启动前台服务</h5><p>在Android 8.0 之后需要使用 <strong>startForegroundService()</strong> 启动前台服务，并在清单文件中添加前</p>
<p>台服务权限 <code>android.permission.FOREGROUND_SERVICE</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">       startForegroundService(mForegroundService);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       startService(mForegroundService);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="八、如何提高服务在后台运行时间"><a href="#八、如何提高服务在后台运行时间" class="headerlink" title="八、如何提高服务在后台运行时间"></a>八、如何提高服务在后台运行时间</h4><p>关于 Service 保活后期会整理一篇主流的具体解决方案，主要思路是：</p>
<p>1.<strong>用 startService 方式启动 Service ，onStartCommand 方式中，返回 START_STICKY</strong> 。</p>
<p>2.<strong>提高 Service 的优先级</strong>，在清单文件中对于 intent-filter 可以通过 android:priority = “1000” 属性设置，1000是最高值，如果数字越小则优先级越低。</p>
<p>3.<strong>提升 Service 进程的优先级</strong>，使用前台服务。</p>
<p>4.<strong>设置应用白名单和电量管理</strong>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Service 实例对象同一应用中同时只会有一个。</li>
<li>Service默认并不会运行在子线程中，也不运行在一个独立的进程中，它同样执行在主线程中（UI线程）。换句话说，不要在Service里执行耗时操作，除非手动打开一个子线程，否则有可能出现主线程被阻塞（ANR）的情况。</li>
<li>使用了远程 Service 后，Service 已经在另外一个进程当中运行了，所以只会阻塞该进程中的主线程，并不会影响到当前的应用程序。</li>
<li>默认 Service 和创建者在同一个进程内，如果将 Service 的 android:process 属性指定成” :remote”，表示Service 是在单独的进程创建远程服务。调用 startService 可以启动服务，但不能调用 bindService 绑定服务，因为创建者和 Service 运行在两个不同的进程中，不能再使用传统的建立关联的方式，需要使用 AIDL 来跨进程通信才可以绑定。</li>
<li>只有Activity、Service、Content Provider 能够绑定服务；BroadcastReceiver 广播接收器不能绑定服务</li>
</ul>
<p>引用文章：</p>
<blockquote>
<p><a href="https://blog.csdn.net/hdhhd/article/details/80612726" target="_blank" rel="noopener">安卓Service 详解</a></p>
<p><a href="https://www.jianshu.com/p/4c798c91a613" target="_blank" rel="noopener">Android Service两种启动方式详解</a></p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/11952435" target="_blank" rel="noopener">Android Service完全解析，关于服务你所需知道的一切</a></p>
<p><a href="https://blog.csdn.net/lmj623565791/article/details/47017485" target="_blank" rel="noopener">Android 基于Message的进程间通信 Messenger完全解析</a></p>
<p><a href="https://blog.csdn.net/lmj623565791/article/details/38461079" target="_blank" rel="noopener">Android aidl Binder框架浅析</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
</search>
