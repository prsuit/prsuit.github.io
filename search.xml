<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Activity必备基础</title>
    <url>/2020/07/23/Activity%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android的四大组件之一的Activity。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、Activity是什么"><a href="#一、Activity是什么" class="headerlink" title="一、Activity是什么"></a>一、Activity是什么</h4><p>我们都知道android中有四大组件（Activity 活动，Service 服务，BroadcastReceiver 广播接收器，Content Provider 内容提供者），Activity是用的最多也是最基本的组件，Activity 提供窗口来和用户进行交互的组件。官方是这么介绍的：</p>
<a id="more"></a>

<blockquote>
<p>An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View).</p>
<p>一个activity是一个单独的，用来处理用户操作的窗口。几乎所有的activity都是用来和用户交互的，所以activity类会创建了一个窗口，你可以通过setContentView(View)显示你的UI在窗口上。</p>
</blockquote>
<ul>
<li>Activity是一个应用程序组件，提供一个屏幕，用户可以用来交互为了完成某项任务。</li>
<li>Activity中所有操作都与用户密切相关，是一个负责与用户交互的组件，可以通过setContentView(View)来显示指定控件。</li>
</ul>
<h4 id="二、Activity状态及转换"><a href="#二、Activity状态及转换" class="headerlink" title="二、Activity状态及转换"></a>二、Activity状态及转换</h4><p>在android 中，Activity 拥有四种基本状态：</p>
<p>1.<strong>Active/Running</strong></p>
<p>​    一个新 Activity 启动入栈后，它显示在屏幕最前端，处理是处于栈的最顶端（Activity栈顶），此时它处于可见并可和用户交互的激活状态，叫做活动状态或者运行状态（active or running）。</p>
<p>2.<strong>Paused</strong></p>
<p>​    当 Activity 失去焦点，被另一个透明或者 Dialog 样式非全屏的 Activity 覆盖时的状态，叫做暂停状态（Paused）。此时它依然与窗口管理器保持连接，系统继续维护其内部状态，所以它仍然可见，但它已经失去了焦点故不可与用户交互。</p>
<p>3.<strong>Stopped</strong></p>
<p>​    当 Activity 被另外一个 Activity 完全覆盖掉，不可再见时的状态叫做停止状态（Stopped）。</p>
<p>4.<strong>Killed</strong></p>
<p>​    Activity 被系统杀死回收或者没有被启动时的状态，叫做被杀死的状态（Killed）。</p>
<p>下图说明了 Activity 在不同状态间转换的时机和条件：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5lxx3ssej308n081dfu.jpg" alt=""></p>
<h4 id="三、Activity栈"><a href="#三、Activity栈" class="headerlink" title="三、Activity栈"></a>三、Activity栈</h4><p>Android 是通过一种 Activity 栈的方式来管理 Activity 的，一个 Activity 的实例的状态决定它在栈中的位置。处于前台的 Activity 总是在栈的顶端，当前台的 Activity 因为异常或其它原因被销毁时，处于栈第二层的 Activity 将被激活，上浮到栈顶。当新的 Activity 启动入栈时，原 Activity 会被压入到栈的第二层。一个 Activity 在栈中的位置变化反映了它在不同状态间的转换。Activity 的状态与它在栈中的位置关系如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5m9bc21zj308w05r748.jpg" alt=""></p>
<p>如上所示，除了最顶层即处在 Active 状态的 Activity 外，其它的 Activity 都有可能在系统内存不足时被回收，一个 Activity 的实例越是处在栈的底层，它被系统回收的可能性越大。系统负责管理栈中 Activity 的实例，它根据 Activity 所处的状态来改变其在栈中的位置。</p>
<h4 id="四、Activity生命周期"><a href="#四、Activity生命周期" class="headerlink" title="四、Activity生命周期"></a>四、Activity生命周期</h4><p>生命周期函数，常用的7个如下：</p>
<p><strong>onCreate()</strong>：表示 Activity <strong>正在被创建</strong>，常用来<strong>初始化工作</strong>，比如调用 setContentView 加载界面布局资源，初始化 Activity 所需数据等；</p>
<p><strong>onReStart()</strong>：表示 Activity <strong>正在重新启动</strong>，当前 Acitivty 从不可见重新变为可见时，onRestart 就会被调用；</p>
<p><strong>onStart()</strong>：表示 Activity <strong>正在被启动</strong>，此时 Activity <strong>可见但不在前台</strong>，还处于后台，无法与用户交互；</p>
<p><strong>onResume()</strong>：表示 Activity <strong>获得焦点</strong>，此时 Activity <strong>可见且在前台</strong>并开始活动，位于活动堆栈的顶部，这是与onStart的区别所在；</p>
<p><strong>onPause()</strong>：表示 Activity <strong>正在停止</strong>，<strong>可见但不在前台</strong>，此时可做一些<strong>存储数据、停止动画</strong>等工作，但是不能太耗时，因为这会影响到新 Activity 的显示，onPause 必须先执行完，新 Activity 的 onResume 才会执行；</p>
<p><strong>onStop()</strong>：表示 Activity <strong>即将停止</strong>，被新 activity 覆盖了，对用户<strong>不可见</strong>，可以做一些稍微重量级的回收工作，比如注销广播接收器、关闭网络连接等，同样不能太耗时；</p>
<p><strong>onDestroy()</strong>：表示 Activity <strong>即将被销毁</strong>，这是 Activity 生命周期中的最后一个回调，常做<strong>回收工作、资源释放</strong>；</p>
<ul>
<li>延伸：从<strong>整个生命周期</strong>来看，<strong>onCreate</strong> 和 <strong>onDestroy</strong> 是配对的，分别标识着 Activity 的创建和销毁，并且只可能有<strong>一次调用</strong>； 从 Activity <strong>是否可见</strong>来说，<strong>onStart</strong> 和 <strong>onStop</strong> 是配对的，这两个方法可能被<strong>调用多次</strong>； 从 Activity <strong>是否在前台</strong>来说，<strong>onResume</strong> 和 <strong>onPause</strong> 是配对的，这两个方法可能被<strong>调用多次</strong>； 除了这种区别，在实际使用中没有其他明显区别。</li>
</ul>
<p>Activity 生命周期循环图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5o2g5wxnj30e90if75q.jpg" alt=""></p>
<p><strong>onSaveInstanceState()</strong>：发生条件在系统配置发生改变（例如屏幕方向）导致 Activity 被杀死并重新创建、资源内存不足导致低优先级的 Activity 被杀死，系统会调用 <strong>onSaveInstanceState</strong> 来保存当前 Activity 的状态，此方法调用在 onStop 之后 和 onDestory 之前；</p>
<p><strong>onRestoreInstanceState()</strong>： 当 Activity 被重建后，系统会调用 <strong>onRestoreInstanceState</strong>，并且把onSaveInstanceState 方法所保存的 Bundle 对象<strong>同时传参</strong>给 onRestoreInstanceState() 和 onCreate() ，因此可以通过这两个方法判断 Activity <strong>是否被重建</strong>，调用在 onStart 之后，可使用 onSaveInstanceState() 和onRestoreInstanceState()（或onCreate()）来保存和恢复 Activity 活动状态。</p>
<h4 id="五、Activity启动和通信"><a href="#五、Activity启动和通信" class="headerlink" title="五、Activity启动和通信"></a>五、Activity启动和通信</h4><p><strong>Intent</strong>是一种消息传递的机制，它负责对操作的动作、动作涉及数据、附加数据进行描述。Android 则根据此Intent的描述，负责找到对应的组件，将 Intent 传递给调用的组件，并完成组件的调用。</p>
<h5 id="显式Intent"><a href="#显式Intent" class="headerlink" title="显式Intent"></a>显式Intent</h5><p>通过指定具体的组件类，通知应用启动对应的组件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClass(MainActivity.<span class="keyword">this</span>,SecondAcvivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">intent.putExtra(<span class="string">"values"</span>,<span class="string">"传个值"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<h5 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h5><p>通过指定了一系列更为抽象的 action 和 category 等信息，然后交由系统去分析这个 Intent，并帮我们找出合适的活动去启动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.administrator.ACTION_START"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>要在清单文件中<code>&lt;activity&gt;</code>标签下配置<code>&lt;intent-filter&gt;</code>的内容，可以指定当前活动能够响应的 action<br>和 category，如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".SecondActivity"</span> &gt;</span><br><span class="line">	&lt;intent-filter&gt;</span><br><span class="line">		&lt;action android:name=<span class="string">"com.example.administrator.ACTION_START"</span> /&gt;</span><br><span class="line">		&lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">	&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Intent-Filter"><a href="#Intent-Filter" class="headerlink" title="Intent Filter"></a>Intent Filter</h5><p>描述了一个组件愿意接收什么样的 Intent 对象，Android 将其抽象为 android.content.IntentFilter 类。 Activity 通过指定其 Intent Filter告诉系统该 Activity 可以响应什么类型的 Intent，有三大属性Action、URL、Category可以配置。</p>
<p>Activity 中 Intent Filter 匹配的过程：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh6iwqed6kj30890bvmxc.jpg" alt=""></p>
<p><strong>Action 匹配</strong></p>
<p>是一个用户定义的字符串，一个 Intent Filter 可以包含多个 Action，用于标示 Activity 所能接受的”动作”。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter &gt;</span><br><span class="line"> 	&lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line"> 	&lt;action android:name=<span class="string">"com.xx.myaction"</span> /&gt;</span><br><span class="line">	......</span><br><span class="line"> &lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<p><strong>URI 数据匹配</strong></p>
<p>通过 URI 携带外部数据给目标组件，在<code>&lt;intent-filter&gt;</code>标签中配置一个<code>&lt;data&gt;</code>标签。</p>
<p>mimeType 属性指定携带外部数据的数据类型，scheme 指定协议，host、port、path 指定数据的位置、端口、和路径。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">	&lt;data android:mimeType=<span class="string">"mimeType"</span> android:scheme=<span class="string">"scheme"</span></span><br><span class="line"> 				android:host=<span class="string">"host"</span> android:port=<span class="string">"port"</span> android:path=<span class="string">"path"</span>/&gt;</span><br><span class="line">&lt;/intent-filter</span><br></pre></td></tr></table></figure>

<p>只有<code>&lt;data&gt;</code>标签中指定的内容和 Intent 中携带的 Data 完全一致时，当前活动才能够响应该 Intent。不过一般在<code>&lt;data&gt;</code>标签中都不会指定过多的内容。</p>
<p><strong>Category 类别匹配</strong></p>
<p>为组件定义一个 Category 类别列表，当 Intent 中包含这个列表的所有项目时 Category 类别匹配才会成功。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">	&lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<p>android.intent.category.DEFAULT 是一种默认的 category，在调用startActivity()方法的时候会自动将这个 category 添加到 Intent 中。</p>
<p><strong>接收上一个Activity返回数据</strong></p>
<p><strong>startActivityForResult()</strong>方法也是用于启动 Activity 的，这个方法可以 Activity 销毁的时候能够返回一个结果给上一个活动。该方法接收两个参数，第一个参数还是 Intent，第二个参数是请求码，用于在之后的回调中判断数据的来源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">startActivityForResult(intent, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>返回代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"data_return"</span>, <span class="string">"Hello MainActivity"</span>);</span><br><span class="line">setResult(RESULT_OK, intent);</span><br><span class="line">finish();</span><br></pre></td></tr></table></figure>

<p><strong>setResult()</strong>方法接收两个参数，第一个参数用于向上一个活动返回处理结果，一般只使用<strong>RESULT_OK</strong>或<strong>RESULT_CANCELED</strong>，第二个参数则是把带有数据的 Intent 传递回去，然后调用了 finish()方法来销毁当前活动。</p>
<p>在需要接收返回数据的 Activity 中重写<strong>onActivityResult()</strong>方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	<span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">		String returnedData = data.getStringExtra(<span class="string">"data_return"</span>);</span><br><span class="line">		Log.d(<span class="string">"FirstActivity"</span>, returnedData);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onActivityResult()方法带有三个参数：</p>
<p>第一个参数 requestCode，即我们在启动活动时传入的请求码。</p>
<p>第二个参数 resultCode，即我们在返回数据时传入的处理结果。</p>
<p>第三个参数 data，即携带着返回数据的 Intent。</p>
<h4 id="六、Activity启动模式"><a href="#六、Activity启动模式" class="headerlink" title="六、Activity启动模式"></a>六、Activity启动模式</h4><h5 id="使用-manifest-文件"><a href="#使用-manifest-文件" class="headerlink" title="使用 manifest 文件"></a>使用 manifest 文件</h5><p>在 manifest 文件中通过给<code>&lt;activity&gt;</code>标签的<strong>android:launchMode</strong>属性来指定恰当的启动模式。</p>
<p>1.<strong>standard标准模式</strong></p>
<p>​        每次启动一个 Activity 都会重新创建一个新的实例，不管这个实例是否已经存在，此模式的 Activity 默认会进入启动它的 Activity 所属的任务栈中；</p>
<p>2.<strong>singleTop栈顶复用模式</strong></p>
<p>​        如果新 Activity 已经位于任务栈的栈顶，那么此 Activity 不会被重新创建，同时会回调 <strong>onNewIntent</strong> 方法，如果已经存在但不在栈顶，那么 Activity 依然会被重新创建；一般用于推送消息跳转界面。</p>
<p>3.<strong>singleTask栈内复用模式</strong></p>
<p>​        Activity 在同一个Task内只有一个实例。每次启动该 Activity 时系统首先会在返回栈中检查是否存在该Activity 的实例，如果发现已经存在则直接使用该实例，回调其<strong>onNewIntent</strong>方法，并把在这个 Activity 之上的所有 Activity 统统出栈；如果没有发现就会创建一个新的 Activity 实例，并将其加入Task栈顶，一般项目的主页面用该启动模式。</p>
<p>4.<strong>singleInstance单实例模式</strong></p>
<p>整个系统里只有一个实例，Activity只能单独地位于一个任务栈中，且此任务栈中只有唯一一个实例，在不同app之间的共享活动实例，一般用于系统功能界面。</p>
<h5 id="使用-Intent-标志"><a href="#使用-Intent-标志" class="headerlink" title="使用 Intent 标志"></a>使用 Intent 标志</h5><p>Activity常用的标记位Flags</p>
<ul>
<li><p><strong>FLAG_ACTIVITY_NEW_TASK</strong>：<del>对应 singleTask 启动模式</del>。</p>
<p>1.单独的<code>FLAG_ACTIVITY_NEW_TASK</code> 并不等价于启动模式 <code>singleTask</code>，它仅表示寻找activity所需的任务栈压入，（即<code>TaskAffinity</code>指定的任务栈，<code>TaskAffinity</code> 默认为应用包名）</p>
<p>2.<code>FLAG_ACTIVITY_NEW_TASK</code>+<code>FLAG_ACTIVITY_CLEAR_TOP</code>也不等价于启动模式<code>singleTask</code></p>
<p>3.在<code>FLAG_ACTIVITY_NEW_TASK</code>+<code>FLAG_ACTIVITY_CLEAR_TOP</code>的情况下，AndroidManifest.xml中设置activity的启动模式为<code>standard</code>或<code>singleTask</code>时activity入栈方式是不一样的。分为如下3个情况：</p>
<p>​    <strong>3.1</strong>当启动模式为<code>standard</code>时，如果activity所需的栈中已经存在该activity的实例了，那么这个实例连同它之上的activity都要出栈，然后再新建一个activity实例入栈。</p>
<p>​    <strong>3.2</strong>当启动模式为<code>singleTask</code>时，如果activity所需的栈中已经存在该activity的实例了，那么系统会调用该实例的<code>onNewIntent()</code>方法，且只将该实例之上的activity出栈。</p>
<p>​    <strong>3.3</strong>如果activity所需的栈中<strong>不存在</strong>该activity的实例，则不论启动模式为<code>standard</code>还是<code>singleTask</code>，都是新建activity实例直接入栈。</p>
<p>4.AndroidManifest.xml中设置activity的启动模式为<code>singleTask</code>时，则不论是<code>FLAG_ACTIVITY_NEW_TASK</code>+<code>FLAG_ACTIVITY_CLEAR_TOP</code>还是只有<code>FLAG_ACTIVITY_NEW_TASK</code>效果一样，因为singleTask模式中默认就带有<code>FLAG_ACTIVITY_CLEAR_TOP</code>标识。</p>
</li>
<li><p><strong>FLAG_ACTIVITY_SINGLE_TOP</strong>：对应 singleTop 启动模式。</p>
</li>
<li><p><strong>FLAG_ACTIVITY_CLEAR_TOP</strong>：在同一个任务栈中所有位于它上面的 Activity 都要出栈。这个标记位一般会和 singleTask 模式一起出现，在这种情况下，被启动Activity的实例如果已经存在，那么系统就会回调onNewIntent。如果被启动的 Activity 采用 standard 模式启动，那么它以及连同它之上的 Activity 都要出栈，系统会创建新的 Activity 实例并放入栈中。</p>
</li>
<li><p><strong>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS :</strong> 具有这个标记的 Activity 不会出现在历史 Activity 列表中。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以此文记录 Android 中 Activity 的基础知识，便于对 Activity 的理解和学习。</p>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ContentProvider必备基础</title>
    <url>/2020/07/29/ContentProvider%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android的四大组件之一的ContentProvider。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是ContentProvider"><a href="#一、什么是ContentProvider" class="headerlink" title="一、什么是ContentProvider"></a>一、什么是ContentProvider</h4><p>ContentProvider 是 Android 中提供的专门用于不同应用间数据交互和共享的组件。它实际上是对SQLiteOpenHelper 的进一步封装，以一个或多个表的形式将数据呈现给外部应用，通过 Uri 映射来选择需要操作数据库中的哪个表，并对表中的数据进行增删改查处理。ContentProvider 其底层使用了 Binder 来完成APP 进程之间的通信，同时使用匿名共享内存来作为共享数据的载体。ContentProvider 支持访问权限管理机制，以控制数据的访问者及访问方式，保证数据访问的安全性。</p>
<a id="more"></a>

<h4 id="二、相关知识"><a href="#二、相关知识" class="headerlink" title="二、相关知识"></a>二、相关知识</h4><h5 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h5><p><strong>Uniform Resource Identifier</strong> 即统一资源标识符，外界进程通过 <code>URI</code> 找到对应的 ContentProvider 和其中的数据，再进行数据操作。以联系人Contacts 的 Uri 为例，其结构如下所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghdopxmxsmj30ig04kdfp.jpg" alt=""></p>
<p><strong>schema:</strong>  Android 中固定为 <code>content://</code>。</p>
<p><strong>authority:</strong>  用于唯一标识一个 ContentProvider。</p>
<p><strong>path:</strong>  ContentProvider 中数据表的表名。</p>
<p><strong>id:</strong>  数据表中数据的标识，可选字段。</p>
<h5 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h5><p>指定某种扩展名的文件用什么应用程序来打开的方式类型。ContentProvider 会根据 URI 来返回一个包含两部分 MIME 类型的字符串，每种 <code>MIME</code> 类型一般由2部分组成 = 类型 + 子类型，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">text/html <span class="comment">// 类型 = text、子类型 = html</span></span><br><span class="line">text/css </span><br><span class="line">text/xml </span><br><span class="line">application/pdf</span><br></pre></td></tr></table></figure>

<h5 id="UriMatcher类"><a href="#UriMatcher类" class="headerlink" title="UriMatcher类"></a>UriMatcher类</h5><p>是一个工具类，帮助匹配 ContentProvider 中的 Uri。提供了两个方法 <strong>addURI()</strong> 和 <strong>match()</strong> 方法。</p>
<ul>
<li><strong>addURI(String authority,String path, int code)：</strong>是在 ContentProvider 添加一个用于匹配的 Uri，当匹配成功时返回 code 。在 ContentProvider 中注册 URI ，把 Uri 和 code 相关联，Uri可以是精确的字符串，Uri 中带有*表示可匹配任意text，#表示只能匹配数字</li>
<li><strong>match(Uri uri) ：</strong>根据 URI 匹配 ContentProvider 中对应的数据表，对 Uri 进行验证。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：初始化UriMatcher对象</span></span><br><span class="line">    UriMatcher matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH); </span><br><span class="line">    <span class="comment">//常量UriMatcher.NO_MATCH  = 不匹配任何路径的返回码</span></span><br><span class="line">    <span class="comment">// 即初始化时不匹配任何东西</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：在ContentProvider 中注册URI（addURI（））</span></span><br><span class="line">    <span class="keyword">int</span> URI_CODE_a = <span class="number">1</span>；</span><br><span class="line">    <span class="keyword">int</span> URI_CODE_b = <span class="number">2</span>；</span><br><span class="line">    matcher.addURI(<span class="string">"com.prsuit.myprovider"</span>, <span class="string">"user"</span>, URI_CODE_a); </span><br><span class="line">    matcher.addURI(<span class="string">"com.prsuit.myprovider"</span>, <span class="string">"book"</span>, URI_CODE_b); </span><br><span class="line">    <span class="comment">// 若URI资源路径 = content://com.prsuit.myprovider/user ，则返回注册码URI_CODE_a</span></span><br><span class="line">    <span class="comment">// 若URI资源路径 = content://com.prsuit.myprovider/book ，则返回注册码URI_CODE_b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源（match（））</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMatchTableName</span><span class="params">(Uri uri)</span> </span>&#123;   </span><br><span class="line">      Uri uri = Uri.parse(<span class="string">" content://com.prsuit.myprovider/user"</span>);   </span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span>(matcher.match(uri))&#123;   </span><br><span class="line">     <span class="comment">// 根据URI匹配的返回码是URI_CODE_a</span></span><br><span class="line">     <span class="comment">// 即matcher.match(uri) == URI_CODE_a</span></span><br><span class="line">      <span class="keyword">case</span> URI_CODE_a:   </span><br><span class="line">        <span class="keyword">return</span> tableNameUser;   </span><br><span class="line">        <span class="comment">// 如果根据URI匹配的返回码是URI_CODE_a，则返回ContentProvider中的名为tableNameUser的表</span></span><br><span class="line">      <span class="keyword">case</span> URI_CODE_b:   </span><br><span class="line">        <span class="keyword">return</span> tableNameBook;</span><br><span class="line">        <span class="comment">// 如果根据URI匹配的返回码是URI_CODE_b，则返回ContentProvider中的名为tableNameBook的表</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ContentUris类"><a href="#ContentUris类" class="headerlink" title="ContentUris类"></a>ContentUris类</h5><p>用来操作 <code>URI</code>，核心方法有两个：<strong>withAppendedId()</strong> 和 <strong>parseId()</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// withAppendedId（）作用：向URI追加一个id</span></span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://com.prsuit.myprovider/user"</span>) </span><br><span class="line">Uri resultUri = ContentUris.withAppendedId(uri, <span class="number">7</span>);  </span><br><span class="line"><span class="comment">// 最终生成后的Uri为：content://com.prsuit.myprovider/user/7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parseId（）作用：从URL中获取ID</span></span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://com.prsuit.myprovider/user/7"</span>) </span><br><span class="line"><span class="keyword">long</span> personid = ContentUris.parseId(uri); </span><br><span class="line"><span class="comment">//获取的结果为:7</span></span><br></pre></td></tr></table></figure>

<h5 id="ContentProvider类"><a href="#ContentProvider类" class="headerlink" title="ContentProvider类"></a>ContentProvider类</h5><p>组织数据方式，ContentProvider 主要以 <strong>表格的形式</strong> 组织数据。进程间共享数据的本质是：添加、删除、获取和修改（更新）数据，所以其核心方法也主要是上述4个作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;-- <span class="number">4</span>个核心方法 --&gt;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span></span><br><span class="line"><span class="function">  <span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span></span><br><span class="line"><span class="function">  <span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function">  <span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs,  String sortOrder)</span>　 </span></span><br><span class="line"><span class="function">  <span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 注：</span></span></span><br><span class="line"><span class="function">  <span class="comment">// 1. 上述4个方法由外部进程回调，并运行在ContentProvider进程的Binder线程池中（不是主线程）</span></span></span><br><span class="line"><span class="function"> <span class="comment">// 2. 存在多线程并发访问，需要实现线程同步</span></span></span><br><span class="line"><span class="function">   <span class="comment">// a. 若ContentProvider的数据存储方式是使用SQLite &amp; 一个，则不需要，因为SQLite内部实现好了线程同步，若是多个SQLite则需要，因为SQL对象之间无法进行线程同步</span></span></span><br><span class="line"><span class="function">  <span class="comment">// b. 若ContentProvider的数据存储方式是内存，则需要自己实现线程同步</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&lt;-- 2个其他方法 --&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// ContentProvider创建后 或 打开系统后其它进程第一次访问该ContentProvider时 由系统进行调用</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注：运行在ContentProvider进程的主线程，故不能做耗时操作</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 得到数据类型，即返回当前 Url 所代表数据的MIME类型</span></span></span><br></pre></td></tr></table></figure>

<h5 id="ContentResolver类"><a href="#ContentResolver类" class="headerlink" title="ContentResolver类"></a>ContentResolver类</h5><p>统一管理不同 ContentProvider 间的操作，ContentProvider 类并不会直接与外部进程交互，而是通过ContentResolver 类。它提供了与 ContentProvider 类相同名字和作用的4个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span>　 </span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>　 </span></span><br><span class="line"><span class="function"><span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="ContentObserver类"><a href="#ContentObserver类" class="headerlink" title="ContentObserver类"></a>ContentObserver类</h5><p>内容观察者，观察 Uri 引起 ContentProvider 中的数据变化并通知数据访问者。当 ContentProvider 中的数据发生变化（增、删 、改）时，就会触发该 ContentObserver 类，可以通过 ContentResolver 的registerContentObserver 和 unregisterContentObserver 方法来注册和注销 ContentObserver 监听器。当被监听的ContentProvider发生变化时，就会回调对应的 ContentObserver 的 onChange 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：注册内容观察者ContentObserver</span></span><br><span class="line">    getContentResolver().registerContentObserver（uri）；</span><br><span class="line">    <span class="comment">// 通过ContentResolver类进行注册，并指定需要观察的URI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：当该URI的ContentProvider数据发生变化时，通知外界（即访问该ContentProvider数据的访问者）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123; </span><br><span class="line">      <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123; </span><br><span class="line">      db.insert(<span class="string">"user"</span>, <span class="string">"userid"</span>, values);</span><br><span class="line">      <span class="comment">// 通知访问者</span></span><br><span class="line">      getContext().getContentResolver().notifyChange(uri, <span class="keyword">null</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：解除观察者</span></span><br><span class="line"> getContentResolver().unregisterContentObserver（uri）；</span><br><span class="line">    <span class="comment">// 同样需要通过ContentResolver类进行解除</span></span><br></pre></td></tr></table></figure>

<h4 id="三、具体使用"><a href="#三、具体使用" class="headerlink" title="三、具体使用"></a>三、具体使用</h4><h5 id="创建数据库类"><a href="#创建数据库类" class="headerlink" title="创建数据库类"></a>创建数据库类</h5><p>创建类 DBHelper 继承 SQLiteOpenHelper 并实现构造方法以及重载 onCreate 和 onUpgrade 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATABASE_NAME = <span class="string">"com_sample_provider.db"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">"user"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOK_TABLE_NAME = <span class="string">"book"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATABASE_VERSION = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CREATE_USER_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span></span><br><span class="line">            + USER_TABLE_NAME</span><br><span class="line">            + <span class="string">"(id INTEGER PRIMARY KEY AUTOINCREMENT,name VARCHAR(64))"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CREATE_BOOK_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span></span><br><span class="line">            + BOOK_TABLE_NAME</span><br><span class="line">            + <span class="string">"(id INTEGER PRIMARY KEY AUTOINCREMENT,name VARCHAR(64))"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context,DATABASE_NAME,<span class="keyword">null</span>,DATABASE_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, <span class="keyword">int</span> version)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, name, factory, version);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, <span class="keyword">int</span> version, @Nullable DatabaseErrorHandler errorHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, name, factory, version, errorHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi</span>(api = Build.VERSION_CODES.P)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(@Nullable Context context, @Nullable String name, <span class="keyword">int</span> version, @NonNull SQLiteDatabase.OpenParams openParams)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, name, version, openParams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建数据表格:用户表和图书表</span></span><br><span class="line">        db.execSQL(CREATE_USER_TABLE);</span><br><span class="line">        db.execSQL(CREATE_BOOK_TABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空user表数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearTable</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        SQLiteDatabase database = <span class="keyword">new</span> DBHelper(context).getWritableDatabase();</span><br><span class="line">        database.execSQL(<span class="string">"delete from user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自定义-ContentProvider-类，实现相关的抽象方法"><a href="#自定义-ContentProvider-类，实现相关的抽象方法" class="headerlink" title="自定义 ContentProvider 类，实现相关的抽象方法"></a>自定义 ContentProvider 类，<strong>实现相关的抽象方法</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyContentProvider"</span>;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> DBHelper dbHelper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase mDatabase = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String matchTableName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ContentProvider的唯一标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">"com.prsuit.myprovider"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_PATH = <span class="string">"user"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOK_PATH = <span class="string">"book"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USER_CODE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOOK_CODE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UriMatcher matcher;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在ContentProvider 中注册URI</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://com.prsuit.myprovider/user ，则返回注册码USER_CODE</span></span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://com.prsuit.myprovider/book ，则返回注册码BOOK_CODE</span></span><br><span class="line">        matcher.addURI(AUTHORITY,USER_PATH,USER_CODE);</span><br><span class="line">        matcher.addURI(AUTHORITY,BOOK_PATH,BOOK_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mContext = getContext();</span><br><span class="line">        dbHelper = <span class="keyword">new</span> DBHelper(getContext());</span><br><span class="line">        mDatabase = dbHelper.getWritableDatabase();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(@NonNull Uri uri, @Nullable ContentValues values)</span> </span>&#123;</span><br><span class="line">        matchTableName = getMatchTableName(uri);</span><br><span class="line">        <span class="keyword">long</span> row = -<span class="number">1</span>;<span class="comment">//返回值是插入数据所在的行号</span></span><br><span class="line">        row = mDatabase.insert(matchTableName,<span class="keyword">null</span>,values);</span><br><span class="line">        <span class="keyword">if</span> (row &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">            mContext.getContentResolver().notifyChange(uri,<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> ContentUris.withAppendedId(uri,row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder)</span> </span>&#123;</span><br><span class="line">        matchTableName = getMatchTableName(uri);</span><br><span class="line">        Cursor cursor = mDatabase.query(matchTableName,projection,selection,selectionArgs,<span class="keyword">null</span>,<span class="keyword">null</span>,sortOrder);</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(@NonNull Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        matchTableName = getMatchTableName(uri);</span><br><span class="line">        <span class="comment">//返回值代表此次操作影响到的行数</span></span><br><span class="line">        <span class="keyword">int</span> deleteRow = mDatabase.delete(matchTableName, selection, selectionArgs);</span><br><span class="line">        <span class="keyword">if</span> (deleteRow &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            mContext.getContentResolver().notifyChange(uri,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deleteRow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        matchTableName = getMatchTableName(uri);</span><br><span class="line">        <span class="comment">//返回值代表此次操作影响到的行数</span></span><br><span class="line">        <span class="keyword">int</span> updateRow = mDatabase.update(matchTableName, values, selection, selectionArgs);</span><br><span class="line">        <span class="keyword">if</span> (updateRow &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            mContext.getContentResolver().notifyChange(uri,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> updateRow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMatchTableName</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">        String tableName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> uriCode = matcher.match(uri);</span><br><span class="line">        <span class="keyword">switch</span> (uriCode)&#123;</span><br><span class="line">            <span class="keyword">case</span> USER_CODE:</span><br><span class="line">                tableName = DBHelper.USER_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BOOK_CODE:</span><br><span class="line">                tableName = DBHelper.BOOK_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在-AndroidManifest-中声明-provider-以及定义相关访问权限"><a href="#在-AndroidManifest-中声明-provider-以及定义相关访问权限" class="headerlink" title="在 AndroidManifest 中声明 provider 以及定义相关访问权限"></a>在 AndroidManifest 中声明 provider 以及定义相关访问权限</h5><p>在注册ContentProvider的时候通过 android:process 属性设置 provider 运行在单独的进程里，模拟进程间通信。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- MyProvider 访问权限声明 --&gt;</span><br><span class="line">  <span class="comment">// 细分读 &amp; 写权限如下，也可直接采用全权限</span></span><br><span class="line">&lt;permission android:name=<span class="string">"com.prsuit.myprovider.READ"</span> </span><br><span class="line">  android:protectionLevel=<span class="string">"normal"</span> /&gt;</span><br><span class="line">&lt;permission android:name=<span class="string">"com.prsuit.myprovider.WRITE"</span></span><br><span class="line">        android:protectionLevel=<span class="string">"normal"</span> /&gt;</span><br><span class="line"> &lt;!-- &lt;permission android:name=<span class="string">"com.prsuit.myprovider.PROVIDER"</span></span><br><span class="line">        android:protectionLevel=<span class="string">"normal"</span> /&gt; --&gt;</span><br><span class="line">          </span><br><span class="line"> &lt;!-- 声明ContentProvider --&gt;</span><br><span class="line"> &lt;application&gt;</span><br><span class="line">    &lt;provider</span><br><span class="line">            android:name=<span class="string">".contentprovider.MyContentProvider"</span></span><br><span class="line">            android:authorities=<span class="string">"com.prsuit.myprovider"</span></span><br><span class="line">            android:process=<span class="string">":provider"</span></span><br><span class="line">            <span class="comment">// 声明外界进程可访问该Provider的全权限（读 &amp; 写）</span></span><br><span class="line">            <span class="comment">//android:permission="com.prsuit.myprovider.PROVIDER"</span></span><br><span class="line">            <span class="comment">// 权限可细分为读 &amp; 写的权限</span></span><br><span class="line">            android:readPermission=<span class="string">"com.prsuit.myprovider.READ"</span></span><br><span class="line">            android:writePermission=<span class="string">"com.prsuit.myprovider.WRITE"</span></span><br><span class="line">            android:exported=<span class="string">"true"</span> <span class="comment">//表明是否允许其他应用调用ContentProvider，true表示支持，false表示不支持</span></span><br><span class="line">            /&gt;</span><br><span class="line"> &lt;/application</span><br></pre></td></tr></table></figure>

<p>在其他应用要访问 MyContentProvider，需要在AndroidManifest中声明相应权限才可进行相应操作，否则会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 其他应用声明ContentProvider所需权限 --&gt; </span><br><span class="line">&lt;uses-permission android:name=<span class="string">"com.prsuit.myprovider.READ"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"com.prsuit.myprovider.WRITE"</span> /&gt;</span><br><span class="line">  <span class="comment">//采用全权限</span></span><br><span class="line">&lt;!--&lt;uses-permission android:name=<span class="string">"com.prsuit.myprovider.PROVIDER"</span> /&gt; --&gt;</span><br></pre></td></tr></table></figure>

<h5 id="通过ContentResolver根据URI进行增删改查"><a href="#通过ContentResolver根据URI进行增删改查" class="headerlink" title="通过ContentResolver根据URI进行增删改查"></a>通过ContentResolver根据URI进行增删改查</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentProviderActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">"com.prsuit.myprovider"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri USER_URI = Uri.parse(<span class="string">"content://"</span> + AUTHORITY + <span class="string">"/user"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startAct</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        context.startActivity(<span class="keyword">new</span> Intent(context, ContentProviderActivity<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_content_provider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertValue</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        ContentValues contentValues1 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        contentValues1.put(<span class="string">"id"</span>,<span class="number">0</span>);</span><br><span class="line">        contentValues1.put(<span class="string">"name"</span>,<span class="string">"kobe"</span>);</span><br><span class="line">        Uri insert1 = getContentResolver().insert(USER_URI, contentValues1);</span><br><span class="line">        System.out.println(<span class="string">"--insertValue1--&gt;"</span>+insert1.toString());</span><br><span class="line"></span><br><span class="line">        ContentValues contentValues2 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        contentValues2.put(<span class="string">"id"</span>,<span class="number">1</span>);</span><br><span class="line">        contentValues2.put(<span class="string">"name"</span>,<span class="string">"sh"</span>);</span><br><span class="line">        Uri insert2 = getContentResolver().insert(USER_URI,contentValues2);</span><br><span class="line">        System.out.println(<span class="string">"--insertValue2--&gt;"</span>+insert2.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateValue</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        ContentValues contentValues = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        contentValues.put(<span class="string">"id"</span>,<span class="number">1</span>);</span><br><span class="line">        contentValues.put(<span class="string">"name"</span>,<span class="string">"sh2"</span>);</span><br><span class="line">        <span class="keyword">int</span> row = getContentResolver().update(USER_URI,contentValues,<span class="string">"id = ?"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>&#125;);</span><br><span class="line">        System.out.println(<span class="string">"--updateValue--&gt;"</span>+row);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteValue</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = getContentResolver().delete(USER_URI,<span class="string">"name = ?"</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"sh2"</span>&#125;);</span><br><span class="line">        System.out.println(<span class="string">"--deleteValue--&gt;"</span>+row);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryValue</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        Cursor cursor = getContentResolver().query(USER_URI, <span class="keyword">new</span> String[]&#123;<span class="string">"id"</span>, <span class="string">"name"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext())&#123;</span><br><span class="line">            System.out.println(<span class="string">"query user："</span>+cursor.getInt(<span class="number">0</span>)+<span class="string">" "</span>+cursor.getString(cursor.getColumnIndex(<span class="string">"name"</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文基于 ContentProvider 的使用过程涉及到的相关知识点进行简单地介绍和整理，归纳总结了ContentProvider 使用步骤。</p>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/94b8582d089a" target="_blank" rel="noopener">Android四大组件——ContentProvider（基础篇）</a></p>
<p><a href="https://www.jianshu.com/p/ea8bc4aaf057" target="_blank" rel="noopener">Android：关于ContentProvider的知识都在这里了！</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 搭建博客教程</title>
    <url>/2020/07/20/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要是介绍在Mac上如何使用Hexo+GitHub搭建个人博客。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是-Hexo"><a href="#一、什么是-Hexo" class="headerlink" title="一、什么是 Hexo"></a>一、什么是 Hexo</h4><blockquote>
<p><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<a id="more"></a>

<h4 id="二、配置环境"><a href="#二、配置环境" class="headerlink" title="二、配置环境"></a>二、配置环境</h4><h5 id="申请GitHub"><a href="#申请GitHub" class="headerlink" title="申请GitHub"></a>申请GitHub</h5><p><a href="https://github.com/" target="_blank" rel="noopener">Github</a>注册账号，用作博客的远程仓库和部署服务器。</p>
<h5 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h5><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网下载</a>并安装，安装完成后可用<code>node -v</code>查看版本号。</p>
<h5 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h5><p>Mac 安装 Xcode 自带有 Git，也可去<a href="https://git-scm.com/" target="_blank" rel="noopener">官网下载</a>，安装完成后可用<code>git --version</code>查看版本号。</p>
<p>需要设置你 Github 的用户名密码和email，在命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure>

<h5 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h5><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h5 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h5><p>安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml  &#x2F;&#x2F; 配置信息，你可以在此配置大部分的参数</span><br><span class="line">├── package.json &#x2F;&#x2F; 应用程序的信息</span><br><span class="line">├── public       &#x2F;&#x2F; 执行 hexo generate 命令，输出的静态网页内容目录</span><br><span class="line">├── scaffolds    &#x2F;&#x2F; 模板文件夹。当你新建文章时，Hexo会根据scaffold来建立文件 </span><br><span class="line">├── scripts      &#x2F;&#x2F; 存放自定义 javascript 脚本</span><br><span class="line">├── source       &#x2F;&#x2F; 存放用户资源的地方</span><br><span class="line">|   ├── _drafts  &#x2F;&#x2F; 草稿文章</span><br><span class="line">|   └── _posts   &#x2F;&#x2F; 发布文章</span><br><span class="line">└── themes       &#x2F;&#x2F; 存放博客的主题，Hexo会根据主题来生成静态页面</span><br></pre></td></tr></table></figure>

<p>执行下列命令，会生成静态页面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate  <span class="comment"># 或者 hexo g</span></span><br></pre></td></tr></table></figure>

<p>启动本地服务，打开浏览器输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 即可访问。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server <span class="comment"># 或者 hexo s</span></span><br></pre></td></tr></table></figure>

<h4 id="三、部署到Github"><a href="#三、部署到Github" class="headerlink" title="三、部署到Github"></a>三、部署到Github</h4><h5 id="配置-SSH-Key，将本地目录与-Github-关联"><a href="#配置-SSH-Key，将本地目录与-Github-关联" class="headerlink" title="配置 SSH Key，将本地目录与 Github 关联"></a>配置 SSH Key，将本地目录与 Github 关联</h5><p>配置SSH Key是让本地 git 项目与远程仓库建立联系。SSH Keys不配置的话每次项目有改动提交的时候就要手动输入账号密码，配置了就不需要了。</p>
<p>首先检查是否已经有SSH Key，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure>

<p>如果没有目录.ssh，则要生成一个新的SSH Key，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your e-mail"</span></span><br></pre></td></tr></table></figure>

<p>接下来几步都直接按回车键，然后系统会要你输入密码。这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。</p>
<p>成功后进入到.shh文件夹中再输入ls，查看是否有id_rsa.pub文件，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>打开id_rsa.pub文件，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>复制SSH Key后，登录GitHub账号，在Setting-&gt;SSH keys-&gt;add SSH key，将其添加到Add SSH Key里。</p>
<h5 id="测试-SSH-Key-是否配置成功"><a href="#测试-SSH-Key-是否配置成功" class="headerlink" title="测试 SSH Key 是否配置成功"></a>测试 SSH Key 是否配置成功</h5><p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>如配置了密码则要输入密码，输完按回车。如果显示以下内容，则说明Github中的 ssh 配置成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hi username! You have successfully authenticated, but GitHub does not</span><br><span class="line">provide shell access.</span><br></pre></td></tr></table></figure>

<h5 id="创建仓库-Github-Pages"><a href="#创建仓库-Github-Pages" class="headerlink" title="创建仓库 Github Pages"></a>创建仓库 Github Pages</h5><p>登录GitHub账号后，新建 New repository，建立与你github用户名对应的仓库，名称必须为username.github.io，如prsuit.github.io。</p>
<h5 id="修改Hexo的-config-yml文件"><a href="#修改Hexo的-config-yml文件" class="headerlink" title="修改Hexo的_config.yml文件"></a>修改Hexo的<code>_config.yml</code>文件</h5><p>根目录<code>_config.yml</code>是博客的配置文件，用文本编辑器打开此文件，在文件最后部分，修改deploy配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/yourname/yourname.github.io.git <span class="comment">#yourname替换成你的Github账户名</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p><strong>注意：在<code>.yml</code>文件中，冒号后面都是要带空格的。</strong></p>
<h5 id="将博客项目上传到仓库"><a href="#将博客项目上传到仓库" class="headerlink" title="将博客项目上传到仓库"></a>将博客项目上传到仓库</h5><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">$ hexo d <span class="comment">#部署到远程仓库</span></span><br><span class="line"><span class="comment"># 或者 $ hexo g -d</span></span><br></pre></td></tr></table></figure>

<p>此时，通过访问 <a href="https://yourname.github.io/" target="_blank" rel="noopener">https://yourname.github.io</a> 可以看到默认的 Hexo 首页。</p>
<p>一些常用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">"postName"</span> <span class="comment"># 新建文章</span></span><br><span class="line"></span><br><span class="line">hexo new page <span class="string">"pageName"</span> <span class="comment"># 新建页面</span></span><br><span class="line"></span><br><span class="line">hexo generate <span class="comment"># 生成静态页面至public目录，markdown转html</span></span><br><span class="line"></span><br><span class="line">hexo server <span class="comment"># 开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line"></span><br><span class="line">hexo deploy <span class="comment"># 将.deploy目录部署到GitHub</span></span><br><span class="line"></span><br><span class="line">hexo clean <span class="comment"># 清除public文件夹和db.json，清除缓存数据</span></span><br><span class="line"></span><br><span class="line">hexo <span class="built_in">help</span> <span class="comment"># 查看帮助</span></span><br><span class="line"></span><br><span class="line">hexo version <span class="comment"># 查看Hexo的版本</span></span><br><span class="line"></span><br><span class="line">hexo n == hexo new</span><br><span class="line"></span><br><span class="line">hexo g == hexo generate</span><br><span class="line"></span><br><span class="line">hexo s == hexo server</span><br><span class="line"></span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>

<h4 id="四、更换Hexo主题"><a href="#四、更换Hexo主题" class="headerlink" title="四、更换Hexo主题"></a>四、更换Hexo主题</h4><p>Hexo 中有很多主题，可以在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网</a>查看。 推荐使用<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">hexo-theme-next</a>，更换主题步骤：</p>
<h5 id="下载主题资源"><a href="#下载主题资源" class="headerlink" title="下载主题资源"></a>下载主题资源</h5><p>终端cd到初始化博客文件夹目录下，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h5 id="配置使用下载的主题"><a href="#配置使用下载的主题" class="headerlink" title="配置使用下载的主题"></a>配置使用下载的主题</h5><p>修改博客目录下<code>_config.yml</code>里的theme的名称<code>landscape</code>更改为<code>next</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<h5 id="主题的其他配置"><a href="#主题的其他配置" class="headerlink" title="主题的其他配置"></a>主题的其他配置</h5><p>可在<code>/theme/{theme}/_config.yml</code> 主题的配置文件下进行主题的配置。</p>
<h5 id="添加分类"><a href="#添加分类" class="headerlink" title="添加分类"></a>添加分类</h5><p>新建一个页面，命名为 categories，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>

<p>在 source 目录下会生成 categories 目录，修改 source/categories 目录的 index.md 如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-07-19 20:24:49</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"categories"</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>在主题<code>/theme/{theme}/_config.yml</code> 中将<code>menu</code>的<code>catagories</code>取消注释，把前面的<code>#</code>去掉即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br></pre></td></tr></table></figure>

<p>给模板添加分类属性，打开scarffolds文件夹里的post.md文件，给它的头部加上categories:，这样我们创建的所有新的文章都会自带这个属性，我们只需要往里填分类，就可以自动在网站上形成分类了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories: 分类名 <span class="comment"># 多个分类，数组形式[分类名1，分类名2]</span></span><br><span class="line"><span class="comment"># 短横线形式</span></span><br><span class="line"><span class="comment"># - 分类名1</span></span><br><span class="line"><span class="comment"># - 分类名2</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h5 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h5><p>新建一个页面，命名为 tags，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>

<p>在 source 目录下会生成 tags 目录，修改 source/tags 目录的 index.md如下 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-07-19 20:28:30</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>同样，在主题<code>/theme/{theme}/_config.yml</code> 中将<code>menu</code>的<code>tags</code>取消注释，同上。</p>
<p>以后写文章时，在要分类的文章顶部加入 tags 属性，值为标签名:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories: 分类名</span><br><span class="line">tags: [标签a,标签b] <span class="comment"># 数组形式，添加a和b两个标签</span></span><br><span class="line"><span class="comment"># 短横线形式</span></span><br><span class="line"><span class="comment"># - 标签a</span></span><br><span class="line"><span class="comment"># - 标签b</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>至此，完成以上配置，可以执行调试命令查看效果。以后就可以使用Hexo发布文章了，当然还可以添加其他配置如文章阅读统计、评论等，可自行探索。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>万事开头难，但总算开头了💔，从此开启自己的博客生涯。第一次写Blog，写作思路不是很清晰流畅，花费了比较多的时间，希望以后会越来越好，Fighting！！！</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Git入门指南</title>
    <url>/2020/07/21/Git%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要是学习和记录在工作中经常用到的一些Git命令。这里推荐几个练习和学习Git命令的网站：</p>
<blockquote>
<p><strong><a href="https://learngitbranching.js.org/?locale=zh_CN" target="_blank" rel="noopener">Learn Git Branching</a></strong>、<strong><a href="https://git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository" target="_blank" rel="noopener">《Git文档》</a></strong>、<strong><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">《廖雪峰的Git教程》</a></strong></p>
</blockquote>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、基础必读"><a href="#一、基础必读" class="headerlink" title="一、基础必读"></a>一、基础必读</h4><h5 id="Git是什么"><a href="#Git是什么" class="headerlink" title="Git是什么"></a>Git是什么</h5><blockquote>
<p>Git is a <a href="https://git-scm.com/about/free-and-open-source" target="_blank" rel="noopener">free and open source</a> distributed version control system designed to handle everything from small to very large projects with speed and efficiency. </p>
<p>Git是一个免费和开源的分布式版本控制系统，致力于高效和快速的处理任何小或者大的项目。</p>
</blockquote>
<a id="more"></a>

<h5 id="Git中的几个概念"><a href="#Git中的几个概念" class="headerlink" title="Git中的几个概念"></a>Git中的几个概念</h5><p><strong>工作区、暂存区、版本库</strong></p>
<ul>
<li>工作区：就是在电脑里能够看到的目录，存放项目的文件夹。</li>
<li>暂存区：是在版本库<code>.git</code>目录下的<code>index</code>文件，称为stage（或者叫index）的暂存区。</li>
<li>版本库：工作区有一个隐藏目录<code>.git</code>，就是Git的版本库，主要存放暂存区和分支，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</li>
</ul>
<p>三者的关系如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3mg3awoxj30cq06iaa8.jpg" alt=""></p>
<p><code>git add</code> 命令把文件修改从工作目录添加到暂存区，<code>git commit</code> 命令把暂存区的所有内容提交到版本库当前分支。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3mizv2xbj30yg0ktgn7.jpg" alt=""><center>Git的过程</center></p>
<h5 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h5><p>如果我们想看一下工作区和暂存区文件的状态，可以使用命令 <code>git status</code>，</p>
<ul>
<li><code>Changes to be committed</code>：暂存区的文件。</li>
<li><code>Changes not staged for commit</code>：工作区的文件，还未保存到暂存区。</li>
<li><code>Untracked files</code>：指那些第一次创建，还没有加入版本更新的文件。</li>
</ul>
<p>对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。</p>
<h5 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h5><p>分支是多人协作开发中必不可少的角色，因为在我们的开发过程中，至少会有两个分支：</p>
<ul>
<li>正式版本的分支：线上代码版本保存的分支，需要稳定的运行。</li>
<li>开发主线的分支：下个版本需求的开发分支。</li>
<li>Bug分支：修复Bug的分支。</li>
</ul>
<h4 id="二、基础命令"><a href="#二、基础命令" class="headerlink" title="二、基础命令"></a>二、基础命令</h4><h5 id="暂存区相关"><a href="#暂存区相关" class="headerlink" title="暂存区相关"></a>暂存区相关</h5><h6 id="添加进暂存区"><a href="#添加进暂存区" class="headerlink" title="添加进暂存区"></a>添加进暂存区</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add .       <span class="comment"># 添加全部文件</span></span><br><span class="line">$ git add &lt;file&gt;  <span class="comment"># 添加某个文件</span></span><br></pre></td></tr></table></figure>

<h6 id="撤销工作区的修改"><a href="#撤销工作区的修改" class="headerlink" title="撤销工作区的修改"></a>撤销工作区的修改</h6><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -- &lt;file&gt;  <span class="comment"># 把工作区指定文件的修改全部撤销</span></span><br></pre></td></tr></table></figure>

<p>这里有两种情况：</p>
<p>一种是<code>file</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>file</code>已经添加到暂存区后，又作了修改，现在撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<h6 id="撤销暂存区的修改"><a href="#撤销暂存区的修改" class="headerlink" title="撤销暂存区的修改"></a>撤销暂存区的修改</h6><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD &lt;file&gt;  <span class="comment"># 把暂存区的修改撤销掉（unstage），重新放回工作区</span></span><br></pre></td></tr></table></figure>

<h5 id="版本库相关"><a href="#版本库相关" class="headerlink" title="版本库相关"></a>版本库相关</h5><h6 id="提交到版本库"><a href="#提交到版本库" class="headerlink" title="提交到版本库"></a>提交到版本库</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m &lt;message&gt;  <span class="comment"># message描述提交信息</span></span><br></pre></td></tr></table></figure>

<h6 id="撤销提交"><a href="#撤销提交" class="headerlink" title="撤销提交"></a>撤销提交</h6><p>在没有上传到远程分支时，进行版本库的撤销。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD~1  <span class="comment"># HEAD 代表当前的头结点，HEAD~n 代表当前节点的前n个节点</span></span><br></pre></td></tr></table></figure>

<h6 id="查看改动"><a href="#查看改动" class="headerlink" title="查看改动"></a>查看改动</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff HEAD -- &lt;file&gt;  <span class="comment"># 比较当前工作区和上一个版本的差异</span></span><br></pre></td></tr></table></figure>

<h6 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h6><p>直接在文件管理器中把文件删了，或者执行<code>rm</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm file  <span class="comment"># 仅从工作区删除文件</span></span><br></pre></td></tr></table></figure>

<p>在Git中删除也是一个修改操作，要想从版本库中删除文件，需执行两步。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm &lt;file&gt;  <span class="comment"># 从工作区删除文件并add到了暂存区</span></span><br><span class="line">$ git commit -m <span class="string">'remove file'</span>  <span class="comment"># 提交到版本库中</span></span><br></pre></td></tr></table></figure>

<h5 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h5><h6 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch  <span class="comment"># 查看本地所有分支，*是当前分支</span></span><br></pre></td></tr></table></figure>

<h6 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch &lt;name&gt;  <span class="comment"># name 分支名</span></span><br></pre></td></tr></table></figure>

<p>在本地创建和远程分支对应的分支，本地和远程分支的名称最好一致，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b branch-name origin/branch-name</span><br></pre></td></tr></table></figure>

<h6 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout &lt;name&gt;  <span class="comment"># 切换到name分支 或者 git switch &lt;name&gt;</span></span><br><span class="line">$ git checkout -b &lt;name&gt; <span class="comment"># 创建并切换name分支 或者 git switch -c &lt;name&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h6><p>合并保留之前的提交顺序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge &lt;name&gt;  <span class="comment"># 合并分支name到当前分支</span></span><br></pre></td></tr></table></figure>

<p>得到的提交历史更加线性，看着更加简洁。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rebase &lt;name&gt;  <span class="comment"># 合并分支name到当前分支</span></span><br></pre></td></tr></table></figure>

<h6 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d &lt;name&gt; <span class="comment"># 删除name分支</span></span><br></pre></td></tr></table></figure>

<h4 id="三、远程命令"><a href="#三、远程命令" class="headerlink" title="三、远程命令"></a>三、远程命令</h4><h5 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h5><p>远程仓库的默认名称是<code>origin</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote -v  <span class="comment"># -v 查看详细信息</span></span><br></pre></td></tr></table></figure>

<h5 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h5><h6 id="拉取最新代码"><a href="#拉取最新代码" class="headerlink" title="拉取最新代码"></a>拉取最新代码</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull &lt;origin&gt; &lt;branch-name&gt;  <span class="comment"># origin是我们远程分支的别名</span></span><br></pre></td></tr></table></figure>

<h6 id="上传代码"><a href="#上传代码" class="headerlink" title="上传代码"></a>上传代码</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push &lt;origin&gt; &lt;branch-name&gt; <span class="comment"># 推送到指定分支</span></span><br></pre></td></tr></table></figure>

<p>在上面的更新/推送命令中，默认了远程仓库的分支和当前的分支名一致，比如 <code>git push origin master</code>，本地分支名和远程分支的名称都为 <code>master</code>，如果不一致，则需要给定名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push/pull &lt;origin&gt; &lt;本地分支:远程分支&gt;</span><br></pre></td></tr></table></figure>

<h5 id="进阶命令"><a href="#进阶命令" class="headerlink" title="进阶命令"></a>进阶命令</h5><h6 id="追加更新"><a href="#追加更新" class="headerlink" title="追加更新"></a>追加更新</h6><p>更新上次 commit 的代码，避免再次生成一个 commit 记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<h6 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h6><p>建立本地分支和远程分支的关联。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream branch-name origin/branch-name</span><br></pre></td></tr></table></figure>

<h6 id="上一个版本"><a href="#上一个版本" class="headerlink" title="上一个版本"></a>上一个版本</h6><p>指定当前版本的上一个版本，比如想在 <code>master</code> 分支上一个版本的基础上对代码进行修改，我可以输入 <code>git checkout -b bugfix master^</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HEAD^</span><br><span class="line">分支^</span><br><span class="line">Hash值^</span><br></pre></td></tr></table></figure>

<h6 id="工作现场暂存和恢复"><a href="#工作现场暂存和恢复" class="headerlink" title="工作现场暂存和恢复"></a>工作现场暂存和恢复</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash  <span class="comment"># 把当前工作现场“储藏”起来，等以后恢复现场后继续工作</span></span><br><span class="line">$ git stash pop  <span class="comment"># 恢复工作现场，同时把stash内容也删了</span></span><br></pre></td></tr></table></figure>

<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>
<h6 id="复制一个特定的提交到当前分支"><a href="#复制一个特定的提交到当前分支" class="headerlink" title="复制一个特定的提交到当前分支"></a>复制一个特定的提交到当前分支</h6><p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;commit&gt;  <span class="comment"># commit 某次提交</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Git命令暂时先学习这些，掌握了这些可以胜任平时的开发，对于一些复杂的命令，使用的时候再查。</p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://juejin.im/post/5a2cdfe26fb9a0452936b07f" target="_blank" rel="noopener">《🛠Git 常用操作总结》</a><br><a href="https://juejin.im/post/5ba3aad7f265da0a8e6d801c" target="_blank" rel="noopener">《关于Android Studio使用Git的总结》</a><br><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">《廖雪峰的Git教程》</a></p>
<p><a href="https://juejin.im/post/5f0281aaf265da230f2838ba#heading-30" target="_blank" rel="noopener">《团队协作Git入门指南》</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>BroadcastReceiver必备基础</title>
    <url>/2020/07/27/BroadcastReceiver%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android的四大组件之一的BroadcastReceiver。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是BroadcastReceiver"><a href="#一、什么是BroadcastReceiver" class="headerlink" title="一、什么是BroadcastReceiver"></a>一、什么是BroadcastReceiver</h4><p>广播是一种广泛运用的在应用程序之间传输信息的机制，<strong>BroadcastReceiver</strong> 主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。广播机制是一个典型的发布-订阅模式，就是观察者模式。</p>
<a id="more"></a>

<h4 id="二、广播的种类"><a href="#二、广播的种类" class="headerlink" title="二、广播的种类"></a>二、广播的种类</h4><h5 id="普通广播-Normal-Broadcast"><a href="#普通广播-Normal-Broadcast" class="headerlink" title="普通广播(Normal Broadcast)"></a>普通广播(Normal Broadcast)</h5><p>普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。同级别接收是先后是随机的；级别低的收到广播；消息传递的效率比较高，并且无法中断广播的传播。</p>
<h5 id="有序广播-Ordered-Broadcast"><a href="#有序广播-Ordered-Broadcast" class="headerlink" title="有序广播(Ordered Broadcast)"></a>有序广播(Ordered Broadcast)</h5><p>有序广播是一种同步执行的广播。在有序广播发出之后同一时刻只会有一个广播接收器能收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传播。</p>
<p>所有的广播接收器按照优先级顺序依次执行，优先级高的先执行，低的后执行。广播接收器的优先级通过清单文件中 receiver 标签下 <code>intent-filter</code> 中的 <code>android:priority</code> 属性来设置，数值越大优先级越高，数值越小优先级越低。</p>
<p>在广播传递的过程中可对广播进行中断操作，通过在 onReceiver() 方法中调用 abortBroadcast() 方法实现，这样后面的广播接收器就无法收到广播消息了。</p>
<h5 id="本地广播-Local-Broadcast"><a href="#本地广播-Local-Broadcast" class="headerlink" title="本地广播(Local Broadcast)"></a>本地广播(Local Broadcast)</h5><p>为了解决广播的安全性问题，Android引入了本地广播机制，该机制能够在应用内部进行传递，并且广播接收器也只能接收来自本应用发出的广播，安全性高和效率高。本地广播主要是一个 LocalBroadcastManager 对广播进行管理，并提供发送跟注册广播接收器的方法。</p>
<h5 id="粘性广播-Sticky-Broadcast"><a href="#粘性广播-Sticky-Broadcast" class="headerlink" title="粘性广播(Sticky Broadcast)"></a>粘性广播(Sticky Broadcast)</h5><p>指广播在发出后，还会保存在 AMS 中，在广播发出之后注册的广播接收器也能收到之前发送的该广播，该广播在 Android 5.0 被废弃。</p>
<h4 id="三、广播的使用"><a href="#三、广播的使用" class="headerlink" title="三、广播的使用"></a>三、广播的使用</h4><h5 id="创建BroadcastReceiver"><a href="#创建BroadcastReceiver" class="headerlink" title="创建BroadcastReceiver"></a>创建BroadcastReceiver</h5><p>需要继承 BroadcastReceiver 基类，并重写 onReceive() 方法来接收消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承BroadcastReceivre基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 复写onReceive()方法</span></span><br><span class="line">  <span class="comment">// 接收到广播后，则自动调用该方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//写入接收广播后的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注册BroadcastReceiver"><a href="#注册BroadcastReceiver" class="headerlink" title="注册BroadcastReceiver"></a>注册BroadcastReceiver</h5><ul>
<li><p><strong>静态注册</strong></p>
<p>在 AndroidManifest.xml 里通过 <code>&lt;receiver&gt;</code> 标签声明，并在标签内用 <code>&lt;intent-filter&gt;</code> 标签设置过滤器。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;application&gt;</span><br><span class="line"> &lt;receiver </span><br><span class="line">    <span class="comment">//是否可以被系统实例化</span></span><br><span class="line">    android:enabled=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">   <span class="comment">//此broadcastReceiver能否接收其他App的发出的广播</span></span><br><span class="line">   <span class="comment">//默认值是由receiver中有无intent-filter决定的：如果有intent-filter，默认值为true，否则为false</span></span><br><span class="line">    android:exported=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:icon=<span class="string">"drawable resource"</span></span><br><span class="line">    android:label=<span class="string">"string resource"</span></span><br><span class="line">   <span class="comment">//继承BroadcastReceiver子类的类名</span></span><br><span class="line">    android:name=<span class="string">".CustomBroadcastReceiver"</span></span><br><span class="line"> <span class="comment">//具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收；</span></span><br><span class="line">    android:permission=<span class="string">"string"</span></span><br><span class="line"><span class="comment">//BroadcastReceiver运行所处的进程</span></span><br><span class="line"><span class="comment">//默认为app的进程，可以指定独立的进程</span></span><br><span class="line"><span class="comment">//注：Android四大基本组件都可以通过此属性指定自己的独立进程</span></span><br><span class="line">    android:process=<span class="string">"string"</span> &gt;</span><br><span class="line"><span class="comment">//用于指定此广播接收器将接收的广播类型</span></span><br><span class="line">  &lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">"com.sample.custom.actionName"</span> /&gt;</span><br><span class="line">  &lt;/intent-filter&gt;</span><br><span class="line"> &lt;/receiver&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态注册</strong></p>
<p>在代码中调用<code>Context.registerReceiver()</code>方法注册，<code>unregisterReceiver()</code> 方法取消注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择在Activity生命周期方法中的onResume()中注册</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onResume();</span><br><span class="line">    <span class="comment">// 1. 实例化BroadcastReceiver子类 &amp;  IntentFilter</span></span><br><span class="line">     mBroadcastReceiver mBroadcastReceiver = <span class="keyword">new</span> CustomBroadcastReceiver();</span><br><span class="line">     IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    <span class="comment">// 2. 设置接收广播的类型</span></span><br><span class="line">    intentFilter.addAction(<span class="string">"CustomActionName"</span>);</span><br><span class="line">    <span class="comment">// 3. 动态注册：调用Context的registerReceiver（）方法</span></span><br><span class="line">     registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册广播后，要在相应位置记得销毁广播</span></span><br><span class="line"><span class="comment">// 即在onPause() 中unregisterReceiver(mBroadcastReceiver)</span></span><br><span class="line"><span class="comment">// 当此Activity销毁前，onPause方法一定会执行，所以在此方法中取消注册。</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onPause();</span><br><span class="line">      <span class="comment">//销毁在onResume()方法中的广播</span></span><br><span class="line">     unregisterReceiver(mBroadcastReceiver);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:red">两者区别：</span></p>
<p><strong>静态注册</strong>：常驻型，不受组件生命周期影响。静态注册是在应用安装的时候由系统 PMS（PackageManagerService）完成整个注册过程。</p>
<p><strong>动态注册</strong>：非常驻型，广播接收器跟随组件的生命周期变化，有注册就必然得有注销，否则会导致<strong>内存泄露</strong>。对 Activity 最好在 <code>onResume()</code> 注册，在 <code>onPause()</code> 注销。如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。动态注册由 ContextImpl 来实现的，会调到 AMS.registerReceiver() 注册。</p>
<p>当广播接收者通过 intent 启动一个 activity 或者 service 时，如果 intent 中无法匹配到相应的组件，动态注册的广播接收者将会导致应用报错，而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。</p>
</li>
</ul>
<h5 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h5><p><strong>发送普通广播</strong>：定义广播所具备的“意图 (<code>Intent</code>) ”，使用 <strong>Context.sendBroadcast()</strong> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line"><span class="comment">//对应BroadcastReceiver中intentFilter的action</span></span><br><span class="line">intent.setAction(BROADCAST_ACTION);</span><br><span class="line"><span class="comment">//适配7.0及以上静态注册的广播收不到，静态注册需发送显式广播，即给intent指定包名。若是动态注册的则不需要</span></span><br><span class="line"><span class="comment">//intent.setComponent(new ComponentName(getPackageName(),getPackageName()+".CustomBroadcastReceiver"));</span></span><br><span class="line"><span class="comment">//发送广播</span></span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p><strong>发送有序广播</strong>：<strong>Context.sendOrderedBroadcast()</strong>，该方法接收两个参数，Intent &amp; 权限相关的字符串，无特殊要求可置为null。</p>
<p><strong>发送本地广播</strong>：使用 <strong>LocalBroadcastManager</strong> 类的 sendBroadcast()、registerReceiver()、unregisterReceiver()等方法，用于应用内部传递消息。对于LocalBroadcastManager方式发送的应用内广播，只能通过LocalBroadcastManager动态注册，不能静态注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册应用内广播接收器</span></span><br><span class="line"><span class="comment">//步骤1：实例化BroadcastReceiver子类 &amp; IntentFilter mBroadcastReceiver </span></span><br><span class="line">mBroadcastReceiver = <span class="keyword">new</span> CustomBroadcastReceiver(); </span><br><span class="line">IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter(); </span><br><span class="line"><span class="comment">//步骤2：实例化LocalBroadcastManager的实例</span></span><br><span class="line">localBroadcastManager = LocalBroadcastManager.getInstance(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//步骤3：设置接收广播的类型 </span></span><br><span class="line">intentFilter.addAction(BROADCAST_ACTION);</span><br><span class="line"><span class="comment">//步骤4：调用LocalBroadcastManager单一实例的registerReceiver（）方法进行动态注册 </span></span><br><span class="line">localBroadcastManager.registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line"><span class="comment">//取消注册应用内广播接收器</span></span><br><span class="line">localBroadcastManager.unregisterReceiver(mBroadcastReceiver);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送应用内广播</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(BROADCAST_ACTION);</span><br><span class="line"><span class="comment">//适配7.0及以上静态注册的广播收不到，静态注册需发送显式广播，即给intent指定包名。若是动态注册的则不需要</span></span><br><span class="line"><span class="comment">//intent.setComponent(new ComponentName(getPackageName(),getPackageName()+".CustomBroadcastReceiver"));</span></span><br><span class="line">localBroadcastManager.sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<h4 id="四、广播发送和接收原理"><a href="#四、广播发送和接收原理" class="headerlink" title="四、广播发送和接收原理"></a>四、广播发送和接收原理</h4><p>广播队列传送广播给 Receiver 的原理其实就是将 BroadcastReceiver 和消息都放到 BroadcastRecord 里面,然后通过 Handler 机制遍历 BroadcastQueue 里面的 BroadcastRecord，将消息发送给 BroadcastReceiver。详细细节可参考：<a href="https://www.jianshu.com/p/02085150339c" target="_blank" rel="noopener">广播的底层实现原理</a></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghb614kgilj30ng07edg2.jpg" alt=""></p>
<p>整个广播的机制可以总结成下面这张图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghb5zyxep8j30g00aqaa4.jpg" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>使用注意</strong>：</p>
<p> 当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过 action 匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，运行在 <code>UI</code> 线程，执行其中的 onReceiver() 方法，这个实例的生命周期只有10秒，10秒内没有执行结束 onReceiver() 系统将会导致 ANR ；<br>    在 onReceiver() 执行完毕之后，该实例将会被销毁，所以不要在 onReceiver() 中执行耗时操作，也不要在里面创建子线程处理业务（可能子线程没处理完，接收者就被回收了，子线程也会跟着被回收掉）；正确的处理方法就是通过 intent 调用 Activity 或者 Service 处理业务。</p>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://blog.csdn.net/xubinjie517/article/details/90239812#Sticky_Broadcast_38" target="_blank" rel="noopener">Android开发之BroadcastReceiver</a></p>
<p><a href="https://www.jianshu.com/p/ca3d87a4cdf3" target="_blank" rel="noopener">BroadcastReceiver史上最全面解析</a></p>
<p><a href="https://www.jianshu.com/p/02085150339c" target="_blank" rel="noopener">广播的底层实现原理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Fragment必备基础</title>
    <url>/2020/07/31/Fragment%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android常用的组件之一的Fragment。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是Fragment"><a href="#一、什么是Fragment" class="headerlink" title="一、什么是Fragment"></a>一、什么是Fragment</h4><p>Fragment，简称碎片，是 Android最基本，最重要的基础概念之一。Fragment 官方的定义是：</p>
<blockquote>
<p>A Fragment represents a behavior or a portion of user interface in an Activity. You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activities. You can think of a fragment as a modular section of an activity, which has its own lifecycle, receives its own input events, and which you can add or remove while the activity is running.</p>
</blockquote>
<a id="more"></a>

<ul>
<li>Fragment 是依赖于 Activity 的，不能独立存在的。</li>
<li>一个 Activity 里可以有多个 Fragment 。</li>
<li>一个 Fragment 可以被多个 Activity 重用。</li>
<li>Fragment 有自己的生命周期，并能接收输入事件。</li>
<li>我们能在 Activity 运行时动态地添加或删除 Fragment 。</li>
</ul>
<p><strong>Fragment 的优势有以下几点：</strong></p>
<ul>
<li><strong>模块化(Modularity)</strong>：我们不必把所有代码全部写在Activity中，而是把代码写在各自的Fragment中。</li>
<li><strong>可重用(Reusability)</strong>：多个Activity可以重用一个Fragment。</li>
<li><strong>可适配(Adaptability)</strong>：根据硬件的屏幕尺寸、屏幕方向，能够方便地实现不同的布局，这样用户体验更好。</li>
</ul>
<p><strong>Fragment核心的类有：</strong></p>
<ul>
<li><strong>Fragment</strong>：Fragment 的基类，任何创建的 Fragment 都需要继承该类。</li>
<li><strong>FragmentManager</strong>：管理和维护 Fragment。它是抽象类，具体的实现类是 <strong>FragmentManagerImpl</strong>。</li>
<li><strong>FragmentTransaction</strong>：对 Fragment 的添加、删除等操作都需要通过事务方式进行。它是抽象类，具体的实现类是 <strong>BackStackRecord</strong>。</li>
</ul>
<h4 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h4><p>Fragment的生命周期和Activity类似，但比Activity的生命周期复杂一些，基本的生命周期方法如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghguz2jnu5j30b409uq34.jpg" alt=""></p>
<ul>
<li><strong>onAttach</strong>：Fragment 和 Activity 相关联时调用。可以通过该方法获取 Activity 引用，还可以通过getArguments() 获取参数。</li>
<li><strong>onCreate</strong>：Fragment 被创建时调用。</li>
<li><strong>onCreateView</strong>：创建 Fragment 的布局。</li>
<li><strong>onActivityCreated</strong>：当 Activity 完成 onCreate() 时调用，在 onCreateView() 方法之后调用该方法。</li>
<li><strong>onStart</strong>：当 Fragment 开始可见时调用，此时还不可交互。</li>
<li><strong>onResume</strong>：当 Fragment 可见且可交互时调用。</li>
<li><strong>onPause</strong>：当 Fragment 不可交互但可见时调用，表明用户将要离开当前 Fragment 。</li>
<li><strong>onStop</strong>：当 Fragment 不可见时调用，Fragment 被停止。</li>
<li><strong>onDestroyView</strong>：当 Fragment 的 UI 从视图结构中移除时调用，销毁与 Fragment 有关的视图。</li>
<li><strong>onDestroy</strong>：销毁 Fragment 时调用。</li>
<li><strong>onDetach</strong>：当 Fragment 和 Activity 解除关联时调用。</li>
</ul>
<p>当一个 fragment 被创建的时候，需调用以下生命周期方法：onAttach(), onCreate(), onCreateView(), onActivityCreated()；</p>
<p>当这个 fragment 对用户可见可交互的时候，需调用：onStart() ,onResume()；</p>
<p>当这个 fragment 对用户不可交互不可见，进入后台模式需调用：onPause(),onStop()；</p>
<p>当这个 fragment 被销毁或者是持有它的 Activity 被销毁了，调用：onPause() ,onStop(), onDestroyView(), onDestroy(),onDetach()。</p>
<p>因为 Fragment 是依赖 Activity 的，Fragment 和 Activity 的生命周期方法有密切的关系和顺序，如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghgwq0ptw2j30hs0l4jsp.jpg" alt=""></p>
<p>举例来理解Fragment生命周期方法，共有两个Fragment：F1和F2，F1在初始化时就加入Activity，点击F1中的按钮调用replace替换为F2。</p>
<p>当F1在Activity的<code>onCreate()</code>中被添加时，日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BasicActivity: [onCreate] BEGIN</span><br><span class="line">BasicActivity: [onCreate] END</span><br><span class="line">BasicActivity: [onStart] BEGIN</span><br><span class="line">Fragment1: [onAttach] BEGIN </span><br><span class="line">Fragment1: [onAttach] END</span><br><span class="line">BasicActivity: [onAttachFragment] BEGIN</span><br><span class="line">BasicActivity: [onAttachFragment] END</span><br><span class="line">Fragment1: [onCreate] BEGIN</span><br><span class="line">Fragment1: [onCreate] END</span><br><span class="line">Fragment1: [onCreateView]</span><br><span class="line">Fragment1: [onViewCreated] BEGIN</span><br><span class="line">Fragment1: [onViewCreated] END</span><br><span class="line">Fragment1: [onActivityCreated] BEGIN</span><br><span class="line">Fragment1: [onActivityCreated] END</span><br><span class="line">Fragment1: [onStart] BEGIN</span><br><span class="line">Fragment1: [onStart] END</span><br><span class="line">BasicActivity: [onStart] END</span><br><span class="line">BasicActivity: [onPostCreate] BEGIN</span><br><span class="line">BasicActivity: [onPostCreate] END</span><br><span class="line">BasicActivity: [onResume] BEGIN</span><br><span class="line">BasicActivity: [onResume] END</span><br><span class="line">BasicActivity: [onPostResume] BEGIN</span><br><span class="line">Fragment1: [onResume] BEGIN</span><br><span class="line">Fragment1: [onResume] END</span><br><span class="line">BasicActivity: [onPostResume] END</span><br><span class="line">BasicActivity: [onAttachedToWindow] BEGIN</span><br><span class="line">BasicActivity: [onAttachedToWindow] END</span><br></pre></td></tr></table></figure>

<p>从上图可以看出：</p>
<ul>
<li><p>Fragment 的 onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()都是在 Activity 的 onStart() 中调用的。</p>
</li>
<li><p>Fragment 的 onResume() 在 Activity 的 onResume() 之后调用。</p>
</li>
</ul>
<p>当点击F1的按钮，调用<code>replace()</code>替换为F2，且不加<code>addToBackStack()</code>时，日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Fragment2: [onAttach] BEGIN</span><br><span class="line">Fragment2: [onAttach] END</span><br><span class="line">BasicActivity: [onAttachFragment] BEGIN</span><br><span class="line">BasicActivity: [onAttachFragment] END</span><br><span class="line">Fragment2: [onCreate] BEGIN</span><br><span class="line">Fragment2: [onCreate] END</span><br><span class="line">Fragment1: [onPause] BEGIN</span><br><span class="line">Fragment1: [onPause] END</span><br><span class="line">Fragment1: [onStop] BEGIN</span><br><span class="line">Fragment1: [onStop] END</span><br><span class="line">Fragment1: [onDestroyView] BEGIN</span><br><span class="line">Fragment1: [onDestroyView] END</span><br><span class="line">Fragment1: [onDestroy] BEGIN</span><br><span class="line">Fragment1: [onDestroy] END</span><br><span class="line">Fragment1: [onDetach] BEGIN</span><br><span class="line">Fragment1: [onDetach] END</span><br><span class="line">Fragment2: [onCreateView]</span><br><span class="line">Fragment2: [onViewCreated] BEGIN</span><br><span class="line">Fragment2: [onViewCreated] END</span><br><span class="line">Fragment2: [onActivityCreated] BEGIN</span><br><span class="line">Fragment2: [onActivityCreated] END</span><br><span class="line">Fragment2: [onStart] BEGIN</span><br><span class="line">Fragment2: [onStart] END</span><br><span class="line">Fragment2: [onResume] BEGIN</span><br><span class="line">Fragment2: [onResume] END</span><br></pre></td></tr></table></figure>

<p>可以看到，F1最后调用了<code>onDestroy()</code>和<code>onDetach()</code>。</p>
<p>当点击F1的按钮，调用<code>replace()</code>替换为F2，且加<code>addToBackStack()</code>时，日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Fragment2: [onAttach] BEGIN</span><br><span class="line">Fragment2: [onAttach] END</span><br><span class="line">BasicActivity: [onAttachFragment] BEGIN</span><br><span class="line">BasicActivity: [onAttachFragment] END</span><br><span class="line">Fragment2: [onCreate] BEGIN</span><br><span class="line">Fragment2: [onCreate] END</span><br><span class="line">Fragment1: [onPause] BEGIN</span><br><span class="line">Fragment1: [onPause] END</span><br><span class="line">Fragment1: [onStop] BEGIN</span><br><span class="line">Fragment1: [onStop] END</span><br><span class="line">Fragment1: [onDestroyView] BEGIN</span><br><span class="line">Fragment1: [onDestroyView] END</span><br><span class="line">Fragment2: [onCreateView]</span><br><span class="line">Fragment2: [onViewCreated] BEGIN</span><br><span class="line">Fragment2: [onViewCreated] END</span><br><span class="line">Fragment2: [onActivityCreated] BEGIN</span><br><span class="line">Fragment2: [onActivityCreated] END</span><br><span class="line">Fragment2: [onStart] BEGIN</span><br><span class="line">Fragment2: [onStart] END</span><br><span class="line">Fragment2: [onResume] BEGIN</span><br><span class="line">Fragment2: [onResume] END</span><br></pre></td></tr></table></figure>

<p>可以看到，F1被替换时，最后只调到了<code>onDestroyView()</code>，并没有调用<code>onDestroy()</code>和<code>onDetach()</code>。当用户点返回按钮回退事务时，F1会调 onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume()，因此在 Fragment 事务中加不加<code>addToBackStack()</code>会影响 Fragment 的生命周期。</p>
<p>FragmentTransaction 有一些基本方法，下面给出调用这些方法时，Fragment 生命周期的变化：</p>
<ul>
<li>add(): onAttach()-&gt;…-&gt;onResume()，添加进来的 fragment 都是可见的，不能重复添加同一 fragment，切换 fragment 时，不销毁当前的，创建新的，不会重新创建，一般配合 hide 或 remove 使用。</li>
<li>remove(): onPause()-&gt;…-&gt;onDetach()，销毁 fragment 。</li>
<li>replace(): 相当于旧 Fragment 调用remove()，新 Fragment 调用 add()，切换 fragment 时每次都会销毁当前的，创建新的，会重新创建初始化。和 add() 区别：<strong>是否要销毁当前fragment清空容器再添加新fragment</strong></li>
<li>show(): 不调用任何生命周期方法，调用该方法的前提是要显示的 Fragment 已经被添加到容器，只是纯粹把 Fragment UI 的 setVisibility 为 true。</li>
<li>hide(): 不调用任何生命周期方法，调用该方法的前提是要显示的 Fragment 已经被添加到容器，只是纯粹把Fragment UI的setVisibility为false。</li>
<li>detach(): onPause()-&gt;onStop()-&gt;onDestroyView()。UI从布局中移除，但是仍然被 FragmentManager 管理。</li>
<li>attach(): onCreateView()-&gt;onStart()-&gt;onResume()。</li>
</ul>
<h4 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h4><h5 id="创建-Fragment"><a href="#创建-Fragment" class="headerlink" title="创建 Fragment"></a>创建 Fragment</h5><p>首先创建继承 Fragment 的类，名为Fragment1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment1</span> <span class="keyword">extends</span> <span class="title">Fragment</span></span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String ARG_PARAM = <span class="string">"param_key"</span>; </span><br><span class="line">     <span class="keyword">private</span> String mParam; </span><br><span class="line">     <span class="keyword">private</span> Activity mActivity; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mActivity = (Activity) context;</span><br><span class="line">        mParam = getArguments().getString(ARG_PARAM);  <span class="comment">//获取参数</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View root = inflater.inflate(R.layout.fragment_1, container, <span class="keyword">false</span>);</span><br><span class="line">        TextView view = root.findViewById(R.id.text);</span><br><span class="line">        view.setText(mParam);</span><br><span class="line">             <span class="keyword">return</span> root;</span><br><span class="line">    &#125;    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fragment1 <span class="title">newInstance</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Fragment1 frag = <span class="keyword">new</span> Fragment1();</span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.putString(ARG_PARAM, str);</span><br><span class="line">        fragment.setArguments(bundle);   <span class="comment">//设置参数</span></span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fragment 有很多可以复写的方法，其中最常用的就是<code>onCreateView()</code>，该方法返回 Fragment 的UI布局，需要注意的是<code>inflate()</code>的第三个参数是 <strong>false</strong> ，因为在 Fragment 内部实现中，会把该布局添加到 container 中，如果设为 true，那么就会重复做两次添加，则会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: The specified child already has a parent. <span class="function">You must call <span class="title">removeView</span><span class="params">()</span> on the child's parent first.</span></span><br></pre></td></tr></table></figure>

<p>如果在创建Fragment时要传入参数，必须要通过<code>setArguments(Bundle bundle)</code>方式添加，而不建议通过为Fragment 添加带参数的构造函数，因为通过<code>setArguments()</code>方式添加，在由于内存紧张导致Fragment被系统杀掉并恢复（re-instantiate）时能保留这些数据。官方建议如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">It is strongly recommended that subclasses <span class="keyword">do</span> not have other constructors with parameters, since these constructors will not be called when the fragment is re-instantiated.</span><br></pre></td></tr></table></figure>

<p>我们可以在 Fragment 的<code>onAttach()</code>中通过<code>getArguments()</code>获得传进来的参数，并在之后使用这些参数。如果要获取 Activity 对象，不建议调用<code>getActivity()</code>，而是在<code>onAttach()</code>中将 Context 对象强转为 Activity 对象。</p>
<h5 id="添加Fragment到Activity"><a href="#添加Fragment到Activity" class="headerlink" title="添加Fragment到Activity"></a>添加Fragment到Activity</h5><ul>
<li><p><strong>静态添加</strong>：通过 <code>&lt;fragment&gt;</code> 标签的形式添加到 Activity 的布局 xml 当中，缺点是一旦添加就不能在运行时删除。</p>
</li>
<li><p><strong>动态添加</strong>：通过 java 代码将 fragment 添加到宿主 Activity 中，这种方式比较灵活，常用这种方式。</p>
</li>
</ul>
<p>这里只给出动态添加的方式。首先Activity需要有一个容器存放 Fragment ，一般是 FrameLayout，因此在Activity 的布局文件中加入 FrameLayout：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;FrameLayout</span><br><span class="line">    android:id=<span class="string">"@+id/container"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>然后在<code>onCreate()</code>中，通过以下代码将 Fragment 添加进 Activity 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bundle == <span class="keyword">null</span>) &#123;</span><br><span class="line">    getSupportFragmentManager().beginTransaction()</span><br><span class="line">        .add(R.id.container, Fragment1.newInstance(<span class="string">"hello world"</span>),<span class="string">"f1"</span>)</span><br><span class="line">      <span class="comment">//.addToBackStack("fname")</span></span><br><span class="line">        .commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意几点：</p>
<ul>
<li>使用<code>getSupportFragmentManager()</code>获取 FragmentManager。</li>
<li><code>add()</code>是对 Fragment 众多操作中的一种，还有<code>remove()</code>, <code>replace()</code>等，第一个参数是根容器的id（FrameLayout的id，即”@id/container”），第二个参数是 Fragment 对象，第三个参数是 fragment 的 tag 名，指定 tag 的好处是后续我们可以通过<code>Fragment1 frag = getSupportFragmentManager().findFragmentByTag(&quot;f1&quot;)</code>从 FragmentManager 中查找 Fragment 对象。</li>
<li>在一次事务中，可以做多个操作，比如同时做<code>add().remove().replace()</code>。</li>
<li><code>commit()</code>操作是异步的，内部通过<code>mManager.enqueueAction()</code>加入处理队列。对应的同步方法为<code>commitNow()</code>，<code>commit()</code>内部会有<code>checkStateLoss()</code>操作，如果开发人员使用不当（比如<code>commit()</code>操作在<code>onSaveInstanceState()</code>之后），可能会抛出异常，而<code>commitAllowingStateLoss()</code>方法则是不会抛出异常版本的<code>commit()</code>方法，但是尽量使用<code>commit()</code>，而不要使用<code>commitAllowingStateLoss()</code>。</li>
<li><code>addToBackStack(&quot;fname&quot;)</code>是可选的。FragmentManager 拥有回退栈（BackStack），类似于 Activity 的任务栈，如果添加了该语句，就把该事务加入回退栈，当用户点击返回按钮，会回退该事务（回退指的是如果事务是<code>add(frag1)</code>，那么回退操作就是<code>remove(frag1)</code>）；如果没添加该语句，用户点击返回按钮会直接销毁Activity。</li>
<li>Fragment 有一个常见的问题，即 Fragment 重叠问题，这是由于页面发生销毁重建(旋转屏幕、内存不足等情况被强杀重启)回到前台，重新初始化时，再次将 fragment 加入 activity，而 FragmentActivity 帮我们保存了 Fragment 的状态，并且在页面重启后会帮我们恢复，因此可在Activity的<code>onCreate()</code>里加上页面是否是重启的判断<code>if(saveInstanceState == null){}</code>。</li>
</ul>
<p><strong>Fragment有个常见的异常：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalStateException: Can not perform <span class="keyword">this</span> action after onSaveInstanceState</span><br><span class="line">    at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:<span class="number">1341</span>)</span><br><span class="line">    at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:<span class="number">1352</span>)</span><br><span class="line">    at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:<span class="number">595</span>)</span><br><span class="line">    at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:<span class="number">574</span>)</span><br></pre></td></tr></table></figure>

<p>该异常出现的原因是：commit() 在 onSaveInstanceState() 后调用。首先，onSaveInstanceState() 是在 Activity 有可能被系统回收的异常终止情况下，而且是在 onPause() 之后，onStop() 之前调用。onRestoreInstanceState() 在onStart() 之后，onResume() 之前。</p>
<p><strong>因此避免出现该异常的方案有：</strong></p>
<ul>
<li>不要把 Fragment 事务放在异步线程的回调中，比如不要把 Fragment 事务放在 AsyncTask 的onPostExecute()，因此 onPostExecute() 可能会在 onSaveInstanceState() 之后执行。</li>
<li>逼不得已时使用 commitAllowingStateLoss()，允许丢失一些界面的状态和信息。</li>
</ul>
<h4 id="四、Fragment实现原理和Back-Stack"><a href="#四、Fragment实现原理和Back-Stack" class="headerlink" title="四、Fragment实现原理和Back Stack"></a>四、Fragment实现原理和Back Stack</h4><p>我们知道 Activity 有任务栈，用户通过 startActivity 将 Activity 加入栈，点击返回按钮将 Activity 出栈。Fragment 也有类似的栈，称为回退栈（Back Stack），回退栈是由 FragmentManager 管理的。默认情况下，Fragment 事务是不会加入回退栈的，如果想将 Fragment 事务加入回退栈，则可以加入<code>addToBackStack(&quot;&quot;)</code>。如果没有加入回退栈，则用户点击返回按钮会直接将 Activity 出栈；如果加入了回退栈，则用户点击返回按钮会回滚 Fragment 事务。</p>
<p>我们将通过最常见的 Fragment 用法，讲解 Back Stack 的实现原理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getSupportFragmentManager().beginTransaction()</span><br><span class="line">    .add(R.id.container, f1, <span class="string">"f1"</span>)</span><br><span class="line">    .addToBackStack(<span class="string">""</span>)</span><br><span class="line">    .commit();</span><br></pre></td></tr></table></figure>

<p>上面这个代码的功能就是将 Fragment 加入 Activity 中，内部实现为：创建一个 BackStackRecord 对象，该对象记录了这个事务的全部操作轨迹（这里只做了一次 add 操作，并且加入回退栈），随后将该对象提交到 FragmentManager 的执行队列中，等待执行。</p>
<p>BackStackRecord 类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//androidx之前</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BackStackRecord</span> <span class="keyword">extends</span> <span class="title">FragmentTransaction</span> <span class="keyword">implements</span> <span class="title">FragmentManager</span>.<span class="title">BackStackEntry</span>, <span class="title">Runnable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// androidx之后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BackStackRecord</span> <span class="keyword">extends</span> <span class="title">FragmentTransaction</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">FragmentManager</span>.<span class="title">BackStackEntry</span>, <span class="title">FragmentManagerImpl</span>.<span class="title">OpGenerator</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>从定义可以看出，BackStackRecord 有三重含义：</p>
<ul>
<li>继承了 FragmentTransaction，即是事务，保存了整个事务的全部操作轨迹。</li>
<li>实现了 BackStackEntry，作为回退栈的元素，正是因为该类拥有事务全部的操作轨迹，因此在popBackStack() 时能回退整个事务。</li>
<li>继承了 Runnable，即被放入 FragmentManager 执行队列，等待被执行。</li>
</ul>
<p>先看第一层含义，<code>getSupportFragmentManager.beginTransaction()</code>返回的就是 BackStackRecord 对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">beginTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BackStackRecord(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>BackStackRecord 类包含了一次事务的整个操作轨迹，是以链表形式存在的，链表的元素是 Op 类，androidx 之后是保存在一个<code>ArrayList&lt;Op&gt; mOps = new ArrayList&lt;&gt;()</code>中，表示其中某个操作，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//androidx之前</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Op</span> </span>&#123;</span><br><span class="line">    Op next; <span class="comment">//链表后一个节点</span></span><br><span class="line">    Op prev; <span class="comment">//链表前一个节点</span></span><br><span class="line">    <span class="keyword">int</span> cmd;  <span class="comment">//操作是add或remove或replace或hide或show等</span></span><br><span class="line">    Fragment fragment; <span class="comment">//对哪个Fragment对象做操作</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// androidx之后</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Op</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mCmd;</span><br><span class="line">        Fragment mFragment;</span><br><span class="line">        <span class="keyword">int</span> mEnterAnim;</span><br><span class="line">        <span class="keyword">int</span> mExitAnim;</span><br><span class="line">        <span class="keyword">int</span> mPopEnterAnim;</span><br><span class="line">        <span class="keyword">int</span> mPopExitAnim;</span><br><span class="line">        Lifecycle.State mOldMaxState;</span><br><span class="line">        Lifecycle.State mCurrentMaxState;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下具体场景下这些类是怎么被使用的，比如我们的事务做add操作。add 函数的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">add</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag)</span> </span>&#123;</span><br><span class="line">   doAddOp(containerViewId, fragment, tag, OP_ADD);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>doAddOp()</code>方法就是创建 Op 对象，并加入链表，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAddOp</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag, <span class="keyword">int</span> opcmd)</span> </span>&#123;</span><br><span class="line">    fragment.mTag = tag;  <span class="comment">//设置fragment的tag</span></span><br><span class="line">    fragment.mContainerId = fragment.mFragmentId = containerViewId;  <span class="comment">//设置fragment的容器id</span></span><br><span class="line">    Op op = <span class="keyword">new</span> Op();</span><br><span class="line">    op.cmd = opcmd;</span><br><span class="line">    op.fragment = fragment;</span><br><span class="line">    addOp(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addOp() 是将创建好的 Op 对象加入链表，androidx 则加到列表，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOp</span><span class="params">(Op op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mHead = mTail = op;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        op.prev = mTail;</span><br><span class="line">        mTail.next = op;</span><br><span class="line">        mTail = op;</span><br><span class="line">    &#125;</span><br><span class="line">    mNumOp++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//androidx</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">addOp</span><span class="params">(Op op)</span> </span>&#123;</span><br><span class="line">        mOps.add(op);</span><br><span class="line">        op.mEnterAnim = mEnterAnim;</span><br><span class="line">        op.mExitAnim = mExitAnim;</span><br><span class="line">        op.mPopEnterAnim = mPopEnterAnim;</span><br><span class="line">        op.mPopExitAnim = mPopExitAnim;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>addToBackStack(“”)</code>是将 mAddToBackStack 变量记为 true，在 <code>commit()</code> 中会用到该变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">addToBackStack</span><span class="params">(@Nullable String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!mAllowAddToBackStack) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                   <span class="string">"This FragmentTransaction is not allowed to be added to the back stack."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       mAddToBackStack = <span class="keyword">true</span>;</span><br><span class="line">       mName = name;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>commit()</code>是异步的，即不是立即生效的，但是后面会看到整个过程还是在主线程完成，只是把事务的执行扔给主线程的 Handler，<code>commit()</code>内部是<code>commitInternal()</code>，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">commitInternal</span><span class="params">(<span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">    mCommitted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">        mIndex = mManager.allocBackStackIndex(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mIndex = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mManager.enqueueAction(<span class="keyword">this</span>, allowStateLoss); <span class="comment">//将事务添加进待执行队列中</span></span><br><span class="line">    <span class="keyword">return</span> mIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 mAddToBackStack 为 true，则调用<code>allocBackStackIndex(this)</code>将事务添加进回退栈，FragmentManager 类的变量 mBackStackIndices 就是回退栈。实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">allocBackStackIndex</span><span class="params">(BackStackRecord bse)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBackStackIndices == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mBackStackIndices = <span class="keyword">new</span> ArrayList&lt;BackStackRecord&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = mBackStackIndices.size();</span><br><span class="line">    mBackStackIndices.add(bse);</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>commitInternal()</code>中，<code>mManager.enqueueAction(this, allowStateLoss);</code>是将 BackStackRecord 加入待执行队列中，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueAction</span><span class="params">(Runnable action, <span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPendingActions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPendingActions = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingActions.add(action);</span><br><span class="line">    <span class="keyword">if</span> (mPendingActions.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        mHost.getHandler().removeCallbacks(mExecCommit);</span><br><span class="line">        mHost.getHandler().post(mExecCommit); <span class="comment">//调用execPendingActions()执行待执行队列的事务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mPendingActions 就是前面说的待执行队列，<code>mHost.getHandler()</code>就是主线程的Handler，因此 Runnable 是在主线程执行的，mExecCommit 的内部就是调用了<code>execPendingActions()</code>，即把 mPendingActions 中所有积压的没被执行的事务全部执行。执行队列中的事务会怎样被执行呢？就是调用<code>BackStackRecord的run()</code>方法，<code>run()</code>方法就是执行 Fragment 的生命周期函数，还有将视图添加进 container 中。</p>
<p>与<code>addToBackStack()</code>对应的是<code>popBackStack()</code>，有以下几种变种：</p>
<ul>
<li>popBackStack()：将回退栈的栈顶弹出，并回退该事务。</li>
<li>popBackStack(String name, int flag)：name 为 addToBackStack(String name) 的参数，通过 name 能找到回退栈的特定元素，flag 可以为0或者 FragmentManager.POP_BACK_STACK_INCLUSIVE ，0表示只弹出该元素以上的所有元素，POP_BACK_STACK_INCLUSIVE 表示弹出包含该元素及以上的所有元素。这里说的弹出所有元素包含回退这些事务。</li>
<li>popBackStack() 是异步执行的，是丢到主线程的 MessageQueue 执行，popBackStackImmediate() 是同步版本。</li>
</ul>
<p><code>getSupportFragmentManager().findFragmentByTag()</code>是经常用到的方法，是 FragmentManager 的方法，FragmentManager是抽象类，FragmentManagerImpl 是继承 FragmentManager 的实现类，他的内部实现是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FragmentManagerImpl</span> <span class="keyword">extends</span> <span class="title">FragmentManager</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Fragment&gt; mActive;</span><br><span class="line">    ArrayList&lt;Fragment&gt; mAdded;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">findFragmentByTag</span><span class="params">(String tag)</span> </span>&#123; </span><br><span class="line">           <span class="keyword">if</span> (mAdded != <span class="keyword">null</span> &amp;&amp; tag != <span class="keyword">null</span>) &#123; </span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i=mAdded.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                Fragment f = mAdded.get(i);</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">null</span> &amp;&amp; tag.equals(f.mTag)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> f;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">          <span class="keyword">if</span> (mActive != <span class="keyword">null</span> &amp;&amp; tag != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i=mActive.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                    Fragment f = mActive.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (f != <span class="keyword">null</span> &amp;&amp; tag.equals(f.mTag)) &#123;</span><br><span class="line">                          <span class="keyword">return</span> f;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面看到，先从 mAdded 中查找是否有该 Fragment，如果没找到，再从 mActive 中查找是否有该 Fragment。mAdded 是已经添加到 Activity 的 Fragment 的集合，mActive 不仅包含 mAdded，还包含虽然不在 Activity 中，但还在回退栈中的 Fragment。</p>
<h4 id="五、Fragment通信"><a href="#五、Fragment通信" class="headerlink" title="五、Fragment通信"></a>五、Fragment通信</h4><h5 id="Fragment向Activity传递数据"><a href="#Fragment向Activity传递数据" class="headerlink" title="Fragment向Activity传递数据"></a>Fragment向Activity传递数据</h5><p>首先，在 Fragment 中定义接口，并让 Activity 实现该接口（具体实现省略）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnFragmentInteractionListener</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(String str)</span></span>;  <span class="comment">//将str从Fragment传递给Activity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Fragment 的 onAttach() 中，将参数 Context 强转为 OnFragmentInteractionListener 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onAttach(context);</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> OnFragmentInteractionListener) &#123;</span><br><span class="line">        mListener = (OnFragmentInteractionListener) context;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(context.toString()</span><br><span class="line">                + <span class="string">" must implement OnFragmentInteractionListener"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在 Fragment 合适的地方调用<code>mListener.onItemClick(&quot;hello&quot;)</code>将”hello”从 Fragment 传递给 Activity。</p>
<h5 id="Activity向Fragment传递数据"><a href="#Activity向Fragment传递数据" class="headerlink" title="Activity向Fragment传递数据"></a>Activity向Fragment传递数据</h5><p>在 Fragment 初次创建时可通过 <code>fragment.setArguments(bundle)</code> 方法传递数据，其他时候，可以获取Fragment 对象，并调用 Fragment 的方法即可，比如要将一个字符串传递给 Fragment，则在 Fragment 中定义方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setString</span><span class="params">(String str)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.str = str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在 Activity 中调用<code>fragment.setString(&quot;hello&quot;)</code>即可。</p>
<h5 id="Fragment之间通信"><a href="#Fragment之间通信" class="headerlink" title="Fragment之间通信"></a>Fragment之间通信</h5><p>由于 Fragment 之间是没有任何依赖关系的，因此如果要进行 Fragment 之间的通信，建议通过 Activity 作为中介，不要 Fragment 之间直接通信。</p>
<h4 id="六、Fragment中的onActivityResult"><a href="#六、Fragment中的onActivityResult" class="headerlink" title="六、Fragment中的onActivityResult"></a>六、Fragment中的onActivityResult</h4><p>假设有一个 FragmentActivity 中嵌套一个 Fragment，它们各自使用 startActivityForResult 发起数据请求。<br>经测，目标所返回结果数据，能否被它们各自的 onActivityResult 方法所接收的情况如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghi3kbnbqwj30ks02tjrj.jpg" alt=""></p>
<ul>
<li>Fragment 和 FragmentActivity 都能接收到自己的发起的请求所返回的结果</li>
<li>FragmentActivity 发起的请求，Fragment 完全接收不到结果</li>
<li>Fragment 发起的请求，虽然在 FragmentActivity 中能获取到结果，但是requestCode完全对应不上</li>
</ul>
<blockquote>
<p>Fragment.startActivityForResult<br>↓<br>FragmentActivitymHost.HostCallbacks.onStartActivityFromFragment<br>↓<br>FragmentActivity.startActivityFromFragment</p>
</blockquote>
<p>从 Fragment 的 <code>startActivityForResult</code> 开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mHost == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fragment "</span> + <span class="keyword">this</span> + <span class="string">" not attached to Activity"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       mHost.onStartActivityFromFragment(<span class="keyword">this</span> <span class="comment">/*fragment*/</span>, intent, requestCode, options);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>调用了一个mHost.onStartActivityFromFragment 的方法。Fragment 被添加到一个 FragmentActivity 中之后，这里的 mHost 即是当前 FragmentActivity 的一个内部类 FragmentActivity.HostCallbacks，它持有对FragmentActivity 的引用，通过调用 <code>onStartActivityFromFragment</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartActivityFromFragment</span><span class="params">(@NonNull Fragment fragment, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">           FragmentActivity.<span class="keyword">this</span>.startActivityFromFragment(fragment, intent, requestCode, options);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>转发到当前 FragmentActivity 的 <code>startActivityFromFragment</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityFromFragment</span><span class="params">(Fragment fragment, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    mStartedActivityFromFragment = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode == -<span class="number">1</span>) &#123;</span><br><span class="line">            ActivityCompat.startActivityForResult(<span class="keyword">this</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((requestCode&amp;<span class="number">0xffff0000</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can only use lower 16 bits for requestCode"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> requestIndex = allocateRequestIndex(fragment);</span><br><span class="line">        ActivityCompat.startActivityForResult(</span><br><span class="line">            <span class="keyword">this</span>, intent, ((requestIndex+<span class="number">1</span>)&lt;&lt;<span class="number">16</span>) + (requestCode&amp;<span class="number">0xffff</span>), options);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mStartedActivityFromFragment = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析一下这段代码：<br>1.<code>mStartedActivityFromFragment = true</code>首先标记一下请求是来自于 Fragment。<br>2.<code>if(requestCode == -1)</code>的内容不用管，它是来自于 startActivity（没有ForResult）的情况。<br>3.然后的代码添加了对requestCode必须小于0xffff的限制 <code>if((requestCode&amp;0xffff0000) ！= 0){/*抛异常*/}</code><br>我们是从 Fragment.startActivityForResult 追踪到这里的，所以虽然文档没有明确说，但是从这里可以看出：<strong>Fragment.startActivityForResult的requestCode也是必须要&lt;=0xffff的。</strong></p>
<p><strong>然后，下面是关键点了：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ActivityCompat.startActivityForResult(</span><br><span class="line">            <span class="keyword">this</span>, intent, ((requestIndex+<span class="number">1</span>)&lt;&lt;<span class="number">16</span>) + (requestCode&amp;<span class="number">0xffff</span>), options);</span><br></pre></td></tr></table></figure>

<p>其中ActivityCompat是一个帮助类，ActivityCompat.startActivityForResult 最终还是调用的Activity.startActivityForResult。通过分析，得知 requestIndex 是请求的序号，值为从0递增的整数值。<br>又从前面得知，requestCode 的本身的值是小于0xffff的，所以<code>((requestIndex+1)&lt;&lt;16)+(requestCode&amp;0xffff)</code>简化一下就是：<code>(requestIndex+1)*65536+requestCode</code>——<strong>所以这个值是必定大于0xffff的。</strong></p>
<p>再看一下 <code>FragmentActivity.startActivityForResult</code> 的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If this was started from a Fragment we've already checked the upper 16 bits were not in</span></span><br><span class="line">    <span class="comment">// use, and then repurposed them for the Fragment's index.</span></span><br><span class="line">    <span class="keyword">if</span> (!mStartedActivityFromFragment) &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode != -<span class="number">1</span> &amp;&amp; (requestCode&amp;<span class="number">0xffff0000</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can only use lower 16 bits for requestCode"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.startActivityForResult(intent, requestCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，判断了一下如果请求不是来自于 Fragment，也就是来自于 FragmentActivity 自身，就限制 requestCode 不能大于0xffff。</p>
<p>再加上前文所说的，Fragment.startActivityForResult 最终映射的 requestCode 值必定大于0xffff，所以，现在可以得出了一个初步的结果：<br><strong>SDK 把 Fragment 和 FragmentActivity 的 requestCode 都限制在了0xffff以内，然后对于 Fragment 所发起的请求，都通过一个映射，把最终的 requestCode 变成了一个大于0xffff的值。</strong></p>
<p>可以推测到：<strong>在获取的结果的时候，也是会通过跟0xffff这个数值来比较，来区分是要把结果交给FragmentActivity 还是 Fragment 来处理。</strong></p>
<p>再来看一下 <code>FragmentActivity.onActivityResult</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    mFragments.noteStateNotSaved();</span><br><span class="line">    <span class="keyword">int</span> requestIndex = requestCode&gt;&gt;<span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestIndex != <span class="number">0</span>) &#123;</span><br><span class="line">        requestIndex--;</span><br><span class="line">        String who = mPendingFragmentActivityResults.get(requestIndex);</span><br><span class="line">        mPendingFragmentActivityResults.remove(requestIndex);</span><br><span class="line">        <span class="keyword">if</span> (who == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Activity result delivered for unknown Fragment."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Fragment targetFragment = mFragments.findFragmentByWho(who);</span><br><span class="line">        <span class="keyword">if</span> (targetFragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Activity result no fragment exists for who: "</span> + who);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            targetFragment.onActivityResult(requestCode&amp;<span class="number">0xffff</span>, resultCode, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>果然，证实了我们上面的推论。在FragmentActivity.onActivityResult 中，只有 <code>requestCode&gt;0xffff</code> 时，这里得到的 requestIndex 才能满足<code>requestIndex != 0</code>，然后进入下面的逻辑：把 requestCode 通过反向之前的映射关系，还原成最初 Fragment 所指定的 requestCode，交给 Fragment.onActivityResult 进行处理。</p>
<p><strong>注意：</strong>通过 FragementActivity 源码可以发现，源码里没有处理嵌套 Fragment 的情况，也就是说回调只到第一级Fragment，就没有继续分发。所以在第二级或者更深级别的 Fragment 调用 startActivityForResult 方法时，将无法收到 onActivityResult 回调。</p>
<ul>
<li><p><strong>使用 startActivityForResult 的时候，requestCode 一定不要大于 0xffff(65535)</strong>。</p>
</li>
<li><p>嵌套一层 Fragment 时，要在 Fragment 的 onActivityResult 接收数据，在 Fragment 中要使用 <code>Fragment.startActivityForResult</code>，而不是 <code>Fragment.getActivity().startActivityForResult</code>，如果 activity 中重写了 onActivityResult，那么一定要加上<code>super.onActivityResult(requestCode, resultCode, data)</code>。</p>
</li>
<li><p>嵌套多层 Fragment 时，要在第二级或更深级别的 Fragment 获取回调，需要重写 activity 的 onActivityResult 方法，继续分发回调给 Fragment。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAppCompatActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"TAG"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写onactivityresult方法，使二个或多个fragment嵌套使用时能收到onactivityresut回调</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        FragmentManager fm = getSupportFragmentManager();</span><br><span class="line">        <span class="keyword">int</span> index = requestCode &gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (fm.getFragments() == <span class="keyword">null</span> || index &lt; <span class="number">0</span></span><br><span class="line">                    || index &gt;= fm.getFragments().size()) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Activity result fragment index out of range: 0x"</span></span><br><span class="line">                        + Integer.toHexString(requestCode));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Fragment frag = fm.getFragments().get(index);</span><br><span class="line">            <span class="keyword">if</span> (frag == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Activity result no fragment exists for index: 0x"</span></span><br><span class="line">                        + Integer.toHexString(requestCode));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handleResult(frag, requestCode, resultCode, data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归调用，对所有子Fragement生效</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> frag</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(Fragment frag, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Intent data)</span> </span>&#123;</span><br><span class="line">        frag.onActivityResult(requestCode &amp; <span class="number">0xffff</span>, resultCode, data);</span><br><span class="line">        List&lt;Fragment&gt; frags = frag.getChildFragmentManager().getFragments();</span><br><span class="line">        <span class="keyword">if</span> (frags != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Fragment f : frags) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">null</span>)</span><br><span class="line">                    handleResult(f, requestCode, resultCode, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Fragment 中调用 startActivityForResult 时，一定要调用根 Fragment 的启动方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 得到根Fragment</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Fragment <span class="title">getRootFragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Fragment fragment = getParentFragment();</span><br><span class="line">  <span class="keyword">while</span> (fragment.getParentFragment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">   fragment = fragment.getParentFragment();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fragment;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 启动Activity</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onClickTextViewRemindAdvancetime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">  intent.setClass(getActivity(), YourActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  intent.putExtra(<span class="string">"TAG"</span>,<span class="string">"TEST"</span>); </span><br><span class="line">  getRootFragment().startActivityForResult(intent, <span class="number">1000</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="七、ViewPager-Fragment相关"><a href="#七、ViewPager-Fragment相关" class="headerlink" title="七、ViewPager+Fragment相关"></a>七、ViewPager+Fragment相关</h4><p>ViewPager 是 android 中提供界面滑动的类，继承自 ViewGroup。PagerAdapter 是 ViewPager 的适配器类，为ViewPager提供界面。但是一般来说，通常都会使用 PagerAdapter 的两个子类：FragmentPagerAdapter和FragmentStatePagerAdapter 作为 ViewPager 的适配器，他们的特点是界面是 Fragment 。</p>
<p>ViewPager 默认会缓存当前页相邻的<code>DEFAULT_OFFSCREEN_PAGES</code>(默认1)个界面，比如当滑动到第2页时，会初始化第1页和第3页的界面（即 Fragmen t对象，且生命周期函数运行到<code>onResume()</code>），可以通过<code>setOffscreenPageLimit(count)</code>设置当前页的左右两边的预加载界面数量。</p>
<p>FragmentPagerAdapter 和 FragmentStatePagerAdapter 需要重写的方法都一样，常见的重写方法如下：</p>
<ul>
<li>public FragmentPagerAdapter(FragmentManager fm)：构造函数，参数为 FragmentManager。如果是嵌套 Fragment 场景，子 PagerAdapter的参数传入 getChildFragmentManager()。</li>
<li>Fragment getItem(int position)：返回第 position 位置的 Fragment，必须重写。</li>
<li>int getCount(): 返回 ViewPager 的页数，必须重写。</li>
<li>Object instantiateItem(ViewGroup container, int position)：container 是 ViewPager 对象，返回第 position位置的 Fragment。</li>
<li>void destroyItem(ViewGroup container, int position, Object object)：container 是 ViewPager 对象，object 是 Fragment 对象。</li>
<li>getItemPosition(Object object)：object 是 Fragment 对象，如果返回 POSITION_UNCHANGED，则表示当前 Fragment 不刷新，如果返回 POSITION_NONE，则表示当前 Fragment 需要调用<code>destroyItem()</code>和<code>instantiateItem()</code>进行销毁和重建。 默认情况下返回 POSITION_UNCHANGED。</li>
</ul>
<p>FragmentPagerAdapter 和 FragmentStatePagerAdapter 的区别：</p>
<ul>
<li><strong>FragmentPagerAdapter</strong>：<strong>对Fragment的状态没有恢复和保存，对Fragment对象进行视图销毁</strong>。每个Fragment 会持久的保存在 FragmentManager 中，在 destroyItem() 中只是 detach，只是在页面上让 fragment 的UI脱离 Activity，但 fragment 仍然保存在内存里，并不会回收内存。因此适用于那些数据<strong>相对静态</strong>的页，Fragment <strong>数量也比较少</strong>的情况。</li>
<li><strong>FragmentStatePagerAdapter</strong>： <strong>对Fragment的状态进行了恢复和保存，对Fragment对象进行实例销毁</strong> 。只保留当前页面，当页面不可见时，在 destroyItem() 中会 remove 之前加载的 fragment，该 fragment 就会被消除，释放其内存资源。因此适用于那些<strong>数据动态性</strong>较大、<strong>占用内存</strong>较多，Fragment <strong>数量较多</strong>的情况。</li>
</ul>
<h4 id="八、懒加载"><a href="#八、懒加载" class="headerlink" title="八、懒加载"></a>八、懒加载</h4><h5 id="为什么要使用懒加载"><a href="#为什么要使用懒加载" class="headerlink" title="为什么要使用懒加载"></a>为什么要使用懒加载</h5><p>默认情况，ViewPager 会缓存当前页和左右相邻的界面。实现懒加载的主要原因是：用户没进入的界面需要有一系列的网络、数据库等耗资源、耗时的操作，预先做这些数据加载是不必要的。为了不做预先额外的数据加载，节省资源，就需要使用懒加载。</p>
<h5 id="什么是懒加载"><a href="#什么是懒加载" class="headerlink" title="什么是懒加载"></a>什么是懒加载</h5><p>当界面对用户可见时，才加载数据并更新UI，当界面对用户不可见时，停止加载数据等一切操作。</p>
<h5 id="如何实现懒加载"><a href="#如何实现懒加载" class="headerlink" title="如何实现懒加载"></a>如何实现懒加载</h5><p><strong>在 androidx 之前</strong>，懒加载主要依赖 Fragment 的<code>setUserVisibleHint(boolean isVisible)</code>方法，当Fragment变为可见时，会调用<code>setUserVisibleHint(true)</code>；当Fragment变为不可见时，会调用<code>setUserVisibleHint(false)</code>，且该方法调用时机：</p>
<ul>
<li>onAttach() 之前，调用<code>setUserVisibleHint(false)</code>。</li>
<li>onCreateView() 之前，如果该界面为当前页，则调用<code>setUserVisibleHint(true)</code>，否则调用<code>setUserVisibleHint(false)</code>。</li>
<li>界面变为可见时，调用<code>setUserVisibleHint(true)</code>。</li>
<li>界面变为不可见时，调用<code>setUserVisibleHint(false)</code>。</li>
</ul>
<p>懒加载 Fragment 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> View mRootView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsPrepared; <span class="comment">//表示UI是否准备好</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsInited;  <span class="comment">//表示是否已经做过数据加载</span></span><br><span class="line">                                            </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        mRootView = inflater.inflate(R.layout.fragment_lazy, container, <span class="keyword">false</span>);</span><br><span class="line">        mIsPrepared = <span class="keyword">true</span>;</span><br><span class="line">        lazyLoad();<span class="comment">// 解决第一次数据显示</span></span><br><span class="line">        <span class="keyword">return</span> mRootView;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lazyLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (getUserVisibleHint() &amp;&amp; mIsPrepared &amp;&amp; !mIsInited) &#123; </span><br><span class="line">           <span class="comment">//异步初始化，在初始化后显示正常UI</span></span><br><span class="line">           <span class="comment">//1. 加载数据  2. 更新UI  3. mIsInited = true</span></span><br><span class="line">           loadData();</span><br><span class="line">           mIsInited = <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//子类可重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加载数据</span></span><br><span class="line">    &#125;   </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserVisibleHint</span><span class="params">(<span class="keyword">boolean</span> isVisibleToUser)</span> </span>&#123; </span><br><span class="line">           <span class="keyword">super</span>.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">           <span class="keyword">if</span> (isVisibleToUser) &#123;</span><br><span class="line">             lazyLoad();</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyFragment <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> LazyFragment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>mIsPrepared：表示UI是否准备好，因为数据加载后需要更新UI，如果UI还没有inflate，就不需要做数据加载，因为setUserVisibleHint()会在onCreateView()之前调用一次，如果此时调用，UI还没有inflate，因此不能加载数据。</li>
<li>mIsInited：表示是否已经做过数据加载，如果做过了就不需要做了。因为 setUserVisibleHint(true) 在界面可见时都会调用，如果滑到该界面做过数据加载后，滑走，再滑回来，还是会调用 setUserVisibleHint(true)，此时由于mIsInited=true，因此不会再做一遍数据加载。</li>
<li>lazyLoad()：懒加载的核心类，在该方法中，只有界面可见（getUserVisibleHint()==true）、UI准备好（mIsPrepared==true）、过去没做过数据加载（mIsInited==false）时，才需要调loadData()做数据加载，数据加载做完后把mIsInited置为true。</li>
</ul>
<p><strong>在 androidx 之后</strong>，<code>setUserVisibleHint()</code>方法已经过时了，官方提出了<code>setMaxLifecycle()</code>方法来替代<code>setUserVisibleHint()</code>方法。</p>
<p><strong>setMaxLifecycle()方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set a ceiling for the state of an active fragment in this FragmentManager. If fragment is</span></span><br><span class="line"><span class="comment">     * already above the received state, it will be forced down to the correct state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The fragment provided must currently be added to the FragmentManager to have it's</span></span><br><span class="line"><span class="comment">     * Lifecycle state capped, or previously added as part of this transaction. The</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Lifecycle.State&#125; passed in must at least be &#123;<span class="doctag">@link</span> Lifecycle.State#CREATED&#125;, otherwise</span></span><br><span class="line"><span class="comment">     * an &#123;<span class="doctag">@link</span> IllegalArgumentException&#125; will be thrown.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragment the fragment to have it's state capped.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state the ceiling state for the fragment.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the same FragmentTransaction instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">setMaxLifecycle</span><span class="params">(@NonNull Fragment fragment,</span></span></span><br><span class="line"><span class="function"><span class="params">            @NonNull Lifecycle.State state)</span> </span>&#123;</span><br><span class="line">  addOp(<span class="keyword">new</span> Op(OP_SET_MAX_LIFECYCLE, fragment, state));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setMaxLifecycle()</code>方法定义在<strong>FragmentTransaction</strong>类中，它的内部逻辑很简单，其实我们经常使用的<code>add()</code>、<code>remove()</code>、<code>show()</code>、<code>hide()</code>等方法也是类似的逻辑，将操作封装为一个Op对象，最后调用<code>commit()</code>方法时再根据Op对象执行对应的操作。</p>
<p>注释中提到<code>setMaxLifecycle()</code>方法的作用是为 Fragment 的状态设置上限，如果当前 Fragment 的状态已经超过了设置的上限，就会强制被降到相应状态。在弄清楚上面这段文字的意义之前我首先要介绍两个相关概念：<strong>Fragment的状态</strong>和<strong>Lifecycle的状态</strong>。</p>
<ul>
<li><strong>Fragment的状态</strong></li>
</ul>
<p>在Fragment类中定义了5个int常量，表示Fragment的状态值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIALIZING = <span class="number">0</span>;     <span class="comment">// Not yet created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATED = <span class="number">1</span>;          <span class="comment">// Created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTIVITY_CREATED = <span class="number">2</span>; <span class="comment">// Fully created, not started.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STARTED = <span class="number">3</span>;          <span class="comment">// Created and started, not resumed.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESUMED = <span class="number">4</span>;          <span class="comment">// Created started and resumed.</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Lifecycle的状态</strong></li>
</ul>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">Lifecycle</a>是 Android Jetpack 中的架构组件之一，用于帮助我们方便地管理 Activity 和 Fragment 的生命周期，关于 Lifecycle 的详细介绍和使用网上有很多文章，我这里就不说了，如果此前没有接触过可以自行了解一下哈。<br>在 Lifecycle 定义了一个枚举类<strong>State</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    DESTROYED,</span><br><span class="line">    INITIALIZED,</span><br><span class="line">    CREATED,</span><br><span class="line">    STARTED,</span><br><span class="line">    RESUMED;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAtLeast</span><span class="params">(@NonNull State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 Lifecycle 中同样定义了5个状态，不过这里的状态和 Fragment中 定义的状态还是有一些区别的。</p>
<p>回到<code>setMaxLifecycle()</code>方法，需要传入的参数有两个：fragment和state。fragment不用多说，就是要设置的目标Fragment，不过需要注意的是<strong>此时Fragment必须已经被添加到了FragmentManager中，也就是调用了<code>add()</code>方法</strong>，否则会抛出异常。state就是Lifecycle中定义的枚举类型，同样需要注意<strong>传入的state应该至少为CREATED，换句话说就是只能传入CREATED、STARTED和RESUMED</strong>，否则同样会抛出异常。</p>
<p>下面就以我们最熟悉的生命周期方法来说明这个状态的限制，先上一张图总结一下结论：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghkm2rcvpcj32bg0u0tn8.jpg" alt=""></p>
<p>图中展示了 Fragment 状态间切换会执行的生命周期方法以及 Lifecycle.State 对应的 Fragment 状态，由于<code>setMaxLifecycle()</code>方法要求传入的state至少为<strong>CREATED</strong>，因此我们只需研究<strong>CREATED</strong>、<strong>STARTED</strong>和<strong>RESUMED</strong>这三个状态，结合上图解释一下<code>setMaxLifecycle()</code>方法的作用。</p>
<ul>
<li><strong>参数传入Lifecycle.State.CREATED</strong></li>
</ul>
<p><strong>Lifecycle.State.CREATED</strong>对应Fragment的<strong>CREATED</strong>状态，如果当前Fragment状态低于<strong>CREATED</strong>，也就是<strong>INITIALIZING</strong>，那么Fragment的状态会变为<strong>CREATED</strong>，依次执行<code>onAttach()</code>、<code>onCreate()</code>方法；如果当前Fragment状态高于<strong>CREATED</strong>，那么Fragment的状态会被强制降为<strong>CREATED</strong>，以当前Fragment状态为<strong>RESUMED</strong>为例，接下来会依次执行<code>onPause()</code>、<code>onStop()</code>和<code>onDestoryView()</code>方法。如果当前Fragment的状态恰好为<strong>CREATED</strong>，那么就什么都不做。</p>
<ul>
<li><strong>参数传入Lifecycle.State.STARTED</strong></li>
</ul>
<p><strong>Lifecycle.State.STARTED</strong>对应Fragment的<strong>STARTED</strong>状态，如果当前Fragment状态低于<strong>STARTED</strong>，那么Fragment的状态会变为<strong>STARTED</strong>，以当前Fragment状态为<strong>CREATED</strong>为例，接下来会依次执行<code>onCreateView()</code>、<code>onActivityCreate()</code>和<code>onStart()</code>方法；如果当前Fragment状态高于<strong>STARTED</strong>，也就是<strong>RESUMED</strong>，那么Fragment的状态会被强制降为<strong>STARTED</strong>，接下来会执行<code>onPause()</code>方法。如果当前Fragment的状态恰好为<strong>STARTED</strong>，那么就什么都不做。</p>
<ul>
<li><strong>参数传入Lifecycle.State.RESUMED</strong></li>
</ul>
<p><strong>Lifecycle.State.RESUMED</strong>对应Fragment的<strong>RESUMED</strong>状态，如果当前Fragment状态低于<strong>RESUMED</strong>，那么Fragment的状态会变为<strong>RESUMED</strong>，以当前Fragment状态为<strong>STARTED</strong>为例，接下来会执行<code>onResume()</code>方法。如果当前Fragment的状态恰好为<strong>RESUMED</strong>，那么就什么都不做。</p>
<p>那么 androidx 之后懒加载的新方案，这次的切入点在 <strong>FragmentPagerAdapter</strong> 中，我们会发现之前继承自 FragmentPagerAdapter 的构造方法同样过时了。提供了新的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FragmentPagerAdapter</span><span class="params">(@NonNull FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @Behavior <span class="keyword">int</span> behavior)</span> </span>&#123;</span><br><span class="line">    mFragmentManager = fm;</span><br><span class="line">    mBehavior = behavior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多了一个 int 类型的参数 behavior，可选的值有以下两个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BEHAVIOR_SET_USER_VISIBLE_HINT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出一个参数的构造方法默认传入<strong>BEHAVIOR_SET_USER_VISIBLE_HINT</strong>，将其赋值给mBehavior，那么这个mBehavior在什么地方用到了呢。在<strong>FragmentPagerAdapter.java</strong>文件中全局搜索一下，发现只有两个地方用到了mBehavior：<code>instantiateItem()</code>方法和<code>setPrimaryItem()</code>方法。<code>instantiateItem()</code>方法我们很熟悉，是初始化ViewPager中每个Item的方法，<code>setPrimaryItem()</code>方法我此前没有接触过，简单地看了一下源码发现它的作用是设置ViewPager将要显示的Item，在ViewPager切换时会调用该方法，我们来看一下FragmentPagerAdapter中的<code>setPrimaryItem()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrimaryItem</span><span class="params">(@NonNull ViewGroup container, <span class="keyword">int</span> position, @NonNull Object object)</span> </span>&#123;</span><br><span class="line">        Fragment fragment = (Fragment)object;</span><br><span class="line">        <span class="keyword">if</span> (fragment != mCurrentPrimaryItem) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCurrentPrimaryItem != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mCurrentPrimaryItem.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mCurrentPrimaryItem.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fragment.setMenuVisibility(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">                &#125;</span><br><span class="line">                mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fragment.setUserVisibleHint(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mCurrentPrimaryItem = fragment;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果 mBehavior 的值为<strong>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</strong>，那么就调用<code>setMaxLifecycle()</code>方法将上一个Fragment的状态设置为<strong>STARTED</strong>，将当前要显示的Fragment的状态设置为<strong>RESUMED</strong>；反之如果mBehavior的值为<strong>BEHAVIOR_SET_USER_VISIBLE_HINT</strong>，那么依然使用<code>setUserVisibleHint()</code>方法设置Fragment的可见性，相应地可以根据<code>getUserVisibleHint()</code>方法获取到Fragment是否可见，从而实现懒加载，具体做法：</p>
<ul>
<li><p>在构造 Adapter 对象的时候 behavior 参数传入 <strong>FragmentPagerAdapter.BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</strong>；</p>
</li>
<li><p>将 Fragment 加载数据的逻辑放到 onResume() 方法中，这样就保证了 Fragment 可见时才会加载数据。</p>
</li>
<li><p>声明一个变量标记是否是首次执行<code>onResume()</code>方法，因为每次 Fragment 由不可见变为可见都会执行<code>onResume()</code>方法，需要防止数据的重复加载。此外，如果我们使用的是 FragmentPagerAdapter，切换导致Fragment被销毁时是不会执行<code>onDestory()</code>和<code>onDetach()</code>方法的，只会执行到<code>onDestroyView()</code>方法，因此在<code>onDestroyView()</code>方法中我们还需要将这个变量重置，否则当Fragment再次可见时就不会重新加载数据了。</p>
</li>
</ul>
<p>以上几点我们就可以封装出新的懒加载 Fragment 了，完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NewLazyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isFirstLoad = <span class="keyword">true</span>; <span class="comment">// 是否第一次加载</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mContext = getActivity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View view = inflater.inflate(getLayoutRes(),container,<span class="keyword">false</span>);</span><br><span class="line">        initView(view);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroyView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView();</span><br><span class="line">        isFirstLoad = <span class="keyword">true</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        <span class="keyword">if</span> (isFirstLoad) &#123;</span><br><span class="line">            <span class="comment">// 将数据加载逻辑放到onResume()方法中</span></span><br><span class="line">            initData();</span><br><span class="line">            isFirstLoad = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置布局资源id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getLayoutRes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化视图</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文记录 Android 中 Fragment 的相关知识点，包括 Fragment 的基本定义及使用、生命周期、回退栈的内部实现、Fragment 通信、ViewPager+Fragment 的使用、AndroidX前、后的懒加载等，加深了对 Fragment 的理解和学习。</p>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/dUuGSVhWinAnN9uMiBaXgw" target="_blank" rel="noopener">Android基础：Fragment，看这篇就够了</a></p>
<p><a href="https://www.jianshu.com/p/ca91fa528d5c" target="_blank" rel="noopener">彻底搞懂startActivityForResult在FragmentActivity和Fragment中的异同</a></p>
<p><a href="https://www.cnblogs.com/xjx22/p/5263658.html" target="_blank" rel="noopener">Android的Fragment中onActivityResult不被调用的解决方案</a></p>
<p><a href="https://blog.csdn.net/qq_36486247/article/details/102531304" target="_blank" rel="noopener">androidx中的Fragment懒加载方案</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Service必备基础</title>
    <url>/2020/07/25/Service%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android的四大组件之一的Service。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是Service"><a href="#一、什么是Service" class="headerlink" title="一、什么是Service"></a>一、什么是Service</h4><p>Service 是一个应用程序组件，它能在后台执行一些耗时较长的操作，并且不提供用户界面。服务能被其他应用程序的组件启动，即使用户切换到另外的应用时还能保持后台运行。此外，应用程序组件还能与服务绑定，并与服务进行交互，甚至能进行进程间通信（IPC）。 比如，服务可以处理网络传输、音乐播放、执行文件I/O、或者与 content provider 进行交互，所有这些都是后台进行的。</p>
<a id="more"></a>

<ul>
<li><p>运行完全不依赖UI的，只要进程还在，Service 就可以继续运行，可以和其他组件组件交互；</p>
</li>
<li><p>一般运行在与创建服务时所在的应用程序进程中，要运行在单独的进程当中，在声明时需指定 <code>android:process</code>；</p>
</li>
<li><p>服务不会自动开启线程，我们需要在服务的内部手动创建子线程，并在这里执行具体的耗时任务。</p>
</li>
</ul>
<h4 id="二、Service分类"><a href="#二、Service分类" class="headerlink" title="二、Service分类"></a>二、Service分类</h4><h5 id="按运行分类"><a href="#按运行分类" class="headerlink" title="按运行分类"></a>按运行分类</h5><p><strong>前台服务</strong>：指那些经常会被用户关注的服务，因此内存过低时它不会成为被杀的对象。 前台服务必须提供一个状态栏通知，比较不容易被系统回收。</p>
<p><strong>后台服务</strong>：指在后台默默工作，提供数据运算等的服务，它优先级还是比较低的，当系统出现内存不足情况时，就有可能会回收掉正在后台运行的Service。</p>
<h5 id="按使用分类"><a href="#按使用分类" class="headerlink" title="按使用分类"></a>按使用分类</h5><p><strong>本地服务</strong>：用于应用程序内部，实现一些耗时任务，并不占用应用程序所属线程，而是单开线程后台执行。 </p>
<p><strong>远程服务</strong>：用于 Android 系统内部的应用程序之间，可被其他应用程序复用，比如天气预报服务，其他应用程序不需要再写这样的服务，调用已有的即可。</p>
<h4 id="三、Service启动状态"><a href="#三、Service启动状态" class="headerlink" title="三、Service启动状态"></a>三、Service启动状态</h4><h5 id="启动状态-Started"><a href="#启动状态-Started" class="headerlink" title="启动状态(Started)"></a>启动状态(Started)</h5><p>当应用组件（如 Activity）通过调用 <strong>startService()</strong> 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响，除非外部手动调用 <strong>stopService()</strong> 或内部调用 <strong>stopSelf()</strong> 才能停止服务， 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。</p>
<h5 id="绑定状态-Bound"><a href="#绑定状态-Bound" class="headerlink" title="绑定状态(Bound)"></a>绑定状态(Bound)</h5><p>当应用组件通过调用 <strong>bindService()</strong> 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器 <strong>IBinder</strong> 接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</p>
<h4 id="四、Service生命周期"><a href="#四、Service生命周期" class="headerlink" title="四、Service生命周期"></a>四、Service生命周期</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh7ysawqzfj30at0e3abt.jpg" alt=""></p>
<p><strong>onCreate()</strong>：首次创建服务时，将调用此方法，如果服务已在运行，则不会调用此方法，该方法只调用一次；</p>
<p><strong>onStartComand()</strong>：服务通过 <strong>startService()</strong> 启动时会调用，多次执行 <strong>startService()</strong> 方法，该方法也会相应的多次调用；</p>
<p><strong>onBind()</strong>：服务通过 <strong>bindService()</strong> 启动且服务是第一次创建时会调用，在此方法必须返回 一个 IBinder 接口的实现类对象，供客户端用来与服务进行通信，服务在启动状态的情况下可返回 null ；</p>
<p><strong>onUnBind()</strong>：服务通过 <strong>unbindService()</strong> 被解绑时调用；</p>
<p><strong>onDestroy()</strong>：服务停止或被解绑后调用；</p>
<h4 id="五、Service使用"><a href="#五、Service使用" class="headerlink" title="五、Service使用"></a>五、Service使用</h4><h5 id="Service在清单文件中的声明"><a href="#Service在清单文件中的声明" class="headerlink" title="Service在清单文件中的声明"></a>Service在清单文件中的声明</h5><p>通过继承Service基类自定义而来，都需要在AndroidManifest.xml中声明，Service在AndroidManifest.xml中的声明语法，其格式如下(不是所有都必填)：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;service android:enabled=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:exported=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:icon=<span class="string">"drawable resource"</span></span><br><span class="line">    android:isolatedProcess=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:label=<span class="string">"string resource"</span></span><br><span class="line">    android:name=<span class="string">"string"</span></span><br><span class="line">    android:permission=<span class="string">"string"</span></span><br><span class="line">    android:process=<span class="string">"string"</span> &gt;</span><br><span class="line">    . . .</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>android:exported：代表是否能被其他应用隐式调用，其默认值是由 service 中有无 intent-filter 决定的，如果有 intent-filter ，默认值为 true ，否则为 false 。为 false 的情况下，即使有 intent-filter 匹配，也无法打开，即无法被其他应用隐式调用。</li>
<li>android:name：对应 Service 类名，唯一必需的属性。</li>
<li>android:permission：申明此服务的权限。</li>
<li>android:process：是否需要在单独的进程中运行，当设置为 android:process=”:remote” 时，代表Service 在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以 “remote” 和 ”:remote” 不是同一个意思，前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。</li>
<li>android:isolatedProcess ：设置 true 意味着，服务会在一个特殊的进程下运行，这个进程与系统其他进程分开且没有自己的权限。与其通信的唯一途径是通过服务的API(bind and start)。</li>
<li>android:enabled：是否可以被系统实例化，默认为 true因为父标签 也有 enable 属性，所以必须两个都为默认值 true 的情况下服务才会被激活，否则不会激活。</li>
</ul>
<h5 id="通过startService启动"><a href="#通过startService启动" class="headerlink" title="通过startService启动"></a>通过startService启动</h5><ul>
<li><p>service 会一直无限期运行下去，只有外部调用了 stopService() 或 stopSelf() 方法时，该 Service 才会停止运行并销毁。</p>
</li>
<li><p>多次 startService 不会重复执行onCreate回调，但每次都会执行 onStartCommand 回调</p>
</li>
<li><p><strong>onStartCommand()</strong> 方法的返回值int类型才值得注意的，它有三种可选值：</p>
<p>START_STICKY：“黏性的”，当 Service 因内存不足而被系统 kill 后，一段时间后内存再次空闲时，系统将会尝试重新创建此 Service ，一旦创建成功后将回调 onStartCommand 方法，但其中的 Intent 将是null，除非有挂起的Intent，如pendingintent，比较适用于不执行命令、但无限期运行并等待作业的媒体播放器或类似服务。</p>
<p>START_NOT_STICKY：“非黏性的”，当 Service 因内存不足而被系统kill后，即使系统内存再次空闲时，系统也不会尝试重新创建此Service。</p>
<p>START_REDELIVER_INTENT：当 Service 因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，任何挂起 Intent 均依次传递。与 START_STICKY 不同的是，其中的传递的 Intent 将是非空，是最后一次调用 startService 中的 intent 。这个值适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</p>
</li>
</ul>
<h5 id="通过bindService启动"><a href="#通过bindService启动" class="headerlink" title="通过bindService启动"></a>通过bindService启动</h5><ul>
<li><p>该启动方式的调用者和服务之间是典型的 <strong>client-server</strong> 模式。调用者是 client ，service 则是 server 端。<strong>service 只有一个</strong>，但绑定到 service 上面的 client 可以有一个或很多个。这里所提到的 client 指的是组件，比如某个Activity。</p>
</li>
<li><p><strong>client 可以通过 IBinder 接口获取 Service 实例</strong>，从而实现在 client 端直接调用 Service 中的方法以实现交互。</p>
</li>
<li><p>启动服务的生命周期与其绑定的 client 息息相关。当 client 销毁时，client 会自动与 Service 解除绑定。当然，client 也可以明确调用 Context的 <strong>unbindService()</strong> 方法与 Service 解除绑定。<strong>当没有任何 client 与 Service 绑定时，Service 会自行销毁</strong>。</p>
</li>
<li><p><strong>onBind()</strong> 方法必须返回一个 IBinder接口的实现类对象，该类用以提供客户端用来与服务进行交互的编程接口，该接口可以通过三种方法定义接口：</p>
<p><strong>扩展 Binder 类</strong> ：如果服务是提供给自有应用专用的，并且 Service (服务端)与客户端相同的进程中运行，即客户端和服务位于<strong>同一应用和进程</strong>内才有效。通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中以及 Service 中可用的公共方法。如果我们的服务只是自有应用的后台工作线程，则优先采用这种方法。不采用该方式创建接口的唯一原因是，服务被其他应用或不同的进程调用。</p>
<p><strong>使用 Messenger</strong> ：通过它可以在<strong>不同的进程</strong>中共传递Message对象(Handler中的Messager，因此 Handler 是 Messenger 的基础)，在Message中可以存放我们需要传递的数据，然后在进程间传递。因为 Messenger 会在单一线程中创建包含所有请求的队列，也就是说Messenger是以串行的方式处理客户端发来的消息，这样我们就不必对服务进行线程安全设计了。</p>
<p><strong>使用 AIDL</strong> ：由于 Messenger 是以串行的方式处理客户端发来的消息，如果当前有大量消息同时发送到Service(服务端)，Service 仍然只能一个个处理，这也就是 Messenger 跨进程通信的缺点了，因此如果有大量并发请求，Messenger 就会显得力不从心了，这时 AIDL（Android Interface Definition Language） Android 接口定义语言就派上用场了，但实际上 Messenger 的跨进程方式其底层实现就是AIDL，只不过 android 系统帮我们封装成透明的 Messenger 罢了。如果我们想让服务同时处理多个请求，则应该使用 AIDL。它可以用于让某个 Service 与多个应用程序组件之间进行跨进程通信，从而可以实现<strong>多个应用程序共享同一个 Service</strong> 的功能。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务端LocalService部分代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> MyBinder mBinder = <span class="keyword">new</span> MyBinder();</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//建Binder对象，返回给客户端使用，提供数据交换的接口</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line"> 	    <span class="comment">// 声明一个方法，getService。（提供给客户端调用）</span></span><br><span class="line">    <span class="function">LocalService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回当前对象LocalService,这样我们就可在客户端调用Service的公共方法了</span></span><br><span class="line">      <span class="keyword">return</span> LocalService.<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//定义交互方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端--绑定服务实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BindActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ServiceConnection conn;</span><br><span class="line">  <span class="keyword">private</span> LocalService.MyBinder mBinder;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Overrid</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_bind);</span><br><span class="line">        btnBind = (Button) findViewById(R.id.BindService);</span><br><span class="line">        btnUnBind = (Button) findViewById(R.id.unBindService);</span><br><span class="line">        btnGetDatas = (Button) findViewById(R.id.getServiceDatas);</span><br><span class="line">        <span class="comment">//创建绑定对象</span></span><br><span class="line">        <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LocalService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 开启绑定</span></span><br><span class="line">        btnBind.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"绑定调用：bindService"</span>);</span><br><span class="line">                <span class="comment">//调用绑定方法</span></span><br><span class="line">                bindService(intent, conn, Service.BIND_AUTO_CREATE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 解除绑定</span></span><br><span class="line">        btnUnBind.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"解除绑定调用：unbindService"</span>);</span><br><span class="line">                <span class="comment">// 解除绑定</span></span><br><span class="line">                <span class="keyword">if</span>(mBinder!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    mBinder = <span class="keyword">null</span>;</span><br><span class="line">                    unbindService(conn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="comment">// 获取数据</span></span><br><span class="line">        btnGetDatas.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mBinder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 通过绑定服务传递的Binder对象，获取Binder暴露出来的数据</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"从服务端获取数据："</span> + mBinder.getCount());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"还没绑定呢，先绑定,无法从服务端获取数据"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">       conn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 与服务器端交互的接口方法 绑定服务的时候被回调，在这个方法获取绑定Service传递过来的IBinder对象，</span></span><br><span class="line"><span class="comment">             * 通过这个IBinder对象，实现宿主和Service的交互。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"绑定成功调用：onServiceConnected"</span>);</span><br><span class="line">                <span class="comment">// 获取Binder</span></span><br><span class="line">                mBinder = (LocalService.LocalBinder) service;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当取消绑定的时候被回调。但正常情况下是不被调用的，它的调用时机是当Service服务被意外销毁时，</span></span><br><span class="line"><span class="comment">             * 例如内存的资源不足时这个方法才被自动调用。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">                mBinder = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>onServiceConnected(ComponentName name, IBinder service)</strong><br>服务绑定成功后系统会调用该方法以传递服务的 onBind() 方法返回的 IBinder。其中 service 便是服务端返回的 IBinder 实现类对象，ComponentName 是一个封装了组件信息的类。</p>
</li>
<li><p><strong>onServiceDisconnected(ComponentName name)</strong><br>系统会在与服务的连接意外中断时（例如<strong>当服务崩溃或被终止</strong>时）调用该方法。<span style="color:red">注意:当客户端取消绑定时，系统“绝对不会”调用该方法</span>。</p>
</li>
<li><p><strong>bindService(Intent service, ServiceConnection conn, int flags)</strong></p>
<p>其中 Intent 是我们要绑定的服务的意图，而 ServiceConnection 代表与服务的连接，它只有两个方法，前面已分析过，flags 则是指定绑定时是否自动创建 Service 。0代表不自动创建、BIND_AUTO_CREATE 则代表自动创建。</p>
</li>
<li><p><strong>unbindService(ServiceConnection conn)</strong><br>该方法执行解除绑定的操作，其中 ServiceConnection 代表与服务的连接。</p>
</li>
</ul>
<h4 id="六、启动服务与绑定服务间的转换问题"><a href="#六、启动服务与绑定服务间的转换问题" class="headerlink" title="六、启动服务与绑定服务间的转换问题"></a>六、启动服务与绑定服务间的转换问题</h4><p>​        虽然服务的状态有启动和绑定两种，但实际上一个服务可以同时是这两种状态，它既可以是启动服务（以无限期运行），也可以是绑定服务。有点需要注意的是 Android 系统仅会为一个 Service 创建一个实例对象，所以不管是启动服务还是绑定服务，操作的是同一个 Service 实例，而且由于绑定服务或者启动服务执行顺序问题将会出现以下两种情况：<strong>（启动服务的优先级比绑定服务高一些）</strong></p>
<ul>
<li><p><strong>先绑定服务后启动服务</strong></p>
<p>如果当前 Service 实例先以绑定状态运行，然后再以启动状态运行，那么绑定服务将会转为启动服务运行，这时如果之前绑定的宿主（Activity）被销毁了，也不会影响服务的运行，服务还是会一直运行下去，指定收到调用停止服务或者内存不足时才会销毁该服务。</p>
</li>
<li><p><strong>先启动服务后绑定服务</strong></p>
<p>如果当前 Service 实例先以启动状态运行，然后再以绑定状态运行，当前启动服务并不会转为绑定服务，但是还是会与宿主绑定，只是即使宿主解除绑定后，服务依然按启动服务的生命周期在后台运行，直到有 Context调用了 stopService() 或是服务本身调用了 stopSelf() 方法抑或内存不足时才会销毁服务。</p>
</li>
</ul>
<h4 id="七、前台服务"><a href="#七、前台服务" class="headerlink" title="七、前台服务"></a>七、前台服务</h4><p>前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。前台服务必须为状态栏提供通知，设置服务运行于前台的方法。</p>
<h5 id="设置服务运行于前台"><a href="#设置服务运行于前台" class="headerlink" title="设置服务运行于前台"></a>设置服务运行于前台</h5><ul>
<li><p><strong>startForeground(int id, Notification notification)</strong></p>
<p>在 Service 创建 onCreate 时调用，该方法的作用是把当前服务设置为前台服务，其中id参数代表唯一标识通知的整型数，需要注意的是提供给 startForeground() 的整型 ID 不得为 0，而notification是一个状态栏的通知。Android 8.0之后对于通知栏也进行了整改，增加了通知渠道，通知组的概念。</p>
</li>
<li><p><strong>stopForeground(boolean removeNotification)</strong> </p>
<p>在 Service 销毁时调用，该方法是用来从前台删除服务，removeNotification 是否也删除状态栏通知。</p>
</li>
</ul>
<h5 id="启动前台服务"><a href="#启动前台服务" class="headerlink" title="启动前台服务"></a>启动前台服务</h5><p>在Android 8.0 之后需要使用 <strong>startForegroundService()</strong> 启动前台服务，并在清单文件中添加前</p>
<p>台服务权限 <code>android.permission.FOREGROUND_SERVICE</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">       startForegroundService(mForegroundService);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       startService(mForegroundService);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="八、如何提高服务在后台运行时间"><a href="#八、如何提高服务在后台运行时间" class="headerlink" title="八、如何提高服务在后台运行时间"></a>八、如何提高服务在后台运行时间</h4><p>关于 Service 保活后期会整理一篇主流的具体解决方案，主要思路是：</p>
<p>1.<strong>用 startService 方式启动 Service ，onStartCommand 方式中，返回 START_STICKY</strong> 。</p>
<p>2.<strong>提高 Service 的优先级</strong>，在清单文件中对于 intent-filter 可以通过 android:priority = “1000” 属性设置，1000是最高值，如果数字越小则优先级越低。</p>
<p>3.<strong>提升 Service 进程的优先级</strong>，使用前台服务。</p>
<p>4.<strong>设置应用白名单和电量管理</strong>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Service 实例对象同一应用中同时只会有一个。</li>
<li>Service默认并不会运行在子线程中，也不运行在一个独立的进程中，它同样执行在主线程中（UI线程）。换句话说，不要在Service里执行耗时操作，除非手动打开一个子线程，否则有可能出现主线程被阻塞（ANR）的情况。(Service执行的操作耗时最多是20s，BroadcastReceiver是10s，Activity是5s)</li>
<li>使用了远程 Service 后，Service 已经在另外一个进程当中运行了，所以只会阻塞该进程中的主线程，并不会影响到当前的应用程序。</li>
<li>默认 Service 和创建者在同一个进程内，如果将 Service 的 android:process 属性指定成” :remote”，表示Service 是在单独的进程创建远程服务。调用 startService 可以启动服务，但不能调用 bindService 绑定服务，因为创建者和 Service 运行在两个不同的进程中，不能再使用传统的建立关联的方式，需要使用 AIDL 来跨进程通信才可以绑定。</li>
<li>只有Activity、Service、Content Provider 能够绑定服务；BroadcastReceiver 广播接收器不能绑定服务</li>
</ul>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://blog.csdn.net/hdhhd/article/details/80612726" target="_blank" rel="noopener">安卓Service 详解</a></p>
<p><a href="https://www.jianshu.com/p/4c798c91a613" target="_blank" rel="noopener">Android Service两种启动方式详解</a></p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/11952435" target="_blank" rel="noopener">Android Service完全解析，关于服务你所需知道的一切</a></p>
<p><a href="https://blog.csdn.net/lmj623565791/article/details/47017485" target="_blank" rel="noopener">Android 基于Message的进程间通信 Messenger完全解析</a></p>
<p><a href="https://blog.csdn.net/lmj623565791/article/details/38461079" target="_blank" rel="noopener">Android aidl Binder框架浅析</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler消息机制</title>
    <url>/2020/08/02/Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android中的Handler消息机制。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是-Handler"><a href="#一、什么是-Handler" class="headerlink" title="一、什么是 Handler"></a>一、什么是 Handler</h4><p>Handler 机制是 Android 中用于线程间通信的一套异步通信机制。官方的介绍是：</p>
<blockquote>
<p>A Handler allows you to send and process <code>Message</code> and Runnable objects associated with a thread’s <code>MessageQueue</code>. Each Handler instance is associated with a single thread and that thread’s message queue. When you create a new Handler it is bound to a <code>Looper</code>. It will deliver messages and runnables to that Looper’s message queue and execute them on that Looper’s thread.</p>
</blockquote>
<a id="more"></a>

<p>Handler 允许你发送和处理与线程的 MessageQueue 关联的 Message 和 Runnable 对象。每个 Handler 实例都与一个线程和该线程的消息队列关联。当你创建一个新的 Handler，它将绑定到 Looper。它将消息和 runnables传递到该 Looper 的消息队列，并在该 Looper 的线程上执行它们。</p>
<p>一句话解释 Handler 消息机制：</p>
<blockquote>
<p>Handler 通过执行其绑定线程的消息队列（MessageQueue）中不断被 Looper 循环取出的消息（Message）来完成线程间的通信。</p>
</blockquote>
<p>Handler 消息机制主要包含四个类：</p>
<ul>
<li><strong>Message</strong>：需要被传递的消息，消息分为硬件产生的消息(如按钮、触摸)和软件生成的消息；</li>
<li><strong>MessageQueue</strong>：负责消息的存储与管理，负责管理由 Handler 发送过来的 Message，消息队列的主要功能向消息池投递消息(<code>MessageQueue.enqueueMessage</code>)和取走消息池的消息(<code>MessageQueue.next</code>)；</li>
<li><strong>Handler</strong>：负责 Message 的发送及处理，主要功能向消息池发送各种消息事件(<code>Handler.sendMessage</code>)和处理相应消息事件(<code>Handler.handleMessage</code>)；</li>
<li><strong>Looper</strong>：负责关联线程以及消息的分发，不断循环执行(<code>Looper.loop</code>)，从 MessageQueue 获取 Message，按分发机制将消息分发给对应的 Handler 处理。</li>
</ul>
<p>四者之间关系：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghm259akbpj30kb0iignf.jpg" alt=""></p>
<ul>
<li><strong>Looper</strong>有一个 MessageQueue 消息队列；</li>
<li><strong>MessageQueue</strong>有一组待处理的 Message；</li>
<li><strong>Message</strong>中有一个用于处理消息的 Handler；</li>
<li><strong>Handler</strong>中有 Looper 和 MessageQueue。</li>
</ul>
<p>Handler 消息机制工作流程可以理解为传送带模型：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghm4dup2wxj30rk0e8tlh.jpg" alt=""></p>
<p>异步消息处理线程的写法应该是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper.prepare();<span class="comment">//初始化Looper，一定要写在Handler初始化之前</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 定义消息处理逻辑</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//所有的事情处理完成后要退出looper，即终止Looper循环</span></span><br><span class="line">        <span class="comment">//这两个方法都可以</span></span><br><span class="line">        <span class="comment">// handler.getLooper().quit();</span></span><br><span class="line">        <span class="comment">// handler.getLooper().quitSafely();</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Looper.loop();<span class="comment">//启动Looper循环</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、Looper"><a href="#二、Looper" class="headerlink" title="二、Looper"></a>二、Looper</h4><p>用于运行线程的消息循环的类。默认情况下线程没有与之关联的消息循环；在要运行循环的线程中调用 prepare() 来创建一个 Looper，然后调用 loop() 使其循环处理消息，直到循环结束为止。</p>
<h5 id="prepare"><a href="#prepare" class="headerlink" title="prepare()"></a>prepare()</h5><p>初始化 Looper 对象，对于无参的情况，默认调用<code>prepare(true)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Initialize the current thread as a looper.</span></span><br><span class="line"><span class="comment">  * This gives you a chance to create handlers that then reference</span></span><br><span class="line"><span class="comment">  * this looper, before actually starting the loop. Be sure to call</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #quit()&#125;.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有参情况，参数 quitAllowed，true 表示当前 Looper 允许退出，而 false 表示当前 Looper 不允许退出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每个线程只允许执行一次该方法，第二次执行时线程的TLS已有数据，则会抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Looper对象，并保存到当前线程的TLS区域</span></span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Looper.prepare() 在<strong>当前线程</strong>使用 ThreadLocal <strong>保存一个通过构造方法生成的Looper实例</strong>，并在 Looper 构造方法中会创建一个 MessageQueue 对象，<strong>保存一个MessageQueue实例</strong>。该方法在<strong>同一个线程只能调用一次</strong>，所以<strong>一个线程只会存在一个 Looper 和一个 MessageQueue</strong> 。</p>
<p>看看 <code>sThreadLocal</code> 的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></span><br><span class="line">   <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure>

<p>可以看出 <code>sThreadLocal</code> 是 ThreadLocal 类型，操作的类型都是 <code>Looper</code> 类型。</p>
<p><strong>ThreadLocal</strong>： 线程本地存储区（Thread Local Storage，简称为TLS），提供线程局部变量，每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。</p>
<p>作用：<strong>为每个线程提供一个独立的变量副本，以解决并发访问的冲突问题</strong>。</p>
<p>本质：<strong>ThreadLocal 的静态内部类 ThreadLocalMap 为每个 Thread 都维护了一个 Entry 类型数组 table，ThreadLocal 对象确定了一个数组下标，而这个下标就是 value 存储的对应位置。get的时候，都是从自己的变量中取值，所以不存在线程安全问题</strong>。</p>
<p>Entry 类是继承自弱引用，弱引用里面放的就是 ThreadLocal 对象，Entry 的 value 存的是当前线程要存储的对象，value 作为 Entry 的成员变量。</p>
<p><strong>每个线程都持有一个 ThreadLocalMap 对象，而 threadlocal 负责访问和维护 ThreadLocalMap</strong>。</p>
<p><strong>ThreadLocal 内存泄漏的问题，从上面分析可以发现 ThreadLocalMap 里面的 Entry 对象存储的ThreadLocal 弱引用，而 value 直接作为 Entry 的强引用，ThreadLocal 对象可能被回收了，但 value 还在，这就造成了内存泄漏，因此在用到了 ThreadLocal 的地方，防止内存泄漏，手动调用 remove 方法。</strong></p>
<p>ThreadLocal 常用的操作方法：</p>
<ul>
<li><code>ThreadLocal.set(T value)</code>：将value存储到当前线程的TLS区域，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment">     * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment">     * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment">     * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment">     *        this thread-local.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ThreadLocal.get()</code>：获取当前线程TLS区域的数据，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment">    * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment">    * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment">    * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>对于 Looper 类型的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数私有化，外界只能通过静态方法prepare()初始化Looper</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">  mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);<span class="comment">//创建MessageQueue对象</span></span><br><span class="line">  mThread = Thread.currentThread();<span class="comment">//记录当前线程.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，与 <code>prepare()</code> 相近功能的，还有一个 <code>prepareMainLooper()</code> 方法，该方法主要在 ActivityThread 类中使用，初始化主线程的 Looper 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment">     * application's main looper. The main looper for your application</span></span><br><span class="line"><span class="comment">     * is created by the Android environment, so you should never need</span></span><br><span class="line"><span class="comment">     * to call this function yourself.  See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>);<span class="comment">//设置不允许退出的Looper</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Looper<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">           <span class="comment">//将当前的Looper保存为主Looper，每个线程只允许执行一次。</span></span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="myLooper"><a href="#myLooper" class="headerlink" title="myLooper()"></a>myLooper()</h5><p>用于获取 TLS 存储的 Looper 对象，外部通过调用 Looper.myLooper() 方法获取当前线程绑定的 Looper 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the Looper object associated with the current thread.  Returns</span></span><br><span class="line"><span class="comment">    * null if the calling thread is not associated with a Looper.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>myLooper()</code> 相近功能的，还有一个 <code>getMainLooper()</code> 方法，获取主线程 Looper 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the application's main looper, which lives in the main thread of the application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sMainLooper;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="loop"><a href="#loop" class="headerlink" title="loop()"></a>loop()</h5><p>loop() 方法作用是让消息队列循环起来和分发消息，需要注意的是 Looper.loop() 应该在该 Looper 所绑定的线程中执行。其核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();<span class="comment">//获取TLS存储的Looper对象</span></span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;<span class="comment">//获取Looper对象中的消息队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//进入loop的主循环方法</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block 可能会阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">               <span class="comment">// 没有消息，则退出循环</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            ...</span><br><span class="line">              </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);<span class="comment">//用于分发Message </span></span><br><span class="line">              ...</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();<span class="comment">//将Message放入消息池</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>loop() 进入循环模式，不断重复下面的操作，直到没有消息时退出循环。</p>
<ul>
<li><strong>Message msg = queue.next()</strong>，通过消息队列 MessageQueue 的 next() 方法从消息队列中取出一条消息 Message，如果此时消息队列中有 Message，那么 next 方法会立即返回该 Message，如果此时消息队列中没有 Message，那么 next 方法就会<strong>阻塞式</strong>地等待获取 Message ；</li>
<li><strong>msg.target.dispatchMessage(msg)</strong>，把 Message 分发给相应的 target ，target 值是 Handler，让 Message 所关联的 Handler 通过 dispatchMessage 方法让 Handler 处理该 Message ；</li>
<li><strong>msg.recycleUnchecked()</strong>，把分发后的 Message 回收到消息池，以便重复利用。</li>
</ul>
<h5 id="quit"><a href="#quit" class="headerlink" title="quit()"></a>quit()</h5><p>子线程开启的Looper，在所有的事情处理完成后要退出 Looper，即终止 Looper 循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//退出Looper，移除所有的消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mQueue.quit(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//安全退出Looper，只移除尚未触发的所有消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mQueue.quit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Looper.quit()方法的实现最终调用的是 MessageQueue.quit() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当mQuitAllowed为false，表示不运行退出，强行调用quit()会抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Main thread not allowed to quit."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="comment">//防止多次执行退出操作</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mQuitting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">                removeAllFutureMessagesLocked();<span class="comment">//移除尚未触发的所有消息</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                removeAllMessagesLocked();<span class="comment">//移除所有的消息</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意：线程 Thread 和 Looper 是一对一绑定的，一个线程可以有多个 Handler，但只能有一个 Looper，一个MessageQueue。</p>
<h4 id="三、Handler"><a href="#三、Handler" class="headerlink" title="三、Handler"></a>三、Handler</h4><h5 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h5><p>对于 Handler 的无参构造方法，默认采用当前线程 TLS 中的 Looper 对象，并且 Callback 回调方法为 null，且消息为同步处理方式。通过 ThreadLocal 获取到当前线程的 Looper 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造默认会调用该构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(@Nullable Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//匿名类、内部类或本地类都必须申明为static，否则会警告可能出现内存泄露</span></span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//必须先执行Looper.prepare()，才能获取Looper对象，否则为null.</span></span><br><span class="line">        mLooper = Looper.myLooper();<span class="comment">//从当前线程的TLS中获取Looper对象</span></span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread "</span> + Thread.currentThread()</span><br><span class="line">                        + <span class="string">" that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;<span class="comment">//消息队列，来自Looper对象</span></span><br><span class="line">        mCallback = callback;<span class="comment">//回调方法</span></span><br><span class="line">        mAsynchronous = async;<span class="comment">//设置消息是否为异步处理方式</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h5><p>Handler 类在构造方法中，可指定 Looper，Callback 回调方法以及消息的处理方式(同步或异步)，对于无 Looper 参的 Handler，默认是当前线程的 Looper 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(@Nullable Callback callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(callback, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(@NonNull Looper looper)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(@NonNull Looper looper, @Nullable Callback callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(looper, callback, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="keyword">null</span>, async);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(@NonNull Looper looper, @Nullable Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">   mLooper = looper;</span><br><span class="line">   mQueue = looper.mQueue;</span><br><span class="line">   mCallback = callback;</span><br><span class="line">   mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：在主线程中可以直接创建 Handler 对象，在子线程中需要先调用 Looper.prepare() 才能创建 Handler 对象。(因为程序启动时，ActivityThread 中的 main() 方法调用了 <code>Looper.prepareMainLooper()</code>，主线程中会始终存在一个 Looper 对象)</p>
<p>Callback 是 Handler 中的内部接口，Handler.Callback 是用来处理 Message 的一种手段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Callback interface you can use when instantiating a Handler to avoid</span></span><br><span class="line"><span class="comment">     * having to implement your own subclass of Handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> True if no further handling is desired</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(@NonNull Message msg)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Handler 处理 Message 的两种方法：</p>
<p>1.向 Hanlder 的构造函数传入一个 Handler.Callback 对象，并实现 Handler.Callback 的 handleMessage 方法；</p>
<p>2.无需向 Hanlder 的构造函数传入 Handler.Callback 对象，但是需要重写 Handler 本身的 handleMessage 方法。 </p>
<h5 id="消息分发机制"><a href="#消息分发机制" class="headerlink" title="消息分发机制"></a>消息分发机制</h5><p>在 Looper.loop() 中，当发现有消息时，调用消息的目标 handler，执行 <strong>dispatchMessage()</strong> 方法来分发消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handle system messages here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//当Message存在回调方法，回调msg.callback.run()方法；</span></span><br><span class="line">      handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//当Handler存在Callback成员变量时，回调Callback的handleMessage()；</span></span><br><span class="line">          <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//Handler自身的回调方法handleMessage()</span></span><br><span class="line">      handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行Message的回调方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//Handler自身的回调方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分发消息流程：</strong></p>
<ol>
<li>当<code>Message</code>的回调方法不为空时，则回调方法<code>msg.callback.run()</code>，其中 callBack 数据类型为 Runnable ，否则进入步骤2；</li>
<li>当<code>Handler</code>的<code>mCallback</code>成员变量不为空时，则回调方法<code>mCallback.handleMessage(msg)</code>，且回调方法要返回 true，否则进入步骤3；</li>
<li>调用<code>Handler</code>自身的回调方法<code>handleMessage()</code>，该方法默认为空，Handler 子类通过覆写该方法来完成具体的逻辑。</li>
</ol>
<h5 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h5><p>发送消息调用链：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghmzljvv00j30mu0ccwer.jpg" alt=""></p>
<p>可以发现所有的发消息方式，最终都是调用<code>MessageQueue.enqueueMessage()</code> 方法。</p>
<p><strong>sendMessage</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean sendMessage(@NonNull Message msg) &#123;</span><br><span class="line">    return sendMessageDelayed(msg, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sendEmptyMessage</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>sendEmptyMessageDelayed</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = what;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>sendMessageDelayed</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>sendMessageAtTime</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>sendMessageAtFrontOfQueue</strong></p>
<p>该方法通过设置消息的触发时间为0，从而使 Message 加入到消息队列的队头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtFrontOfQueue</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>enqueueMessage</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(@NonNull MessageQueue queue, @NonNull Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        msg.target = <span class="keyword">this</span>;<span class="comment">//将Message的target绑定为当前的Handler </span></span><br><span class="line">        msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<span class="comment">//将消息添加到消息队列中</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>post</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(@NonNull Runnable r)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建了一个Message对象，并将传入的Runnable对象赋值给Message的callback，然后返回该Message</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>postDelayed</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(@NonNull Runnable r, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、MessageQueue"><a href="#四、MessageQueue" class="headerlink" title="四、MessageQueue"></a>四、MessageQueue</h4><p>MessageQueue 是消息机制的 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理，其中MessageQueue 类中涉及的 native 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeDestroy</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePollOnce</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> timeoutMillis)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nativeIsPolling</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeSetFileDescriptorEvents</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">  mQuitAllowed = quitAllowed;</span><br><span class="line">  <span class="comment">//通过native方法初始化消息队列，其中mPtr是供native代码使用</span></span><br><span class="line">  mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="enqueueMessage"><a href="#enqueueMessage" class="headerlink" title="enqueueMessage"></a>enqueueMessage</h5><p>添加一条消息到消息队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 每一个普通Message必须有一个target</span></span><br><span class="line">       <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">//正在退出时，回收msg，加入到消息池</span></span><br><span class="line">               IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                       msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">               Log.w(TAG, e.getMessage(), e);</span><br><span class="line">               msg.recycle();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           msg.markInUse();</span><br><span class="line">           msg.when = when;</span><br><span class="line">           Message p = mMessages;</span><br><span class="line">           <span class="keyword">boolean</span> needWake;</span><br><span class="line">           <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">               <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">              <span class="comment">//p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的， 则进入该该分支</span></span><br><span class="line">               msg.next = p;</span><br><span class="line">               mMessages = msg;</span><br><span class="line">               needWake = mBlocked; <span class="comment">//当阻塞时需要唤醒</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">               <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">               <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">              <span class="comment">//将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非</span></span><br><span class="line">              <span class="comment">//消息队头存在barrier，并且同时Message是队列中最早的异步消息。</span></span><br><span class="line">               needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">               Message prev;</span><br><span class="line">               <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                   prev = p;</span><br><span class="line">                   p = p.next;</span><br><span class="line">                   <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                       needWake = <span class="keyword">false</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">               prev.next = msg;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">          <span class="comment">//消息没有退出，我们认为此时mPtr != 0</span></span><br><span class="line">           <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">               nativeWake(mPtr);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>MessageQueue 是按照 Message 触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p>
<h5 id="next"><a href="#next" class="headerlink" title="next"></a>next</h5><p>取出下一条消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;<span class="comment">//当消息循环已经退出，则直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// 循环迭代的首次为-1</span></span><br><span class="line">        <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span></span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                <span class="comment">//当遇到target为null的Message，说明是同步屏障，则查询异步消息</span></span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                  <span class="comment">//循环遍历找出一条异步消息，当查询到异步消息，则立刻退出循环，然后处理</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                       <span class="comment">//当异步消息触发时间大于当前时间，则设置下一次轮询的超时时长</span></span><br><span class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Got a message.</span></span><br><span class="line">                       <span class="comment">// 获取一条消息，并返回</span></span><br><span class="line">                        mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                       <span class="comment">//设置消息的使用状态，即flags |= FLAG_IN_USE</span></span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        <span class="keyword">return</span> msg;<span class="comment">//成功地获取MessageQueue中的下一条即将要执行的消息</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// No more messages.</span></span><br><span class="line">                   <span class="comment">//没有消息</span></span><br><span class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">               <span class="comment">//消息正在退出，返回null  </span></span><br><span class="line">               <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">                <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">                <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">              <span class="comment">//当消息队列为空，或者是消息队列的第一个消息时间大于当前时间</span></span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                   <span class="comment">//没有idle handlers 需要运行，则循环并等待。</span></span><br><span class="line">                    mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Run the idle handlers.</span></span><br><span class="line">            <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">           <span class="comment">//只有第一次循环时，会运行idle handlers，执行完成后，重置pendingIdleHandlerCount为0.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">                mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler 去掉handler的引用</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    keep = idler.queueIdle();<span class="comment">//idle时执行的方法，获取返回值</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">//idler.queueIdle()返回false时会移除idler，只执行一次</span></span><br><span class="line">                <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">           <span class="comment">//重置idle handler个数为0，以保证不会再次重复运行</span></span><br><span class="line">            pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">            <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">          <span class="comment">//当调用一个空闲handler时，一个新message能够被分发，因此无需等待可以直接查询pending message.</span></span><br><span class="line">            nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>nativePollOnce</code> 是阻塞操作，其中<code>nextPollTimeoutMillis</code>代表下一个消息到来前，还需要等待的时长；当nextPollTimeoutMillis = -1时，表示消息队列中无消息，会一直阻塞等待下去。</p>
<p>当处于空闲时，往往会执行<code>IdleHandler</code>中的方法。当 nativePollOnce() 返回后，next() 从<code>mMessages</code>中提取一个消息。</p>
<p><code>nativePollOnce()</code>在 native 做了大量的工作，想进一步了解可查看 <a href="http://gityuan.com/2015/12/27/handler-message-native/#nativepollonce" target="_blank" rel="noopener">Android消息机制2-Handler(native篇)</a>。</p>
<p><strong>此处用到了Linux的pipe/epoll机制：没有消息时阻塞线程并进入休眠释放cpu资源，有消息时唤醒线程</strong>。</p>
<h5 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h5><p>当线程将要进入堵塞，以等待更多消息时，会回调这个接口，简单点说：当 MessageQueue 中无可处理的Message 时回调。作用：<strong>UI线程处理完所有View事务后，回调一些额外的操作，且不会堵塞主进程；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Callback interface for discovering when a thread is going to block</span></span><br><span class="line"><span class="comment">     * waiting for more messages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Called when the message queue has run out of messages and will now</span></span><br><span class="line"><span class="comment">         * wait for more.  Return true to keep your idle handler active, false</span></span><br><span class="line"><span class="comment">         * to have it removed.  This may be called if there are still messages</span></span><br><span class="line"><span class="comment">         * pending in the queue, but they are all scheduled to be dispatched</span></span><br><span class="line"><span class="comment">         * after the current time.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接口中只有一个 queueIdle() 函数，线程进入堵塞时执行的额外操作可以写这里，返回值是 true 的话，执行完此方法后还会保留这个 IdleHandler，否则删除。</p>
<h5 id="removeMessages"><a href="#removeMessages" class="headerlink" title="removeMessages"></a>removeMessages</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="comment">// Remove all messages at front.</span></span><br><span class="line">           <span class="comment">//从消息队列的头部开始，移除所有符合条件的消息</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what</span><br><span class="line">                   &amp;&amp; (object == <span class="keyword">null</span> || p.obj == object)) &#123;</span><br><span class="line">                Message n = p.next;</span><br><span class="line">                mMessages = n;</span><br><span class="line">                p.recycleUnchecked();</span><br><span class="line">                p = n;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remove all messages after front.</span></span><br><span class="line">           <span class="comment">//移除剩余的符合要求的消息</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message n = p.next;</span><br><span class="line">                <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (n.target == h &amp;&amp; n.what == what</span><br><span class="line">                        &amp;&amp; (object == <span class="keyword">null</span> || n.obj == object)) &#123;</span><br><span class="line">                        Message nn = n.next;</span><br><span class="line">                        n.recycleUnchecked();</span><br><span class="line">                        p.next = nn;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                p = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个移除消息的方法，采用了两个 while 循环，第一个循环是从队头开始，移除符合条件的消息，第二个循环是从头部移除完连续的满足条件的消息之后，再从队列后面继续查询是否有满足条件的消息需要被移除。</p>
<h5 id="同步屏障机制"><a href="#同步屏障机制" class="headerlink" title="同步屏障机制"></a>同步屏障机制</h5><p>我们知道用 Handler 发送的 Message 后，MessageQueue 的 enqueueMessage() 按照 时间戳升序 将消息插入到队列中，而 Looper 则按照顺序，每次取出一枚Message进行分发，一个处理完到下一个。那么当<strong>有一个紧急的Message需要优先处理怎么破？</strong>一个 Message 分发给 Handler 后，执行了耗时操作，后面一堆本该到点执行的Message 在那里等着，这个时候你 sendMessage()，还是得排在这堆 Message 后，等他们执行完，再到你！</p>
<p>于是，Handler 中的 MessageQueue 加入了<strong>同步屏障</strong>这种机制，来实现<strong>异步消息优先执行</strong>的功能。</p>
<p>添加一个异步消息的方法很简单：</p>
<ul>
<li>Handler 构造方法中传入 async 参数，设置为 true，使用此 Handler 添加的 Message 都是异步的；</li>
<li>创建 Message 对象时，直接调用 setAsynchronous(true)</li>
</ul>
<h5 id="postSyncBarrier"><a href="#postSyncBarrier" class="headerlink" title="postSyncBarrier"></a>postSyncBarrier</h5><p>同步消息和异步消息没太大差别，但仅限于开启同步屏障之前。postSyncBarrier 只对同步消息产生影响，对于异步消息没有任何差别。可以通过 MessageQueue 的 postSyncBarrier 函数来开启同步屏障：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往消息队列合适的位置插入了同步屏障类型的Message (target属性为null)</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">       <span class="comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">           <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">           msg.markInUse();</span><br><span class="line">           msg.when = when;</span><br><span class="line">           msg.arg1 = token;<span class="comment">//初始化Msg时target没赋值，为null</span></span><br><span class="line"></span><br><span class="line">           Message prev = <span class="keyword">null</span>;</span><br><span class="line">           Message p = mMessages;</span><br><span class="line">           <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                   prev = p;</span><br><span class="line">                   p = p.next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">               msg.next = p;</span><br><span class="line">               prev.next = msg;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               msg.next = p;</span><br><span class="line">               mMessages = msg;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> token;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>每一个普通 Message 必须有一个 target，对于 target 为 null 的 Message，说明是同步屏障，循环遍历找出一条异步消息，然后处理。 这个消息的价值就是用于拦截同步消息，所以并不会唤醒 Looper。</p>
<h5 id="removeSyncBarrier"><a href="#removeSyncBarrier" class="headerlink" title="removeSyncBarrier"></a>removeSyncBarrier</h5><p>在同步屏障没移除前，只会处理异步消息，处理完所有的异步消息后，就会处于堵塞。如果想恢复处理同步消息，需要调用 removeSyncBarrier() 移除同步屏障：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">        <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            Message prev = <span class="keyword">null</span>;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">          <span class="comment">//从消息队列找到 target为空,并且token相等的Message</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The specified message queue synchronization "</span></span><br><span class="line">                        + <span class="string">" barrier token has not been posted or has already been removed."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = p.next;</span><br><span class="line">                needWake = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mMessages = p.next;</span><br><span class="line">                needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the loop is quitting then it is already awake.</span></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">            <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="五、Message"><a href="#五、Message" class="headerlink" title="五、Message"></a>五、Message</h4><h5 id="消息对象"><a href="#消息对象" class="headerlink" title="消息对象"></a>消息对象</h5><p>每个消息用 Message 表示，Message 主要包含以下内容：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">成员变量</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">what</td>
<td align="left">消息类别</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">when</td>
<td align="left">消息触发时间</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">arg1</td>
<td align="left">参数1</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">arg2</td>
<td align="left">参数2</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">obj</td>
<td align="left">消息内容</td>
</tr>
<tr>
<td align="left">Handler</td>
<td align="left">target</td>
<td align="left">消息响应方</td>
</tr>
<tr>
<td align="left">Runnable</td>
<td align="left">callback</td>
<td align="left">回调方法</td>
</tr>
</tbody></table>
<h5 id="消息池"><a href="#消息池" class="headerlink" title="消息池"></a>消息池</h5><p>静态变量<code>sPool</code>的数据类型为 Message，通过 next 成员变量，维护一个消息池；静态变量<code>MAX_POOL_SIZE</code>代表消息池的可用大小；消息池的默认大小为50。当消息池不为空时，可以直接从消息池中获取 Message 对象，而不是直接创建，提高效率。</p>
<p>消息池常用的操作方法是 obtain() 和 recycle()。</p>
<h5 id="obtain"><a href="#obtain" class="headerlink" title="obtain"></a>obtain</h5><p>从消息池中获取消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment">     * avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="keyword">null</span>;<span class="comment">//从sPool中取出一个Message对象，并消息链表断开</span></span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag 清除in-use flag</span></span><br><span class="line">                sPoolSize--;<span class="comment">//消息池的可用大小进行减1操作</span></span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>obtain()，从消息池取 Message，都是把消息池表头的 Message 取走，再把表头指向 next。</p>
<h5 id="recycle"><a href="#recycle" class="headerlink" title="recycle"></a>recycle</h5><p>把不再使用的消息加入消息池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isInUse()) &#123;<span class="comment">//判断消息是否正在使用</span></span><br><span class="line">            <span class="keyword">if</span> (gCheckRecycle) &#123;<span class="comment">//Android 5.0以后的版本默认为true,之前的版本默认为false.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span></span><br><span class="line">                        + <span class="string">"is still in use."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于不再使用的消息，加入到消息池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">        <span class="comment">// Clear out all other details.</span></span><br><span class="line">       <span class="comment">// 将消息标示位置为FLAG_IN_USE，并清空消息所有的参数，同时将其保留在回收对象池中</span></span><br><span class="line">        flags = FLAG_IN_USE;</span><br><span class="line">        what = <span class="number">0</span>;</span><br><span class="line">        arg1 = <span class="number">0</span>;</span><br><span class="line">        arg2 = <span class="number">0</span>;</span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        replyTo = <span class="keyword">null</span>;</span><br><span class="line">        sendingUid = UID_NONE;</span><br><span class="line">        workSourceUid = UID_NONE;</span><br><span class="line">        when = <span class="number">0</span>;</span><br><span class="line">        target = <span class="keyword">null</span>;</span><br><span class="line">        callback = <span class="keyword">null</span>;</span><br><span class="line">        data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;<span class="comment">//当消息池没有满时，将Message对象加入消息池</span></span><br><span class="line">                next = sPool;</span><br><span class="line">                sPool = <span class="keyword">this</span>;</span><br><span class="line">                sPoolSize++;<span class="comment">//消息池的可用大小进行加1操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>recycle()，将 Message 加入到消息池的过程，会把消息标示位置为 FLAG_IN_USE，并清空消息所有的参数，都是把 Message 加到链表的表头。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Handler 消息机制：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghndj328rcj30p20fatah.jpg" alt=""></p>
<ul>
<li>Handler 通过 sendMessage() 发送 Message 到 MessageQueue 队列；</li>
<li>Looper 通过 loop()，不断提取出达到触发条件的 Message，并将 Message 交给 target 来处理；</li>
<li>经过 dispatchMessage() 后，交回给 Handler 的 handleMessage() 来进行相应地处理。</li>
<li>将 Message 加入 MessageQueue 时，往管道写入字符，可以会唤醒 loop 线程；如果 MessageQueue 中没有 Message，并处于 Idle 状态，则会执行 IdelHandler 接口中的方法，往往用于做一些清理性地工作。</li>
</ul>
<p><strong>Handler：</strong></p>
<p>内部实现主要涉及到如下几个类：Thread、MessageQueue 和 Looper，它们之间的关系：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghp0auiuk8j309r06qglm.jpg" alt=""></p>
<p>Thread 是最基础的，Looper 和 MessageQueue 都构建在 Thread 之上，Handler 又构建在 Looper 和 MessageQueue 之上，我们通过 Handler 间接地与下面这几个相对底层一点的类打交道。</p>
<p>Handler 创建的时候会采用当前线程的 Looper 来构造消息循环系统，<strong>Looper 在哪个线程创建，就跟哪个线程绑定</strong>，并且 <strong>Handler 处理消息是在它关联的 Looper 对应的线程中</strong>。</p>
<p><strong>消息分发的优先级：</strong></p>
<ol>
<li>Message 的回调方法：<code>message.callback.run()</code>，优先级最高；</li>
<li>Handler.Callback 的回调方法：<code>Handler.mCallback.handleMessage(msg)</code>，返回 true 时不会轮到步骤3，优先级仅次于1；</li>
<li>Handler 自身的默认方法：<code>Handler.handleMessage(msg)</code>，优先级最低。</li>
</ol>
<p><strong>消息缓存：</strong></p>
<p>为了提供效率，提供了一个大小为50的 Message 缓存队列，减少对象不断创建与销毁的过程。</p>
<p>引用文章：</p>
<blockquote>
<p><a href="http://blog.csdn.net/iispring/article/details/47180325" target="_blank" rel="noopener">深入源码解析Handler</a><br><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="noopener">Gityuan–消息机制Handler</a></p>
<p><a href="https://mp.weixin.qq.com/s/vCnftbD3z07X79gHj30Kiw" target="_blank" rel="noopener">关于Handler 的这 15 个问题，你都清楚吗？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler常见面试题</title>
    <url>/2020/08/12/Handler%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Handler机制是面试官非常喜欢问的知识点，本文主要是记录整理Handler相关面试题和解答。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h5 id="1、Handler：是什么？有什么用？为什么要用Handler，不用行不行？"><a href="#1、Handler：是什么？有什么用？为什么要用Handler，不用行不行？" class="headerlink" title="1、Handler：是什么？有什么用？为什么要用Handler，不用行不行？"></a>1、Handler：是什么？有什么用？为什么要用Handler，不用行不行？</h5><p>Android定义的一套 线程(子线程与主线程)间通讯的消息传递机制 。把子线程中的 UI更新信息，传递给主线程(UI线程)，以此完成UI更新操作。Android建议要求：我们在主线程(UI)线程中更新UI。Android的UI控件不是<strong>线程安全</strong>的，用Handler在多个线程并发更新UI的同时，保证线程的安全。</p>
<a id="more"></a>

<h5 id="2、真的只能在主-UI-线程中更新UI吗？子线程一定不能更新UI吗？"><a href="#2、真的只能在主-UI-线程中更新UI吗？子线程一定不能更新UI吗？" class="headerlink" title="2、真的只能在主(UI)线程中更新UI吗？子线程一定不能更新UI吗？"></a>2、真的只能在主(UI)线程中更新UI吗？子线程一定不能更新UI吗？</h5><p><strong>并不是的</strong>，子线程更新UI也行，但是只能更新自己创建的View！只有创建这个view的线程才能操作这个view，但不建议在子线程更新UI。Android的UI更新被设计成了单线程。ViewRootImp 在 onCreate() 时还没创建；在 onResume()时，即ActivityThread 的 handleResumeActivity() 执行后才创建，调用 requestLayout()，走到 checkThread() 时就报错了。</p>
<h5 id="3、真的不能在主-UI-线程中执行网络操作吗？"><a href="#3、真的不能在主-UI-线程中执行网络操作吗？" class="headerlink" title="3、真的不能在主(UI)线程中执行网络操作吗？"></a>3、真的不能在主(UI)线程中执行网络操作吗？</h5><p>把 StrictMode 的网络检测关了，就可以在主线程中执行网络操作了，不过一般是不建议这样做的。</p>
<h5 id="4、谈谈消息机制Handler作用-？有哪些要素-？流程是怎样的-？"><a href="#4、谈谈消息机制Handler作用-？有哪些要素-？流程是怎样的-？" class="headerlink" title="4、谈谈消息机制Handler作用 ？有哪些要素 ？流程是怎样的 ？"></a>4、谈谈消息机制Handler作用 ？有哪些要素 ？流程是怎样的 ？</h5><p>作用：负责<strong>线程间通信</strong>，这是因为<strong>在主线程不能做耗时操作，而子线程不能更新UI</strong></p>
<p>四大要素：</p>
<p><strong>Message</strong>：需要被传递的消息，消息分为硬件产生的消息（如按钮、触摸）和软件生成的消息。</p>
<p><strong>MessageQueue</strong>：负责消息的存储与管理，负责管理由 Handler发送过来的Message。</p>
<p><strong>Handler</strong>：负责Message的发送及处理。主要向消息池发送各种消息事件（Handler.sendMessage()）和处理相应消息事件（Handler.handleMessage()）。</p>
<p><strong>Looper</strong>：负责关联线程以及消息的分发，在该线程下从 MessageQueue获取 Message，分发给Handler，Looper创建的时候会创建一个 MessageQueue，调用loop()方法的时候消息循环开始，其中会不断调用messageQueue的next()方法，当有消息就处理，否则阻塞在messageQueue的next()方法中。当Looper的quit()被调用的时候会调用messageQueue的quit()，此时next()会返回null，然后loop()方法也就跟着退出。</p>
<p>具体流程：</p>
<p>在主线程创建的时候会创建一个Looper，同时也会在在Looper内部创建一个消息队列。而在创键Handler的时候取出当前线程的Looper，并通过该Looper对象获得消息队列，然后Handler在子线程中通过<strong>MessageQueue.enqueueMessage</strong>在消息队列中添加一条Message。</p>
<p>通过<strong>Looper.loop()</strong> 开启消息循环不断轮询调用 <strong>MessageQueue.next()</strong>，取得对应的Message并且通过<strong>Handler.dispatchMessage</strong>传递给Handler，最终调用<strong>Handler.handlerMessage</strong>处理消息。</p>
<h5 id="5、一个线程能否创建多个Handler，Handler跟Looper之间的对应关系-？"><a href="#5、一个线程能否创建多个Handler，Handler跟Looper之间的对应关系-？" class="headerlink" title="5、一个线程能否创建多个Handler，Handler跟Looper之间的对应关系 ？"></a>5、一个线程能否创建多个Handler，Handler跟Looper之间的对应关系 ？</h5><ul>
<li>一个Thread可以有多个Handler，但只能有一个Looper，一个MessageQueue。</li>
<li>以一个线程为基准，他们的数量级关系是： Thread(1) : Looper(1) : MessageQueue(1) : Handler(N)</li>
</ul>
<p>看Looper的创建，是在prepare()方法里。在创建之前去判断looper是否存在，存在就会抛出<code>Only one Looper may be created per thread</code>异常，这是在告诉我们一个线程只能有一个Looper。而TreadLocal的作用就是线程间隔离，确保一个线程对应一个Looper。然后在Looper构造方法中，初始化了一个MessageQueue。所以不管一个线程有多少个Handler，它们相关联的都是同一个Looper和MessageQueue。</p>
<h5 id="6、Message可以如何创建？哪种效果更好，为什么？"><a href="#6、Message可以如何创建？哪种效果更好，为什么？" class="headerlink" title="6、Message可以如何创建？哪种效果更好，为什么？"></a>6、Message可以如何创建？哪种效果更好，为什么？</h5><ul>
<li>直接生成实例<code>Message m = new Message()</code></li>
<li>通过<code>Message m = Message.obtain()</code></li>
<li>通过<code>Message m = mHandler.obtainMessage()</code></li>
</ul>
<p>建议使用后两者效果更好，默认的消息池中消息数量是50，后两者是直接在消息池中取出一个Message实例，这样做就可以避免多生成Message实例。</p>
<h5 id="7、为什么子线程中不可以直接new-Handler-而主线程中可以？"><a href="#7、为什么子线程中不可以直接new-Handler-而主线程中可以？" class="headerlink" title="7、为什么子线程中不可以直接new Handler()而主线程中可以？"></a>7、为什么子线程中不可以直接new Handler()而主线程中可以？</h5><p>因为在主线程启动时，主线程的Looper在ActivityThread中就通过prepareMainLooper() 完成了初始化。而子线程还需要调用手动调用 Looper.prepare()初始化Looper 和 Looper.loop()开启轮询。所以要在子线程创建Handler要先创建Looper，并开启Looper循环。主线程与子线程不共享同一个Looper实例。</p>
<h5 id="8、主线程给子线程的Handler发送消息怎么写？"><a href="#8、主线程给子线程的Handler发送消息怎么写？" class="headerlink" title="8、主线程给子线程的Handler发送消息怎么写？"></a>8、主线程给子线程的Handler发送消息怎么写？</h5><p>多线程并发的问题，当主线程执行到 sendEnptyMessage 时，子线程的 Handler 可能还没有创建，解决方法是：<strong>主线程延时给子线程发消息</strong>或者<strong>使用 HandlerThread 异步类</strong>。HandlerThread提供了主线程向子线程的通信。</p>
<h5 id="9、HandlerThread实现的核心原理？"><a href="#9、HandlerThread实现的核心原理？" class="headerlink" title="9、HandlerThread实现的核心原理？"></a>9、HandlerThread实现的核心原理？</h5><p><strong>HandlerThread = 继承Thread + 封装Looper + Handler</strong></p>
<p>源码分析：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghogfu4j9xj30hu08dt9j.jpg" alt=""></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghoggpff6kj30c1067jsa.jpg" alt=""></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghoghg7a2qj30jz0b5jsy.jpg" alt=""></p>
<p>HandlerThread的核心原理就是：</p>
<ul>
<li>继承Thread，getLooper()加锁死循环wait()堵塞；</li>
<li>run()加锁等待Looper对象创建成功，notifyAll()唤醒；</li>
<li>唤醒后，getLooper返回由run()中生成的Looper对象；</li>
</ul>
<p>总结：</p>
<ul>
<li><p>HandlerThread本质上是一个线程类，它继承了Thread。</p>
</li>
<li><p>HandlerThread有自己内部的Looper对象，可以进行Looper循环。</p>
</li>
<li><p>通过获取HandlerThread的Looper对象传递给Handler对象，可以在handlerMessage方法中执行异步任务。</p>
</li>
<li><p>优点是不会有堵塞，多次创建和销毁子线程是很耗费资源的，减少对性能的消耗，缺点是不能进行多任务的处理，需要等待进行处理，处理效率较低。</p>
</li>
<li><p>与线程池注重并发不同，HandlerThread是一个串行队列，HandlerThread背后只有一个线程。</p>
</li>
<li><p>在 HandlerThread 不使用的时候，需要调用退出方法<code>quit()/quitSafely()</code>，停止Looper。</p>
</li>
</ul>
<h5 id="10、Looper是怎么拣队列里的消息的？"><a href="#10、Looper是怎么拣队列里的消息的？" class="headerlink" title="10、Looper是怎么拣队列里的消息的？"></a>10、Looper是怎么拣队列里的消息的？</h5><p>由 Looper -&gt; loop函数-&gt;MessageQueue -&gt; next函数：</p>
<p>关键其实就是：nextPollTimeoutMillis，决定了堵塞与否，以及堵塞的时间，三种情况：</p>
<ol>
<li>等于0时，不堵塞，立即返回，Looper第一次处理消息，有一个消息处理完 ；</li>
<li>大于0时，最长堵塞等待时间，期间有新消息进来，可能会了立即返回(立即执行)；</li>
<li>等于-1时，无消息时，会一直堵塞；</li>
</ol>
<p><strong>此处用到了Linux的pipe/epoll机制：没有消息时阻塞线程并进入休眠释放cpu资源，有消息时唤醒线程；</strong></p>
<h5 id="11、分发给Handler的消息是怎么处理的？"><a href="#11、分发给Handler的消息是怎么处理的？" class="headerlink" title="11、分发给Handler的消息是怎么处理的？"></a>11、分发给Handler的消息是怎么处理的？</h5><p>通过MessageQueue的queue.next()拣出消息后，调用<code>msg.target.dispatchMessage(msg)</code><br>把消息分发给对应的Handler，调用 <code>dispatchMessage()</code> 方法。</p>
<p>回调优先级：</p>
<ol>
<li>Message 的回调方法：<code>message.callback.run()</code>，优先级最高；</li>
<li>Handler.Callback 的回调方法：<code>Handler.mCallback.handleMessage(msg)</code>，返回 true 时不会轮到步骤3，优先级仅次于1；</li>
<li>Handler 自身的默认方法：<code>Handler.handleMessage(msg)</code>，优先级最低。</li>
</ol>
<h5 id="12、IdleHandler是什么？"><a href="#12、IdleHandler是什么？" class="headerlink" title="12、IdleHandler是什么？"></a>12、IdleHandler是什么？</h5><p>在 MessageQueue 类中有一个 static 的接口 IdleHanlder。当线程将要进入堵塞，以等待更多消息时，会回调这个接口；简单点说：当MessageQueue中无可处理的Message时回调。</p>
<p>作用：<strong>UI线程处理完所有View事务后，回调一些额外的操作，且不会堵塞主进程；</strong></p>
<p>接口中只有一个 queueIdle() 函数，线程进入堵塞时执行的额外操作可以写这里，返回值是true的话，执行完此方法后还会保留这个IdleHandler，否则删除。使用方法：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gho6gn418dj30aq03mweo.jpg" alt=""></p>
<h5 id="13、Looper在主线程中死循环，为啥不会ANR？"><a href="#13、Looper在主线程中死循环，为啥不会ANR？" class="headerlink" title="13、Looper在主线程中死循环，为啥不会ANR？"></a>13、Looper在主线程中死循环，为啥不会ANR？</h5><ol>
<li><p>主线程的主要方法就是<strong>消息循环</strong>，一旦退出消息循环，那么你的应用也就退出了，Looer.loop() 方法可能会引起主线程的阻塞，但只要它的<strong>消息循环没有被阻塞</strong>，能一直处理事件就不会产生ANR异常。</p>
</li>
<li><p>造成<strong>ANR</strong>的不是主线程阻塞，而是主线程的Looper消息处理过程发生了<strong>任务阻塞</strong>，无法响应手势操作，不能及时刷新UI。</p>
</li>
<li><p><strong>阻塞与程序无响应</strong>没有必然关系，虽然主线程在没有消息可处理的时候是阻塞的，但是只要保证有消息的时候能够立刻处理，程序是不会无响应的。</p>
</li>
<li><p>真正会卡死主线程的操作是在回调方法onCreate/onStart/onResume等操作时间过长，会导致掉帧，甚至发生ANR，Looper.loop() 本身不会导致应用卡死。</p>
</li>
<li><p>Looper通过queue.next()获取消息队列消息，当队列为空，会堵塞，此时主线程也堵塞在这里，好处是：main函数无法退出，APP不会一启动就结束！</p>
<p>application启动时，可不止一个main线程，还有其他两个Binder线程：<strong>ApplicationThread</strong> 和 <strong>ActivityManagerProxy</strong>，用来和系统进程进行通信操作，接收系统进程发送的通知。</p>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gho6y2oscoj30ei094jtf.jpg" alt=""></p>
<ul>
<li><p>当系统受到因用户操作产生的通知时，会通过 Binder 方式跨进程通知 ApplicationThread;</p>
</li>
<li><p>它通过Handler机制，往 ActivityThread 的 MessageQueue 中插入消息，唤醒了主线程；</p>
</li>
<li><p>queue.next() 能拿到消息了,然后 dispatchMessage 完成事件分发。</p>
<p>死循环不会ANR，但是 dispatchMessage 中又可能会ANR哦！如果你在此执行一些耗时操作，导致这个消息一直没处理完，后面又接收到了很多消息，堆积太多，从而引起ANR异常。</p>
</li>
</ul>
<h5 id="14、主线程的死循环一直运行是不是特别消耗CPU资源呢？"><a href="#14、主线程的死循环一直运行是不是特别消耗CPU资源呢？" class="headerlink" title="14、主线程的死循环一直运行是不是特别消耗CPU资源呢？"></a>14、主线程的死循环一直运行是不是特别消耗CPU资源呢？</h5><p>其实不然，这里就涉及到Linux pipe/epoll机制，简单说就是在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。 </p>
<h5 id="15、Handler导致内存泄露的原因及正确写法"><a href="#15、Handler导致内存泄露的原因及正确写法" class="headerlink" title="15、Handler导致内存泄露的原因及正确写法"></a>15、Handler导致内存泄露的原因及正确写法</h5><p>泄露原因：</p>
<p><strong>当Handler消息队列还有未处理的消息 或 正在处理消息而外部类需要销毁时，将使得外部类无法被垃圾回收器GC回收，从而造成内存泄露</strong>。</p>
<p>当Handler消息队列还有未处理的消息 / 正在处理消息，而外部类需销毁时，<strong>存在引用关系</strong>： <strong>“未被处理 / 正处理的消息Message -&gt; Handler实例 -&gt; 外部类Activity实例”</strong>，将使得外部类无法被垃圾回收器GC回收，从而造成内存泄露。</p>
<p>Handler 允许我们发送延时消息，如果在延时期间用户关闭了 Activity，那么该 Activity 无法被GC导致泄露。是因为 Message 会持有 Handler，由于 Java 的特性，非静态内部类 / 匿名内部类会持有外部类，使得 Activity 会被 Handler 持有，这样最终就导致 Activity 泄露。在Java中，非静态内部类 / 匿名内部类会持有一个外部类的隐式引用，可能会造成外部类无法被GC。</p>
<p>解决方案有两种：</p>
<ul>
<li><p>1.<strong>静态内部类+弱引用</strong></p>
<p>静态内部类默认不持有外部类的引用，<strong>将 Handler 定义成静态内部类，在内部持有Activity的弱引用</strong>。而单单使用静态内部类，Handler就不能调用Activity里的非静态方法了，所以加上弱引用持有外部Activity。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个弱引用持有外部类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;MainActivity&gt; context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyHandler</span><span class="params">(MainActivity context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = <span class="keyword">new</span> WeakReference&lt;MainActivity&gt;(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        MainActivity activity = context.get();</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                    activity.notifyUI();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>2.<strong>当外部类结束生命周期时，清空Handler内消息队列的消息</strong></p>
<p>在Acitivity的onDestroy()中调用<strong>handler.removeCallbacksAndMessages(null)</strong>移除所有消息。使得 Handler 的生命周期(即消息存在的时期)与外部类的生命周期同步。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 外部类Activity生命周期结束时，同时清空消息队列 &amp; 结束Handler生命周期</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用建议：为了保证Handler中消息队列中的所有消息都能被执行，推荐使用解决方案1解决内存泄露问题，即 <strong>静态内部类 + 弱引用的方式</strong></p>
<h5 id="16、Handler中的同步屏障机制"><a href="#16、Handler中的同步屏障机制" class="headerlink" title="16、Handler中的同步屏障机制"></a>16、Handler中的同步屏障机制</h5><p>我们知道用Handler发送的Message后，MessageQueue的enqueueMessage()按照 时间戳升序 将消息插入到队列中，而Looper则按照顺序，每次取出一枚Message进行分发，一个处理完到下一个。</p>
<p><strong>这时候，问题来了：有一个紧急的Message需要优先处理怎么破？</strong></p>
<p>Handler中加入了「同步屏障」这种机制，来实现「异步消息优先执行」的功能。</p>
<p>添加一个异步消息的方法很简单：</p>
<p>1、Handler构造方法中传入async参数，设置为true，使用此Handler添加的Message都是异步的；</p>
<p>2、创建Message对象时，直接调用setAsynchronous(true)</p>
<p>可以通过 MessageQueue 的 postSyncBarrier 函数来开启同步屏障：往消息队列合适的位置插入了同步屏障类型的Message (target属性为null)，接着，在 MessageQueue 执行到 next() 函数时：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwOPb5hszoy7LYnoN5FKueEqsPG4gXiawQtIibMg4JqZL9O3mGKwTvjrSvT25IiaRAf7DWd9NtbhsSJTA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<p>遇到target为null的Message，说明是同步屏障，循环遍历找出一条异步消息，然后处理。</p>
<p>在同步屏障没移除前，只会处理异步消息，处理完所有的异步消息后，就会处于堵塞。如果想恢复处理同步消息，需要调用 removeSyncBarrier() 移除同步屏障。</p>
<p>在API 28的版本中，postSyncBarrier()已被标注hide，但在系统源码可找到相关应用，为了更快地响应UI刷新事件，在ViewRootImpl的scheduleTraversals函数中就用到了同步屏障：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gho7zziasxj30g5063wf2.jpg" alt=""></p>
<h5 id="17、当Activity有多个Handler的时候，Message消息是否会混乱？怎么样区分当前消息由哪个Handler处理？"><a href="#17、当Activity有多个Handler的时候，Message消息是否会混乱？怎么样区分当前消息由哪个Handler处理？" class="headerlink" title="17、当Activity有多个Handler的时候，Message消息是否会混乱？怎么样区分当前消息由哪个Handler处理？"></a>17、当Activity有多个Handler的时候，Message消息是否会混乱？怎么样区分当前消息由哪个Handler处理？</h5><p>不会混乱，哪个Handler发送的消息，到时候也是这个handler处理。在发送消息的时候，msg会绑定target，这个target就是Handler本身，在循环取出消息时会调用<code>msg.target.dispatchMessage(msg)</code>分发处理消息，这里的target就是当时发送消息绑定的 handler 。</p>
<h5 id="18、在子线程发送消息，却能够在主线程接收消息，主线程和子线程是怎么样切换的？"><a href="#18、在子线程发送消息，却能够在主线程接收消息，主线程和子线程是怎么样切换的？" class="headerlink" title="18、在子线程发送消息，却能够在主线程接收消息，主线程和子线程是怎么样切换的？"></a>18、在子线程发送消息，却能够在主线程接收消息，主线程和子线程是怎么样切换的？</h5><p>在子线程中用主线程 handler 发送消息，发送的消息被送到与主线程相关联的MessageQueue，也是主线程相关联的Looper在循环消息，handler所关联的是主线程的Looper和MessageQueue，所以最后消息的处理逻辑也是在主线程。只有发送消息是在子线程，其他都是在主线程。Handler与哪个线程的Looper相关联，消息处理逻辑就在与之关联的线程中执行，相应的消息的走向也就在相关联的MessageQueue中。所以子线程切换到主线程是很自然的过程，并没有想象中的复杂。</p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/vCnftbD3z07X79gHj30Kiw" target="_blank" rel="noopener">关于Handler 的这 15 个问题，你都清楚吗？</a></p>
<p><a href="https://blog.csdn.net/qian520ao/article/details/78262289#4-handler-是如何能够线程切换" target="_blank" rel="noopener">Android 消息机制——你真的了解Handler？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>HandlerThread源码分析</title>
    <url>/2020/08/04/HandlerThread%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android中的HandlerThread。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、HandlerThread是什么"><a href="#一、HandlerThread是什么" class="headerlink" title="一、HandlerThread是什么?"></a>一、HandlerThread是什么?</h4><p>HandlerThread 是 Android 已封装好的轻量级异步通信类。官方介绍：</p>
<blockquote>
<p>A <code>Thread</code> that has a <code>Looper</code>. The <code>Looper</code> can then be used to create <code>Handler</code>s.</p>
<p>Note that just like with a regular <code>Thread</code>, <code>Thread.start()</code> must still be called.</p>
</blockquote>
<p>一个具有 Looper 的线程。该 Looper 可以用来创建 Handler。就像使用常规线程一样，<code>Thread.start()</code> 仍必须调用。</p>
<a id="more"></a>

<p><strong>产生背景</strong>：我们知道，耗时任务需要在子线程中进行，而线程的创建和销毁是非常消耗系统资源的，如果当任务 A 执行完了后，如果还需要执行任务 B， 那么就还需要创建一个新的子线程进行。这样性能问题就会凸显。为此，可以子线程中创建一个轮询器 Looper，当有新任务时，Looper 就开启并处理，否则就阻塞，直到下一个耗时任务的到来。因此，HandlerThread 内部封装了 Handler 和 Looper ，<strong>可以避免多次创建和销毁线程带来的性能问题</strong>。</p>
<p><strong>本质</strong>：HandlerThread 是一个线程，它继承自 Thread。内部封装了 Handler 和 Looper 来进行消息的分发、循环以及处理。<strong>通过继承Thread类</strong>和<strong>封装Handler类的使用</strong>，从而使得<strong>创建新线程和与其他线程进行通信</strong>变得更加方便易用。</p>
<p><strong>作用</strong>：实现多线程，在工作线程中执行任务，如耗时任务；实现异步通信、消息传递，实现工作线程和主线程(UI线程)之间的通信，即：将工作线程的执行结果传递给主线程，从而在主线程中执行相关的UI操作。</p>
<h4 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：创建HandlerThread实例对象</span></span><br><span class="line"><span class="comment">// 传入参数 = 线程名字，作用 = 标记该线程</span></span><br><span class="line">   HandlerThread mHandlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"handlerThread"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：启动线程</span></span><br><span class="line">   mHandlerThread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：创建工作线程Handler &amp; 复写handleMessage（）</span></span><br><span class="line"><span class="comment">// 作用：关联HandlerThread的Looper对象、实现消息处理操作 &amp; 与其他线程进行通信</span></span><br><span class="line"><span class="comment">// 注：消息处理操作handleMessage()的执行线程 = mHandlerThread所创建的工作线程中执行</span></span><br><span class="line">  Handler workHandler = <span class="keyword">new</span> Handler( handlerThread.getLooper() ) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                ...<span class="comment">//消息处理，通知主线程等</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤4：使用工作线程Handler向工作线程的消息队列发送消息</span></span><br><span class="line"><span class="comment">// 在工作线程中，当消息循环时取出对应消息 &amp; 在工作线程执行相关操作</span></span><br><span class="line">  <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">  Message msg = Message.obtain();</span><br><span class="line">  msg.what = <span class="number">2</span>; <span class="comment">//消息的标识</span></span><br><span class="line">  msg.obj = <span class="string">"B"</span>; <span class="comment">// 消息的存放</span></span><br><span class="line">  <span class="comment">// b. 通过Handler发送消息到其绑定的消息队列</span></span><br><span class="line">  workHandler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤5：结束线程，即停止线程的消息循环</span></span><br><span class="line">  mHandlerThread.quit();</span><br></pre></td></tr></table></figure>

<h4 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入线程名，默认优先级</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">super</span>(name);</span><br><span class="line">    mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义设置优先级</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a HandlerThread.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priority The priority to run the thread at. The value supplied must be from </span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> android.os.Process&#125; and not from java.lang.Thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    mPriority = priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>HandlerThread</code>类继承自<code>Thread</code>类；</li>
<li>创建<code>HandlerThread</code>类对象 = 创建<code>Thread</code>类对象 + 设置线程优先级 = <strong>新开1个工作线程 + 设置线程优先级</strong>。</li>
</ul>
<h5 id="run"><a href="#run" class="headerlink" title="run"></a>run</h5><p>启动线程，<code>mHandlerThread.start()</code>最终会回调 HandlerThread 的 run() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mTid = Process.myTid();</span><br><span class="line">  Looper.prepare(); <span class="comment">//为当前线程创建Looper对象</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//同步代码块</span></span><br><span class="line">  	mLooper = Looper.myLooper();<span class="comment">//获取Looper对象</span></span><br><span class="line">    <span class="comment">//阻塞--等待机制</span></span><br><span class="line">    <span class="comment">//发出通知，当前线程已经创建mLooper对象成功，这里主要是通知getLooper()中的等待锁wait()，结束阻塞等待</span></span><br><span class="line">    notifyAll();</span><br><span class="line">    <span class="comment">//此处使用持有锁机制 + notifyAll() 是为了保证后面获得Looper对象前就已创建好Looper对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  Process.setThreadPriority(mPriority);<span class="comment">//设置当前线程的优先级</span></span><br><span class="line">  onLooperPrepared();<span class="comment">//在线程循环消息之前做一些准备工作</span></span><br><span class="line">  Looper.loop(); <span class="comment">//开启循环，Handler从消息队列中处理消息</span></span><br><span class="line">  mTid = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为当前工作线程（即步骤1创建的线程）创建1个<code>Looper</code>对象 &amp; <code>MessageQueue</code>对象；</p>
</li>
<li><p>通过持有锁机制来获得当前线程的<code>Looper</code>对象；</p>
</li>
<li><p>发出通知：当前线程已经创建 mLooper 对象成功；</p>
</li>
<li><p>工作线程进行消息循环，即不断从 MessageQueue 中取消息 &amp; 派发消息。</p>
</li>
</ul>
<h5 id="onLooperPrepared"><a href="#onLooperPrepared" class="headerlink" title="onLooperPrepared"></a>onLooperPrepared</h5><p>重写该方法，可在 Looper 创建完成之后，开始循环消息之前可做一些准备工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Call back method that can be explicitly overridden if needed to execute some</span></span><br><span class="line"><span class="comment">    * setup before Looper loops.</span></span><br><span class="line"><span class="comment">    * 重写该方法，可在循环消息之前可做一些准备工作，在Loop.loop()方法之前调用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="getLooper"><a href="#getLooper" class="headerlink" title="getLooper"></a>getLooper</h5><p>获得当前 HandlerThread 线程中的 Looper 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method returns the Looper associated with this thread. If this thread not been started</span></span><br><span class="line"><span class="comment">     * or for any reason isAlive() returns false, this method will return null. If this thread</span></span><br><span class="line"><span class="comment">     * has been started, this method will block until the looper has been initialized.  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The looper.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 若线程不是存活的，则直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">      <span class="comment">//同步代码块：如果线程已经启动，但是Looper还未创建的话，就阻塞等待，直到run()中的Looper对象创建成功</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//阻塞-等待机制，确保已经创建了mLooper对象</span></span><br><span class="line">            <span class="comment">//开始循环等待，调用wait()去阻塞线程，</span></span><br><span class="line">            <span class="comment">//当run()中的notifyAll()调用之后，通知当前线程的wait方法结束等待，跳出循环。</span></span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();<span class="comment">//阻塞线程，等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待唤醒后，结束等待，跳出循环，返回在run()中创建的mLooper对象</span></span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在获得<code>HandlerThread</code>工作线程的<code>Looper</code>对象时存在一个同步的问题：只有当线程创建成功 &amp; 其对应的<code>Looper</code>对象也创建成功后才能获得<code>Looper</code>的值，才能将创建的<code>Handler</code> 与 工作线程的<code>Looper</code>对象绑定，从而将<code>Handler</code>绑定工作线程。</p>
</li>
<li><p>解决方案：即保证同步的解决方案 = 同步锁、<code>wait（）</code> 和 <code>notifyAll（）</code>，即 在<code>run()</code>中成功创建<code>Looper</code>对象后，立即调用<code>notifyAll（）</code>通知 <code>getLooper()</code>中的<code>wait（）</code>结束等待 &amp; 返回<code>run()</code>中成功创建的<code>Looper</code>对象，使得<code>Handler</code>与该<code>Looper</code>对象绑定。</p>
</li>
</ul>
<h5 id="quit-quitSafely"><a href="#quit-quitSafely" class="headerlink" title="quit/quitSafely"></a>quit/quitSafely</h5><p>在 HandlerThread 不使用的时候，需要调用退出方法<code>quit()/quitSafely()</code>，结束线程，即停止线程的消息循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Looper looper = getLooper();</span><br><span class="line">       <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">           looper.quit();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Looper looper = getLooper();</span><br><span class="line">       <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">           looper.quitSafely();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HandlerThread 本质是一个线程类，继承自 Thread；</li>
<li>HandlerThread 有自己的内部 Looper 对象，可以进行 Looper 循环；</li>
<li>通过获取 HandlerThread 的 Looper 对象传递给 Handler，可以在 <code>handlerMessage()</code>中执行异步任务；</li>
<li>优点是减少了对性能的消耗，缺点是不能同时进行多任务的处理，需要等待处理，效率较低；</li>
<li>与线程池注重并发不同，HandlerThread 是一个串行队列，HandlerThread 背后已只有一个线程；</li>
<li>在 HandlerThread 不使用的时候，需要调用退出方法<code>quit()/quitSafely()</code>。</li>
</ul>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/4a8dc2f50ae6" target="_blank" rel="noopener">Android多线程：这是一份详细的HandlerThread源码分析攻略</a></p>
<p><a href="https://blog.csdn.net/hust_twj/article/details/87884318?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">Android消息机制之HandlerThread</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>IntentService源码分析</title>
    <url>/2020/08/06/IntentService%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android中的IntentService。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、IntentService是什么？"><a href="#一、IntentService是什么？" class="headerlink" title="一、IntentService是什么？"></a>一、IntentService是什么？</h4><p>IntentService 是 Android 里的一个封装的抽象类，继承自 Service。官方介绍：</p>
<blockquote>
<p>IntentService is a base class for <code>Service</code>s that handle asynchronous requests (expressed as <code>Intent</code>s) on demand. Clients send requests through <code>Context.startService(Intent)</code> calls; the service is started as needed, handles each Intent in turn using a worker thread, and stops itself when it runs out of work.</p>
</blockquote>
<p>IntentService 是处理异步请求服务的基类。客户端通过调用 Context.startService(Intent)发送请求，服务会使用一个工作线程依次处理每个意图，并在用完工作时自动停止。</p>
<p><strong>产生背景</strong>：如果想要在 Service 中做些耗时的操作，需要开启一个子线程然后内部执行耗时的操作，在执行完毕后如果需要自动停止服务需要在子线程的 run 方法中调用 stopSelf() 来停止服务，IntentService 类可以很方便的解决了自己开启线程和手动停止服务的问题，适合需要在工作线程处理 UI 无关任务的场景。</p>
<p><strong>本质</strong>：可以看做是 Service 和 HandlerThread 的结合体，封装了一个 HandlerThread 和 Handler 的异步框架，在完成了任务之后会自动停止。</p>
<p><strong>作用</strong>：处理异步请求和实现多线程。</p>
<h4 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h4><p>IntentService 是一个抽象类内部有一个抽象的方法 <code>onHandleIntent()</code>，继承至 Service 类。所以使用它需要继承它实现抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyIntentService"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">"MyIntentService"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//在这里通过intent携带的数据，开进行任务的操作。</span></span><br><span class="line">      Log.d(TAG, <span class="string">"onHandleIntent: "</span> + Thread.currentThread().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onDestroy();</span><br><span class="line">      Log.d(TAG, <span class="string">"onDestroy: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用 StartService() 启动异步后台服务类 IntentService。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">startService.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, MyIntentService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            startService(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h4><h5 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate"></a>onCreate</h5><p>方法会开启一个新的子线程 HandlerThread ( HandlerThread 内部封装了 Looper )，然后创建一个 ServiceHandler 与子线程中的 Looper 对象绑定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 通过实例化andlerThread新建线程 &amp; 启动；故 使用IntentService时，不需额外新建线程</span></span><br><span class="line">    <span class="comment">// HandlerThread继承自Thread，内部封装了 Looper</span></span><br><span class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2. 获得工作线程的 Looper &amp; 维护自己的工作队列</span></span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 新建mServiceHandler &amp; 绑定上述获得Looper</span></span><br><span class="line">    <span class="comment">// 新建的Handler 属于工作线程 -&gt;&gt;分析1</span></span><br><span class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 分析1：ServiceHandler源码分析</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 构造函数</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>(looper);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// IntentService的handleMessage（）把接收的消息交给onHandleIntent()处理</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// onHandleIntent 方法在工作线程中执行</span></span><br><span class="line">          <span class="comment">// onHandleIntent() = 抽象方法，使用时需重写 -&gt;&gt;分析2</span></span><br><span class="line">          onHandleIntent((Intent)msg.obj);</span><br><span class="line">          <span class="comment">// 执行完调用 stopSelf(startId) 结束服务</span></span><br><span class="line">          stopSelf(msg.arg1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 分析2： onHandleIntent()源码分析</span></span><br><span class="line"><span class="comment">     * onHandleIntent() = 抽象方法，使用时需重写</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">      <span class="meta">@WorkerThread</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="onStartCommand"><a href="#onStartCommand" class="headerlink" title="onStartCommand"></a>onStartCommand</h5><p>将 Intent 传递给 ServiceHandler 并依次插入到工作队列中，在方法中调用<code>onStart()</code>构建一个 Message 对象，并且将传递进来的 Intent 封装在 Message，通过 mServiceHandler 发送到消息队列中。经过 Looper 循环将消息分发到 ServiceHandler 的 handleMessage 中处理，从而传递给 <code>onHandleIntent()</code> 方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * onStartCommand（）源码分析</span></span><br><span class="line"><span class="comment">  * onHandleIntent() = 抽象方法，使用时需重写</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用onStart（）-&gt;&gt;分析1</span></span><br><span class="line">    onStart(intent, startId);</span><br><span class="line">    <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 分析1：onStart(intent, startId)</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 获得ServiceHandler消息的引用</span></span><br><span class="line">    Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">    msg.arg1 = startId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 把 Intent参数 包装到 message 的 obj 发送消息中，</span></span><br><span class="line">    <span class="comment">//这里的Intent  = 启动服务时startService(Intent) 里传入的 Intent</span></span><br><span class="line">    msg.obj = intent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 发送消息，即 添加到消息队列里</span></span><br><span class="line">    mServiceHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy"></a>onDestroy</h5><p>Service销毁时，停止 Looper 并把消息队列中的所有消息给移除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//将消息队列中的所有消息给移除，包括处理中的和未处理的</span></span><br><span class="line">      mServiceLooper.quit();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><strong>1.为什么不建议通过 bindService() 启动 IntentService？</strong></p>
<p>IntentService 源码中的 onBind() 默认返回 null；bindService()启动服务生命周期：onCreate() -&gt;&gt; onBind() -&gt;&gt; onunbind()-&gt;&gt; onDestory()，并不会调用<code>onStart()</code> 或 <code>onStartcommand()</code>，<strong>故不会将消息发送到消息队列，那么onHandleIntent()将不会回调，即无法实现多线程的操作</strong>。</p>
<p><strong>2.为什么多次启动 IntentService 会顺序执行事件，停止服务后，后续的事件得不到执行？</strong></p>
<p>由于<code>onCreate()</code>只会调用一次 = 只会创建1个工作线程；</p>
<p>当多次调用 <code>startService(Intent)</code>时（即 <code>onStartCommand（）</code>也会调用多次），其实不会创建新的工作线程，只是把消息加入消息队列中 &amp; 等待执行。而如果服务停止，会清除消息队列中的消息，后续的事件得不到执行。</p>
<p>每次onHandleIntent方法处理完，HandlerThread继续观察消息队列，如果还有未执行完的message则继续执行，否则使用stopSelf()通知HandlerThread 已经全部处理完毕，结束Looper循环。</p>
<p><strong>所以，多次启动 IntentService 会按顺序执行事件</strong>。</p>
<h5 id="3-在源码handleMessage方法中为什么执行完onHandleIntent方法会去调用带参数的stopSelf-satrtId-？"><a href="#3-在源码handleMessage方法中为什么执行完onHandleIntent方法会去调用带参数的stopSelf-satrtId-？" class="headerlink" title="3.在源码handleMessage方法中为什么执行完onHandleIntent方法会去调用带参数的stopSelf(satrtId)？"></a>3.在源码handleMessage方法中为什么执行完onHandleIntent方法会去调用带参数的stopSelf(satrtId)？</h5><p>因为stopSelf()的执行会立刻将服务停止掉，而带参数的stopSelf(int startId)会在所有任务执行完毕后将服务给停止。通常情况下调用stopSelf(int satrtId)方法不会立刻去执行停止服务的操作，会去判断最近执行任务的次数是否和startId相等，如果相等就立刻执行停止服务的操作。</p>
<p><strong>4.启动 IntentService 为什么不需要新建线程？</strong><br>IntentService内部的HandlerThread 继承自 Thread，内部封装了 Looper，在这里新建线程并启动，所以启动 IntentService 不需要新建线程。</p>
<p><strong>5.onHandleIntent() 方法在工作线程中执行</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>IntentService 是继承自 Service 并处理异步请求的一个类，在 IntentService 内有一个工作线程来处理耗时操作。</p>
<p>当任务执行完后，IntentService 会自动停止，不需要我们去手动结束。</p>
<p>如果启动 IntentService 多次，那么每一个耗时操作会以工作队列的方式在 IntentService 的 onHandleIntent 回调方法中执行，依次去执行，使用串行的方式，执行完自动结束。</p>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/8a3c44a9173a" target="_blank" rel="noopener">Android多线程：这是一份全面 &amp; 详细的IntentService源码分析指南</a></p>
<p><a href="https://www.jianshu.com/p/8c4181049564" target="_blank" rel="noopener">Android IntentService使用介绍以及原理分析</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
</search>
