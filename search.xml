<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Activity必备基础</title>
    <url>/2020/07/23/Activity%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android的四大组件之一的Activity。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、Activity是什么"><a href="#一、Activity是什么" class="headerlink" title="一、Activity是什么"></a>一、Activity是什么</h4><p>我们都知道android中有四大组件（Activity 活动，Service 服务，BroadcastReceiver 广播接收器，Content Provider 内容提供者），Activity是用的最多也是最基本的组件，Activity 提供窗口来和用户进行交互的组件。官方是这么介绍的：</p>
<a id="more"></a>

<blockquote>
<p>An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View).</p>
<p>一个activity是一个单独的，用来处理用户操作的窗口。几乎所有的activity都是用来和用户交互的，所以activity类会创建了一个窗口，你可以通过setContentView(View)显示你的UI在窗口上。</p>
</blockquote>
<ul>
<li>Activity是一个应用程序组件，提供一个屏幕，用户可以用来交互为了完成某项任务。</li>
<li>Activity中所有操作都与用户密切相关，是一个负责与用户交互的组件，可以通过setContentView(View)来显示指定控件。</li>
</ul>
<h4 id="二、Activity状态及转换"><a href="#二、Activity状态及转换" class="headerlink" title="二、Activity状态及转换"></a>二、Activity状态及转换</h4><p>在android 中，Activity 拥有四种基本状态：</p>
<p>1.<strong>Active/Running</strong></p>
<p>​    一个新 Activity 启动入栈后，它显示在屏幕最前端，处理是处于栈的最顶端（Activity栈顶），此时它处于可见并可和用户交互的激活状态，叫做活动状态或者运行状态（active or running）。</p>
<p>2.<strong>Paused</strong></p>
<p>​    当 Activity 失去焦点，被另一个透明或者 Dialog 样式非全屏的 Activity 覆盖时的状态，叫做暂停状态（Paused）。此时它依然与窗口管理器保持连接，系统继续维护其内部状态，所以它仍然可见，但它已经失去了焦点故不可与用户交互。</p>
<p>3.<strong>Stopped</strong></p>
<p>​    当 Activity 被另外一个 Activity 完全覆盖掉，不可再见时的状态叫做停止状态（Stopped）。</p>
<p>4.<strong>Killed</strong></p>
<p>​    Activity 被系统杀死回收或者没有被启动时的状态，叫做被杀死的状态（Killed）。</p>
<p>下图说明了 Activity 在不同状态间转换的时机和条件：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5lxx3ssej308n081dfu.jpg" alt=""></p>
<h4 id="三、Activity栈"><a href="#三、Activity栈" class="headerlink" title="三、Activity栈"></a>三、Activity栈</h4><p>Android 是通过一种 Activity 栈的方式来管理 Activity 的，一个 Activity 的实例的状态决定它在栈中的位置。处于前台的 Activity 总是在栈的顶端，当前台的 Activity 因为异常或其它原因被销毁时，处于栈第二层的 Activity 将被激活，上浮到栈顶。当新的 Activity 启动入栈时，原 Activity 会被压入到栈的第二层。一个 Activity 在栈中的位置变化反映了它在不同状态间的转换。Activity 的状态与它在栈中的位置关系如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5m9bc21zj308w05r748.jpg" alt=""></p>
<p>如上所示，除了最顶层即处在 Active 状态的 Activity 外，其它的 Activity 都有可能在系统内存不足时被回收，一个 Activity 的实例越是处在栈的底层，它被系统回收的可能性越大。系统负责管理栈中 Activity 的实例，它根据 Activity 所处的状态来改变其在栈中的位置。</p>
<h4 id="四、Activity生命周期"><a href="#四、Activity生命周期" class="headerlink" title="四、Activity生命周期"></a>四、Activity生命周期</h4><p>生命周期函数，常用的7个如下：</p>
<p><strong>onCreate()</strong>：表示 Activity <strong>正在被创建</strong>，常用来<strong>初始化工作</strong>，比如调用 setContentView 加载界面布局资源，初始化 Activity 所需数据等；</p>
<p><strong>onReStart()</strong>：表示 Activity <strong>正在重新启动</strong>，当前 Acitivty 从不可见重新变为可见时，onRestart 就会被调用；</p>
<p><strong>onStart()</strong>：表示 Activity <strong>正在被启动</strong>，此时 Activity <strong>可见但不在前台</strong>，还处于后台，无法与用户交互；</p>
<p><strong>onResume()</strong>：表示 Activity <strong>获得焦点</strong>，此时 Activity <strong>可见且在前台</strong>并开始活动，位于活动堆栈的顶部，这是与onStart的区别所在；</p>
<p><strong>onPause()</strong>：表示 Activity <strong>正在停止</strong>，<strong>可见但不在前台</strong>，此时可做一些<strong>存储数据、停止动画</strong>等工作，但是不能太耗时，因为这会影响到新 Activity 的显示，onPause 必须先执行完，新 Activity 的 onResume 才会执行；</p>
<p><strong>onStop()</strong>：表示 Activity <strong>即将停止</strong>，被新 activity 覆盖了，对用户<strong>不可见</strong>，可以做一些稍微重量级的回收工作，比如注销广播接收器、关闭网络连接等，同样不能太耗时；</p>
<p><strong>onDestroy()</strong>：表示 Activity <strong>即将被销毁</strong>，这是 Activity 生命周期中的最后一个回调，常做<strong>回收工作、资源释放</strong>；</p>
<ul>
<li>延伸：从<strong>整个生命周期</strong>来看，<strong>onCreate</strong> 和 <strong>onDestroy</strong> 是配对的，分别标识着 Activity 的创建和销毁，并且只可能有<strong>一次调用</strong>； 从 Activity <strong>是否可见</strong>来说，<strong>onStart</strong> 和 <strong>onStop</strong> 是配对的，这两个方法可能被<strong>调用多次</strong>； 从 Activity <strong>是否在前台</strong>来说，<strong>onResume</strong> 和 <strong>onPause</strong> 是配对的，这两个方法可能被<strong>调用多次</strong>； 除了这种区别，在实际使用中没有其他明显区别。</li>
</ul>
<p>Activity 生命周期循环图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5o2g5wxnj30e90if75q.jpg" alt=""></p>
<p><strong>onSaveInstanceState()</strong>：发生条件在系统配置发生改变（例如屏幕方向）导致 Activity 被杀死并重新创建、资源内存不足导致低优先级的 Activity 被杀死，系统会调用 <strong>onSaveInstanceState</strong> 来保存当前 Activity 的状态，此方法调用在 onStop 之后 和 onDestory 之前；</p>
<p><strong>onRestoreInstanceState()</strong>： 当 Activity 被重建后，系统会调用 <strong>onRestoreInstanceState</strong>，并且把onSaveInstanceState 方法所保存的 Bundle 对象<strong>同时传参</strong>给 onRestoreInstanceState() 和 onCreate() ，因此可以通过这两个方法判断 Activity <strong>是否被重建</strong>，调用在 onStart 之后，可使用 onSaveInstanceState() 和onRestoreInstanceState()（或onCreate()）来保存和恢复 Activity 活动状态。</p>
<h4 id="五、Activity启动和通信"><a href="#五、Activity启动和通信" class="headerlink" title="五、Activity启动和通信"></a>五、Activity启动和通信</h4><p><strong>Intent</strong>是一种消息传递的机制，它负责对操作的动作、动作涉及数据、附加数据进行描述。Android 则根据此Intent的描述，负责找到对应的组件，将 Intent 传递给调用的组件，并完成组件的调用。</p>
<h5 id="显式Intent"><a href="#显式Intent" class="headerlink" title="显式Intent"></a>显式Intent</h5><p>通过指定具体的组件类，通知应用启动对应的组件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClass(MainActivity.<span class="keyword">this</span>,SecondAcvivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">intent.putExtra(<span class="string">"values"</span>,<span class="string">"传个值"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<h5 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h5><p>通过指定了一系列更为抽象的 action 和 category 等信息，然后交由系统去分析这个 Intent，并帮我们找出合适的活动去启动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.administrator.ACTION_START"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>要在清单文件中<code>&lt;activity&gt;</code>标签下配置<code>&lt;intent-filter&gt;</code>的内容，可以指定当前活动能够响应的 action<br>和 category，如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".SecondActivity"</span> &gt;</span><br><span class="line">	&lt;intent-filter&gt;</span><br><span class="line">		&lt;action android:name=<span class="string">"com.example.administrator.ACTION_START"</span> /&gt;</span><br><span class="line">		&lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">	&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Intent-Filter"><a href="#Intent-Filter" class="headerlink" title="Intent Filter"></a>Intent Filter</h5><p>描述了一个组件愿意接收什么样的 Intent 对象，Android 将其抽象为 android.content.IntentFilter 类。 Activity 通过指定其 Intent Filter告诉系统该 Activity 可以响应什么类型的 Intent，有三大属性Action、URL、Category可以配置。</p>
<p>Activity 中 Intent Filter 匹配的过程：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh6iwqed6kj30890bvmxc.jpg" alt=""></p>
<p><strong>Action 匹配</strong></p>
<p>是一个用户定义的字符串，一个 Intent Filter 可以包含多个 Action，用于标示 Activity 所能接受的”动作”。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter &gt;</span><br><span class="line"> 	&lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line"> 	&lt;action android:name=<span class="string">"com.xx.myaction"</span> /&gt;</span><br><span class="line">	......</span><br><span class="line"> &lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<p><strong>URI 数据匹配</strong></p>
<p>通过 URI 携带外部数据给目标组件，在<code>&lt;intent-filter&gt;</code>标签中配置一个<code>&lt;data&gt;</code>标签。</p>
<p>mimeType 属性指定携带外部数据的数据类型，scheme 指定协议，host、port、path 指定数据的位置、端口、和路径。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">	&lt;data android:mimeType=<span class="string">"mimeType"</span> android:scheme=<span class="string">"scheme"</span></span><br><span class="line"> 				android:host=<span class="string">"host"</span> android:port=<span class="string">"port"</span> android:path=<span class="string">"path"</span>/&gt;</span><br><span class="line">&lt;/intent-filter</span><br></pre></td></tr></table></figure>

<p>只有<code>&lt;data&gt;</code>标签中指定的内容和 Intent 中携带的 Data 完全一致时，当前活动才能够响应该 Intent。不过一般在<code>&lt;data&gt;</code>标签中都不会指定过多的内容。</p>
<p><strong>Category 类别匹配</strong></p>
<p>为组件定义一个 Category 类别列表，当 Intent 中包含这个列表的所有项目时 Category 类别匹配才会成功。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">	&lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<p>android.intent.category.DEFAULT 是一种默认的 category，在调用startActivity()方法的时候会自动将这个 category 添加到 Intent 中。</p>
<p><strong>接收上一个Activity返回数据</strong></p>
<p><strong>startActivityForResult()</strong>方法也是用于启动 Activity 的，这个方法可以 Activity 销毁的时候能够返回一个结果给上一个活动。该方法接收两个参数，第一个参数还是 Intent，第二个参数是请求码，用于在之后的回调中判断数据的来源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">startActivityForResult(intent, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>返回代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"data_return"</span>, <span class="string">"Hello MainActivity"</span>);</span><br><span class="line">setResult(RESULT_OK, intent);</span><br><span class="line">finish();</span><br></pre></td></tr></table></figure>

<p><strong>setResult()</strong>方法接收两个参数，第一个参数用于向上一个活动返回处理结果，一般只使用<strong>RESULT_OK</strong>或<strong>RESULT_CANCELED</strong>，第二个参数则是把带有数据的 Intent 传递回去，然后调用了 finish()方法来销毁当前活动。</p>
<p>在需要接收返回数据的 Activity 中重写<strong>onActivityResult()</strong>方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	<span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">		String returnedData = data.getStringExtra(<span class="string">"data_return"</span>);</span><br><span class="line">		Log.d(<span class="string">"FirstActivity"</span>, returnedData);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onActivityResult()方法带有三个参数：</p>
<p>第一个参数 requestCode，即我们在启动活动时传入的请求码。</p>
<p>第二个参数 resultCode，即我们在返回数据时传入的处理结果。</p>
<p>第三个参数 data，即携带着返回数据的 Intent。</p>
<h4 id="六、Activity启动模式"><a href="#六、Activity启动模式" class="headerlink" title="六、Activity启动模式"></a>六、Activity启动模式</h4><h5 id="使用-manifest-文件"><a href="#使用-manifest-文件" class="headerlink" title="使用 manifest 文件"></a>使用 manifest 文件</h5><p>在 manifest 文件中通过给<code>&lt;activity&gt;</code>标签的<strong>android:launchMode</strong>属性来指定恰当的启动模式。</p>
<p>1.<strong>standard标准模式</strong></p>
<p>​        每次启动一个 Activity 都会重新创建一个新的实例，不管这个实例是否已经存在，此模式的 Activity 默认会进入启动它的 Activity 所属的任务栈中；</p>
<p>2.<strong>singleTop栈顶复用模式</strong></p>
<p>​        如果新 Activity 已经位于任务栈的栈顶，那么此 Activity 不会被重新创建，同时会回调 <strong>onNewIntent</strong> 方法，如果已经存在但不在栈顶，那么 Activity 依然会被重新创建；一般用于推送消息跳转界面。</p>
<p>3.<strong>singleTask栈内复用模式</strong></p>
<p>​        Activity 在同一个Task内只有一个实例。每次启动该 Activity 时系统首先会在返回栈中检查是否存在该Activity 的实例，如果发现已经存在则直接使用该实例，回调其<strong>onNewIntent</strong>方法，并把在这个 Activity 之上的所有 Activity 统统出栈；如果没有发现就会创建一个新的 Activity 实例，并将其加入Task栈顶，一般项目的主页面用该启动模式。</p>
<p>4.<strong>singleInstance单实例模式</strong></p>
<p>整个系统里只有一个实例，Activity只能单独地位于一个任务栈中，且此任务栈中只有唯一一个实例，在不同app之间的共享活动实例，一般用于系统功能界面。</p>
<h5 id="使用-Intent-标志"><a href="#使用-Intent-标志" class="headerlink" title="使用 Intent 标志"></a>使用 Intent 标志</h5><p>Activity常用的标记位Flags</p>
<ul>
<li><p><strong>FLAG_ACTIVITY_NEW_TASK</strong>：<del>对应 singleTask 启动模式</del>。</p>
<p>1.单独的<code>FLAG_ACTIVITY_NEW_TASK</code> 并不等价于启动模式 <code>singleTask</code>，它仅表示寻找和activity具有相同的亲和性的任务栈压入，（即<code>TaskAffinity</code>指定的任务栈，<code>TaskAffinity</code> 默认为应用包名）</p>
<p>2.<code>FLAG_ACTIVITY_NEW_TASK</code>+<code>FLAG_ACTIVITY_CLEAR_TOP</code>也不等价于启动模式<code>singleTask</code></p>
<p>3.在<code>FLAG_ACTIVITY_NEW_TASK</code>+<code>FLAG_ACTIVITY_CLEAR_TOP</code>的情况下，AndroidManifest.xml中设置activity的启动模式为<code>standard</code>或<code>singleTask</code>时activity入栈方式是不一样的。分为如下3个情况：</p>
<p>​    <strong>3.1</strong>当启动模式为<code>standard</code>时，如果activity所需的栈中已经存在该activity的实例了，那么这个实例连同它之上的activity都要出栈，然后再新建一个activity实例入栈。</p>
<p>​    <strong>3.2</strong>当启动模式为<code>singleTask</code>时，如果activity所需的栈中已经存在该activity的实例了，那么系统会调用该实例的<code>onNewIntent()</code>方法，且只将该实例之上的activity出栈。</p>
<p>​    <strong>3.3</strong>如果activity所需的栈中<strong>不存在</strong>该activity的实例，则不论启动模式为<code>standard</code>还是<code>singleTask</code>，都是新建activity实例直接入栈。</p>
<p>4.AndroidManifest.xml中设置activity的启动模式为<code>singleTask</code>时，则不论是<code>FLAG_ACTIVITY_NEW_TASK</code>+<code>FLAG_ACTIVITY_CLEAR_TOP</code>还是只有<code>FLAG_ACTIVITY_NEW_TASK</code>效果一样，因为singleTask模式中默认就带有<code>FLAG_ACTIVITY_CLEAR_TOP</code>标识。</p>
</li>
<li><p><strong>FLAG_ACTIVITY_SINGLE_TOP</strong>：对应 singleTop 启动模式。</p>
</li>
<li><p><strong>FLAG_ACTIVITY_CLEAR_TOP</strong>：在同一个任务栈中所有位于它上面的 Activity 都要出栈。这个标记位一般会和 singleTask 模式一起出现，在这种情况下，被启动Activity的实例如果已经存在，那么系统就会回调onNewIntent。如果被启动的 Activity 采用 standard 模式启动，那么它以及连同它之上的 Activity 都要出栈，系统会创建新的 Activity 实例并放入栈中。</p>
</li>
<li><p><strong>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS :</strong> 具有这个标记的 Activity 不会出现在历史 Activity 列表中。</p>
</li>
</ul>
<p>注意：从 Activity 外部(Service,BroadcastReceiver,Application等)不设置 FLAG_ACTIVITY_NEW_TASK 是不能启动 Activity 的，除非调用者指定 Activity 要启动的 task 的 Id。所以建议加上 FLAG_ACTIVITY_NEW_TASK。</p>
<p>api 24以下，非activity场景启动activity必须加new_task，原因还是任务栈的概念；<br>api 24及以上28以下，非activity场景启动activity不加new_task不会抛出异常，标记可加可不加；</p>
<p>api 28及以上，Android9.0中非activity场景启动activity需要加new_task。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以此文记录 Android 中 Activity 的基础知识，便于对 Activity 的理解和学习。</p>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ContentProvider必备基础</title>
    <url>/2020/07/29/ContentProvider%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android的四大组件之一的ContentProvider。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是ContentProvider"><a href="#一、什么是ContentProvider" class="headerlink" title="一、什么是ContentProvider"></a>一、什么是ContentProvider</h4><p>ContentProvider 是 Android 中提供的专门用于不同应用间数据交互和共享的组件。它实际上是对SQLiteOpenHelper 的进一步封装，以一个或多个表的形式将数据呈现给外部应用，通过 Uri 映射来选择需要操作数据库中的哪个表，并对表中的数据进行增删改查处理。ContentProvider 其底层使用了 Binder 来完成APP 进程之间的通信，同时使用匿名共享内存来作为共享数据的载体。ContentProvider 支持访问权限管理机制，以控制数据的访问者及访问方式，保证数据访问的安全性。</p>
<a id="more"></a>

<h4 id="二、相关知识"><a href="#二、相关知识" class="headerlink" title="二、相关知识"></a>二、相关知识</h4><h5 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h5><p><strong>Uniform Resource Identifier</strong> 即统一资源标识符，外界进程通过 <code>URI</code> 找到对应的 ContentProvider 和其中的数据，再进行数据操作。以联系人Contacts 的 Uri 为例，其结构如下所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghdopxmxsmj30ig04kdfp.jpg" alt=""></p>
<p><strong>schema:</strong>  Android 中固定为 <code>content://</code>。</p>
<p><strong>authority:</strong>  用于唯一标识一个 ContentProvider。</p>
<p><strong>path:</strong>  ContentProvider 中数据表的表名。</p>
<p><strong>id:</strong>  数据表中数据的标识，可选字段。</p>
<h5 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h5><p>指定某种扩展名的文件用什么应用程序来打开的方式类型。ContentProvider 会根据 URI 来返回一个包含两部分 MIME 类型的字符串，每种 <code>MIME</code> 类型一般由2部分组成 = 类型 + 子类型，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">text/html <span class="comment">// 类型 = text、子类型 = html</span></span><br><span class="line">text/css </span><br><span class="line">text/xml </span><br><span class="line">application/pdf</span><br></pre></td></tr></table></figure>

<h5 id="UriMatcher类"><a href="#UriMatcher类" class="headerlink" title="UriMatcher类"></a>UriMatcher类</h5><p>是一个工具类，帮助匹配 ContentProvider 中的 Uri。提供了两个方法 <strong>addURI()</strong> 和 <strong>match()</strong> 方法。</p>
<ul>
<li><strong>addURI(String authority,String path, int code)：</strong>是在 ContentProvider 添加一个用于匹配的 Uri，当匹配成功时返回 code 。在 ContentProvider 中注册 URI ，把 Uri 和 code 相关联，Uri可以是精确的字符串，Uri 中带有*表示可匹配任意text，#表示只能匹配数字</li>
<li><strong>match(Uri uri) ：</strong>根据 URI 匹配 ContentProvider 中对应的数据表，对 Uri 进行验证。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：初始化UriMatcher对象</span></span><br><span class="line">    UriMatcher matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH); </span><br><span class="line">    <span class="comment">//常量UriMatcher.NO_MATCH  = 不匹配任何路径的返回码</span></span><br><span class="line">    <span class="comment">// 即初始化时不匹配任何东西</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：在ContentProvider 中注册URI（addURI（））</span></span><br><span class="line">    <span class="keyword">int</span> URI_CODE_a = <span class="number">1</span>；</span><br><span class="line">    <span class="keyword">int</span> URI_CODE_b = <span class="number">2</span>；</span><br><span class="line">    matcher.addURI(<span class="string">"com.prsuit.myprovider"</span>, <span class="string">"user"</span>, URI_CODE_a); </span><br><span class="line">    matcher.addURI(<span class="string">"com.prsuit.myprovider"</span>, <span class="string">"book"</span>, URI_CODE_b); </span><br><span class="line">    <span class="comment">// 若URI资源路径 = content://com.prsuit.myprovider/user ，则返回注册码URI_CODE_a</span></span><br><span class="line">    <span class="comment">// 若URI资源路径 = content://com.prsuit.myprovider/book ，则返回注册码URI_CODE_b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源（match（））</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMatchTableName</span><span class="params">(Uri uri)</span> </span>&#123;   </span><br><span class="line">      Uri uri = Uri.parse(<span class="string">" content://com.prsuit.myprovider/user"</span>);   </span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span>(matcher.match(uri))&#123;   </span><br><span class="line">     <span class="comment">// 根据URI匹配的返回码是URI_CODE_a</span></span><br><span class="line">     <span class="comment">// 即matcher.match(uri) == URI_CODE_a</span></span><br><span class="line">      <span class="keyword">case</span> URI_CODE_a:   </span><br><span class="line">        <span class="keyword">return</span> tableNameUser;   </span><br><span class="line">        <span class="comment">// 如果根据URI匹配的返回码是URI_CODE_a，则返回ContentProvider中的名为tableNameUser的表</span></span><br><span class="line">      <span class="keyword">case</span> URI_CODE_b:   </span><br><span class="line">        <span class="keyword">return</span> tableNameBook;</span><br><span class="line">        <span class="comment">// 如果根据URI匹配的返回码是URI_CODE_b，则返回ContentProvider中的名为tableNameBook的表</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ContentUris类"><a href="#ContentUris类" class="headerlink" title="ContentUris类"></a>ContentUris类</h5><p>用来操作 <code>URI</code>，核心方法有两个：<strong>withAppendedId()</strong> 和 <strong>parseId()</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// withAppendedId（）作用：向URI追加一个id</span></span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://com.prsuit.myprovider/user"</span>) </span><br><span class="line">Uri resultUri = ContentUris.withAppendedId(uri, <span class="number">7</span>);  </span><br><span class="line"><span class="comment">// 最终生成后的Uri为：content://com.prsuit.myprovider/user/7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parseId（）作用：从URL中获取ID</span></span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://com.prsuit.myprovider/user/7"</span>) </span><br><span class="line"><span class="keyword">long</span> personid = ContentUris.parseId(uri); </span><br><span class="line"><span class="comment">//获取的结果为:7</span></span><br></pre></td></tr></table></figure>

<h5 id="ContentProvider类"><a href="#ContentProvider类" class="headerlink" title="ContentProvider类"></a>ContentProvider类</h5><p>组织数据方式，ContentProvider 主要以 <strong>表格的形式</strong> 组织数据。进程间共享数据的本质是：添加、删除、获取和修改（更新）数据，所以其核心方法也主要是上述4个作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;-- <span class="number">4</span>个核心方法 --&gt;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span></span><br><span class="line"><span class="function">  <span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span></span><br><span class="line"><span class="function">  <span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function">  <span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs,  String sortOrder)</span>　 </span></span><br><span class="line"><span class="function">  <span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 注：</span></span></span><br><span class="line"><span class="function">  <span class="comment">// 1. 上述4个方法由外部进程回调，并运行在ContentProvider进程的Binder线程池中（不是主线程）</span></span></span><br><span class="line"><span class="function"> <span class="comment">// 2. 存在多线程并发访问，需要实现线程同步</span></span></span><br><span class="line"><span class="function">   <span class="comment">// a. 若ContentProvider的数据存储方式是使用SQLite &amp; 一个，则不需要，因为SQLite内部实现好了线程同步，若是多个SQLite则需要，因为SQL对象之间无法进行线程同步</span></span></span><br><span class="line"><span class="function">  <span class="comment">// b. 若ContentProvider的数据存储方式是内存，则需要自己实现线程同步</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&lt;-- 2个其他方法 --&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// ContentProvider创建后 或 打开系统后其它进程第一次访问该ContentProvider时 由系统进行调用</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注：运行在ContentProvider进程的主线程，故不能做耗时操作</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 得到数据类型，即返回当前 Url 所代表数据的MIME类型</span></span></span><br></pre></td></tr></table></figure>

<h5 id="ContentResolver类"><a href="#ContentResolver类" class="headerlink" title="ContentResolver类"></a>ContentResolver类</h5><p>统一管理不同 ContentProvider 间的操作，ContentProvider 类并不会直接与外部进程交互，而是通过ContentResolver 类。它提供了与 ContentProvider 类相同名字和作用的4个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span>　 </span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>　 </span></span><br><span class="line"><span class="function"><span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="ContentObserver类"><a href="#ContentObserver类" class="headerlink" title="ContentObserver类"></a>ContentObserver类</h5><p>内容观察者，观察 Uri 引起 ContentProvider 中的数据变化并通知数据访问者。当 ContentProvider 中的数据发生变化（增、删 、改）时，就会触发该 ContentObserver 类，可以通过 ContentResolver 的registerContentObserver 和 unregisterContentObserver 方法来注册和注销 ContentObserver 监听器。当被监听的ContentProvider发生变化时，就会回调对应的 ContentObserver 的 onChange 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：注册内容观察者ContentObserver</span></span><br><span class="line">    getContentResolver().registerContentObserver（uri）；</span><br><span class="line">    <span class="comment">// 通过ContentResolver类进行注册，并指定需要观察的URI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：当该URI的ContentProvider数据发生变化时，通知外界（即访问该ContentProvider数据的访问者）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123; </span><br><span class="line">      <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123; </span><br><span class="line">      db.insert(<span class="string">"user"</span>, <span class="string">"userid"</span>, values);</span><br><span class="line">      <span class="comment">// 通知访问者</span></span><br><span class="line">      getContext().getContentResolver().notifyChange(uri, <span class="keyword">null</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：解除观察者</span></span><br><span class="line"> getContentResolver().unregisterContentObserver（uri）；</span><br><span class="line">    <span class="comment">// 同样需要通过ContentResolver类进行解除</span></span><br></pre></td></tr></table></figure>

<h4 id="三、具体使用"><a href="#三、具体使用" class="headerlink" title="三、具体使用"></a>三、具体使用</h4><h5 id="创建数据库类"><a href="#创建数据库类" class="headerlink" title="创建数据库类"></a>创建数据库类</h5><p>创建类 DBHelper 继承 SQLiteOpenHelper 并实现构造方法以及重载 onCreate 和 onUpgrade 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATABASE_NAME = <span class="string">"com_sample_provider.db"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">"user"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOK_TABLE_NAME = <span class="string">"book"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATABASE_VERSION = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CREATE_USER_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span></span><br><span class="line">            + USER_TABLE_NAME</span><br><span class="line">            + <span class="string">"(id INTEGER PRIMARY KEY AUTOINCREMENT,name VARCHAR(64))"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CREATE_BOOK_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span></span><br><span class="line">            + BOOK_TABLE_NAME</span><br><span class="line">            + <span class="string">"(id INTEGER PRIMARY KEY AUTOINCREMENT,name VARCHAR(64))"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context,DATABASE_NAME,<span class="keyword">null</span>,DATABASE_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, <span class="keyword">int</span> version)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, name, factory, version);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, <span class="keyword">int</span> version, @Nullable DatabaseErrorHandler errorHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, name, factory, version, errorHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi</span>(api = Build.VERSION_CODES.P)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(@Nullable Context context, @Nullable String name, <span class="keyword">int</span> version, @NonNull SQLiteDatabase.OpenParams openParams)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, name, version, openParams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建数据表格:用户表和图书表</span></span><br><span class="line">        db.execSQL(CREATE_USER_TABLE);</span><br><span class="line">        db.execSQL(CREATE_BOOK_TABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空user表数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearTable</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        SQLiteDatabase database = <span class="keyword">new</span> DBHelper(context).getWritableDatabase();</span><br><span class="line">        database.execSQL(<span class="string">"delete from user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自定义-ContentProvider-类，实现相关的抽象方法"><a href="#自定义-ContentProvider-类，实现相关的抽象方法" class="headerlink" title="自定义 ContentProvider 类，实现相关的抽象方法"></a>自定义 ContentProvider 类，<strong>实现相关的抽象方法</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyContentProvider"</span>;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> DBHelper dbHelper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase mDatabase = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String matchTableName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ContentProvider的唯一标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">"com.prsuit.myprovider"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_PATH = <span class="string">"user"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOK_PATH = <span class="string">"book"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USER_CODE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOOK_CODE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UriMatcher matcher;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在ContentProvider 中注册URI</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://com.prsuit.myprovider/user ，则返回注册码USER_CODE</span></span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://com.prsuit.myprovider/book ，则返回注册码BOOK_CODE</span></span><br><span class="line">        matcher.addURI(AUTHORITY,USER_PATH,USER_CODE);</span><br><span class="line">        matcher.addURI(AUTHORITY,BOOK_PATH,BOOK_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mContext = getContext();</span><br><span class="line">        dbHelper = <span class="keyword">new</span> DBHelper(getContext());</span><br><span class="line">        mDatabase = dbHelper.getWritableDatabase();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(@NonNull Uri uri, @Nullable ContentValues values)</span> </span>&#123;</span><br><span class="line">        matchTableName = getMatchTableName(uri);</span><br><span class="line">        <span class="keyword">long</span> row = -<span class="number">1</span>;<span class="comment">//返回值是插入数据所在的行号</span></span><br><span class="line">        row = mDatabase.insert(matchTableName,<span class="keyword">null</span>,values);</span><br><span class="line">        <span class="keyword">if</span> (row &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">            mContext.getContentResolver().notifyChange(uri,<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> ContentUris.withAppendedId(uri,row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder)</span> </span>&#123;</span><br><span class="line">        matchTableName = getMatchTableName(uri);</span><br><span class="line">        Cursor cursor = mDatabase.query(matchTableName,projection,selection,selectionArgs,<span class="keyword">null</span>,<span class="keyword">null</span>,sortOrder);</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(@NonNull Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        matchTableName = getMatchTableName(uri);</span><br><span class="line">        <span class="comment">//返回值代表此次操作影响到的行数</span></span><br><span class="line">        <span class="keyword">int</span> deleteRow = mDatabase.delete(matchTableName, selection, selectionArgs);</span><br><span class="line">        <span class="keyword">if</span> (deleteRow &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            mContext.getContentResolver().notifyChange(uri,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deleteRow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        matchTableName = getMatchTableName(uri);</span><br><span class="line">        <span class="comment">//返回值代表此次操作影响到的行数</span></span><br><span class="line">        <span class="keyword">int</span> updateRow = mDatabase.update(matchTableName, values, selection, selectionArgs);</span><br><span class="line">        <span class="keyword">if</span> (updateRow &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            mContext.getContentResolver().notifyChange(uri,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> updateRow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMatchTableName</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">        String tableName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> uriCode = matcher.match(uri);</span><br><span class="line">        <span class="keyword">switch</span> (uriCode)&#123;</span><br><span class="line">            <span class="keyword">case</span> USER_CODE:</span><br><span class="line">                tableName = DBHelper.USER_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BOOK_CODE:</span><br><span class="line">                tableName = DBHelper.BOOK_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在-AndroidManifest-中声明-provider-以及定义相关访问权限"><a href="#在-AndroidManifest-中声明-provider-以及定义相关访问权限" class="headerlink" title="在 AndroidManifest 中声明 provider 以及定义相关访问权限"></a>在 AndroidManifest 中声明 provider 以及定义相关访问权限</h5><p>在注册ContentProvider的时候通过 android:process 属性设置 provider 运行在单独的进程里，模拟进程间通信。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- MyProvider 访问权限声明 --&gt;</span><br><span class="line">  <span class="comment">// 细分读 &amp; 写权限如下，也可直接采用全权限</span></span><br><span class="line">&lt;permission android:name=<span class="string">"com.prsuit.myprovider.READ"</span> </span><br><span class="line">  android:protectionLevel=<span class="string">"normal"</span> /&gt;</span><br><span class="line">&lt;permission android:name=<span class="string">"com.prsuit.myprovider.WRITE"</span></span><br><span class="line">        android:protectionLevel=<span class="string">"normal"</span> /&gt;</span><br><span class="line"> &lt;!-- &lt;permission android:name=<span class="string">"com.prsuit.myprovider.PROVIDER"</span></span><br><span class="line">        android:protectionLevel=<span class="string">"normal"</span> /&gt; --&gt;</span><br><span class="line">          </span><br><span class="line"> &lt;!-- 声明ContentProvider --&gt;</span><br><span class="line"> &lt;application&gt;</span><br><span class="line">    &lt;provider</span><br><span class="line">            android:name=<span class="string">".contentprovider.MyContentProvider"</span></span><br><span class="line">            android:authorities=<span class="string">"com.prsuit.myprovider"</span></span><br><span class="line">            android:process=<span class="string">":provider"</span></span><br><span class="line">            <span class="comment">// 声明外界进程可访问该Provider的全权限（读 &amp; 写）</span></span><br><span class="line">            <span class="comment">//android:permission="com.prsuit.myprovider.PROVIDER"</span></span><br><span class="line">            <span class="comment">// 权限可细分为读 &amp; 写的权限</span></span><br><span class="line">            android:readPermission=<span class="string">"com.prsuit.myprovider.READ"</span></span><br><span class="line">            android:writePermission=<span class="string">"com.prsuit.myprovider.WRITE"</span></span><br><span class="line">            android:exported=<span class="string">"true"</span> <span class="comment">//表明是否允许其他应用调用ContentProvider，true表示支持，false表示不支持</span></span><br><span class="line">            /&gt;</span><br><span class="line"> &lt;/application</span><br></pre></td></tr></table></figure>

<p>在其他应用要访问 MyContentProvider，需要在AndroidManifest中声明相应权限才可进行相应操作，否则会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 其他应用声明ContentProvider所需权限 --&gt; </span><br><span class="line">&lt;uses-permission android:name=<span class="string">"com.prsuit.myprovider.READ"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"com.prsuit.myprovider.WRITE"</span> /&gt;</span><br><span class="line">  <span class="comment">//采用全权限</span></span><br><span class="line">&lt;!--&lt;uses-permission android:name=<span class="string">"com.prsuit.myprovider.PROVIDER"</span> /&gt; --&gt;</span><br></pre></td></tr></table></figure>

<h5 id="通过ContentResolver根据URI进行增删改查"><a href="#通过ContentResolver根据URI进行增删改查" class="headerlink" title="通过ContentResolver根据URI进行增删改查"></a>通过ContentResolver根据URI进行增删改查</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentProviderActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">"com.prsuit.myprovider"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri USER_URI = Uri.parse(<span class="string">"content://"</span> + AUTHORITY + <span class="string">"/user"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startAct</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        context.startActivity(<span class="keyword">new</span> Intent(context, ContentProviderActivity<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_content_provider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertValue</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        ContentValues contentValues1 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        contentValues1.put(<span class="string">"id"</span>,<span class="number">0</span>);</span><br><span class="line">        contentValues1.put(<span class="string">"name"</span>,<span class="string">"kobe"</span>);</span><br><span class="line">        Uri insert1 = getContentResolver().insert(USER_URI, contentValues1);</span><br><span class="line">        System.out.println(<span class="string">"--insertValue1--&gt;"</span>+insert1.toString());</span><br><span class="line"></span><br><span class="line">        ContentValues contentValues2 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        contentValues2.put(<span class="string">"id"</span>,<span class="number">1</span>);</span><br><span class="line">        contentValues2.put(<span class="string">"name"</span>,<span class="string">"sh"</span>);</span><br><span class="line">        Uri insert2 = getContentResolver().insert(USER_URI,contentValues2);</span><br><span class="line">        System.out.println(<span class="string">"--insertValue2--&gt;"</span>+insert2.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateValue</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        ContentValues contentValues = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        contentValues.put(<span class="string">"id"</span>,<span class="number">1</span>);</span><br><span class="line">        contentValues.put(<span class="string">"name"</span>,<span class="string">"sh2"</span>);</span><br><span class="line">        <span class="keyword">int</span> row = getContentResolver().update(USER_URI,contentValues,<span class="string">"id = ?"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>&#125;);</span><br><span class="line">        System.out.println(<span class="string">"--updateValue--&gt;"</span>+row);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteValue</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = getContentResolver().delete(USER_URI,<span class="string">"name = ?"</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"sh2"</span>&#125;);</span><br><span class="line">        System.out.println(<span class="string">"--deleteValue--&gt;"</span>+row);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryValue</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        Cursor cursor = getContentResolver().query(USER_URI, <span class="keyword">new</span> String[]&#123;<span class="string">"id"</span>, <span class="string">"name"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext())&#123;</span><br><span class="line">            System.out.println(<span class="string">"query user："</span>+cursor.getInt(<span class="number">0</span>)+<span class="string">" "</span>+cursor.getString(cursor.getColumnIndex(<span class="string">"name"</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文基于 ContentProvider 的使用过程涉及到的相关知识点进行简单地介绍和整理，归纳总结了ContentProvider 使用步骤。</p>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/94b8582d089a" target="_blank" rel="noopener">Android四大组件——ContentProvider（基础篇）</a></p>
<p><a href="https://www.jianshu.com/p/ea8bc4aaf057" target="_blank" rel="noopener">Android：关于ContentProvider的知识都在这里了！</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 搭建博客教程</title>
    <url>/2020/07/20/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要是介绍在Mac上如何使用Hexo+GitHub搭建个人博客。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是-Hexo"><a href="#一、什么是-Hexo" class="headerlink" title="一、什么是 Hexo"></a>一、什么是 Hexo</h4><blockquote>
<p><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<a id="more"></a>

<h4 id="二、配置环境"><a href="#二、配置环境" class="headerlink" title="二、配置环境"></a>二、配置环境</h4><h5 id="申请GitHub"><a href="#申请GitHub" class="headerlink" title="申请GitHub"></a>申请GitHub</h5><p><a href="https://github.com/" target="_blank" rel="noopener">Github</a>注册账号，用作博客的远程仓库和部署服务器。</p>
<h5 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h5><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网下载</a>并安装，安装完成后可用<code>node -v</code>查看版本号。</p>
<h5 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h5><p>Mac 安装 Xcode 自带有 Git，也可去<a href="https://git-scm.com/" target="_blank" rel="noopener">官网下载</a>，安装完成后可用<code>git --version</code>查看版本号。</p>
<p>需要设置你 Github 的用户名密码和email，在命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure>

<h5 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h5><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h5 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h5><p>安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml  &#x2F;&#x2F; 配置信息，你可以在此配置大部分的参数</span><br><span class="line">├── package.json &#x2F;&#x2F; 应用程序的信息</span><br><span class="line">├── public       &#x2F;&#x2F; 执行 hexo generate 命令，输出的静态网页内容目录</span><br><span class="line">├── scaffolds    &#x2F;&#x2F; 模板文件夹。当你新建文章时，Hexo会根据scaffold来建立文件 </span><br><span class="line">├── scripts      &#x2F;&#x2F; 存放自定义 javascript 脚本</span><br><span class="line">├── source       &#x2F;&#x2F; 存放用户资源的地方</span><br><span class="line">|   ├── _drafts  &#x2F;&#x2F; 草稿文章</span><br><span class="line">|   └── _posts   &#x2F;&#x2F; 发布文章</span><br><span class="line">└── themes       &#x2F;&#x2F; 存放博客的主题，Hexo会根据主题来生成静态页面</span><br></pre></td></tr></table></figure>

<p>执行下列命令，会生成静态页面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate  <span class="comment"># 或者 hexo g</span></span><br></pre></td></tr></table></figure>

<p>启动本地服务，打开浏览器输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 即可访问。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server <span class="comment"># 或者 hexo s</span></span><br></pre></td></tr></table></figure>

<h4 id="三、部署到Github"><a href="#三、部署到Github" class="headerlink" title="三、部署到Github"></a>三、部署到Github</h4><h5 id="配置-SSH-Key，将本地目录与-Github-关联"><a href="#配置-SSH-Key，将本地目录与-Github-关联" class="headerlink" title="配置 SSH Key，将本地目录与 Github 关联"></a>配置 SSH Key，将本地目录与 Github 关联</h5><p>配置SSH Key是让本地 git 项目与远程仓库建立联系。SSH Keys不配置的话每次项目有改动提交的时候就要手动输入账号密码，配置了就不需要了。</p>
<p>首先检查是否已经有SSH Key，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure>

<p>如果没有目录.ssh，则要生成一个新的SSH Key，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your e-mail"</span></span><br></pre></td></tr></table></figure>

<p>接下来几步都直接按回车键，然后系统会要你输入密码。这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。</p>
<p>成功后进入到.shh文件夹中再输入ls，查看是否有id_rsa.pub文件，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>打开id_rsa.pub文件，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>复制SSH Key后，登录GitHub账号，在Setting-&gt;SSH keys-&gt;add SSH key，将其添加到Add SSH Key里。</p>
<h5 id="测试-SSH-Key-是否配置成功"><a href="#测试-SSH-Key-是否配置成功" class="headerlink" title="测试 SSH Key 是否配置成功"></a>测试 SSH Key 是否配置成功</h5><p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>如配置了密码则要输入密码，输完按回车。如果显示以下内容，则说明Github中的 ssh 配置成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hi username! You have successfully authenticated, but GitHub does not</span><br><span class="line">provide shell access.</span><br></pre></td></tr></table></figure>

<h5 id="创建仓库-Github-Pages"><a href="#创建仓库-Github-Pages" class="headerlink" title="创建仓库 Github Pages"></a>创建仓库 Github Pages</h5><p>登录GitHub账号后，新建 New repository，建立与你github用户名对应的仓库，名称必须为username.github.io，如prsuit.github.io。</p>
<h5 id="修改Hexo的-config-yml文件"><a href="#修改Hexo的-config-yml文件" class="headerlink" title="修改Hexo的_config.yml文件"></a>修改Hexo的<code>_config.yml</code>文件</h5><p>根目录<code>_config.yml</code>是博客的配置文件，用文本编辑器打开此文件，在文件最后部分，修改deploy配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/yourname/yourname.github.io.git <span class="comment">#yourname替换成你的Github账户名</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p><strong>注意：在<code>.yml</code>文件中，冒号后面都是要带空格的。</strong></p>
<h5 id="将博客项目上传到仓库"><a href="#将博客项目上传到仓库" class="headerlink" title="将博客项目上传到仓库"></a>将博客项目上传到仓库</h5><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">$ hexo d <span class="comment">#部署到远程仓库</span></span><br><span class="line"><span class="comment"># 或者 $ hexo g -d</span></span><br></pre></td></tr></table></figure>

<p>此时，通过访问 <a href="https://yourname.github.io/" target="_blank" rel="noopener">https://yourname.github.io</a> 可以看到默认的 Hexo 首页。</p>
<p>一些常用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">"postName"</span> <span class="comment"># 新建文章</span></span><br><span class="line"></span><br><span class="line">hexo new page <span class="string">"pageName"</span> <span class="comment"># 新建页面</span></span><br><span class="line"></span><br><span class="line">hexo generate <span class="comment"># 生成静态页面至public目录，markdown转html</span></span><br><span class="line"></span><br><span class="line">hexo server <span class="comment"># 开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line"></span><br><span class="line">hexo deploy <span class="comment"># 将.deploy目录部署到GitHub</span></span><br><span class="line"></span><br><span class="line">hexo clean <span class="comment"># 清除public文件夹和db.json，清除缓存数据</span></span><br><span class="line"></span><br><span class="line">hexo <span class="built_in">help</span> <span class="comment"># 查看帮助</span></span><br><span class="line"></span><br><span class="line">hexo version <span class="comment"># 查看Hexo的版本</span></span><br><span class="line"></span><br><span class="line">hexo n == hexo new</span><br><span class="line"></span><br><span class="line">hexo g == hexo generate</span><br><span class="line"></span><br><span class="line">hexo s == hexo server</span><br><span class="line"></span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>

<h4 id="四、更换Hexo主题"><a href="#四、更换Hexo主题" class="headerlink" title="四、更换Hexo主题"></a>四、更换Hexo主题</h4><p>Hexo 中有很多主题，可以在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网</a>查看。 推荐使用<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">hexo-theme-next</a>，更换主题步骤：</p>
<h5 id="下载主题资源"><a href="#下载主题资源" class="headerlink" title="下载主题资源"></a>下载主题资源</h5><p>终端cd到初始化博客文件夹目录下，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h5 id="配置使用下载的主题"><a href="#配置使用下载的主题" class="headerlink" title="配置使用下载的主题"></a>配置使用下载的主题</h5><p>修改博客目录下<code>_config.yml</code>里的theme的名称<code>landscape</code>更改为<code>next</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<h5 id="主题的其他配置"><a href="#主题的其他配置" class="headerlink" title="主题的其他配置"></a>主题的其他配置</h5><p>可在<code>/theme/{theme}/_config.yml</code> 主题的配置文件下进行主题的配置。</p>
<h5 id="添加分类"><a href="#添加分类" class="headerlink" title="添加分类"></a>添加分类</h5><p>新建一个页面，命名为 categories，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>

<p>在 source 目录下会生成 categories 目录，修改 source/categories 目录的 index.md 如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-07-19 20:24:49</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"categories"</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>在主题<code>/theme/{theme}/_config.yml</code> 中将<code>menu</code>的<code>catagories</code>取消注释，把前面的<code>#</code>去掉即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br></pre></td></tr></table></figure>

<p>给模板添加分类属性，打开scarffolds文件夹里的post.md文件，给它的头部加上categories:，这样我们创建的所有新的文章都会自带这个属性，我们只需要往里填分类，就可以自动在网站上形成分类了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories: 分类名 <span class="comment"># 多个分类，数组形式[分类名1，分类名2]</span></span><br><span class="line"><span class="comment"># 短横线形式</span></span><br><span class="line"><span class="comment"># - 分类名1</span></span><br><span class="line"><span class="comment"># - 分类名2</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h5 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h5><p>新建一个页面，命名为 tags，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>

<p>在 source 目录下会生成 tags 目录，修改 source/tags 目录的 index.md如下 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-07-19 20:28:30</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>同样，在主题<code>/theme/{theme}/_config.yml</code> 中将<code>menu</code>的<code>tags</code>取消注释，同上。</p>
<p>以后写文章时，在要分类的文章顶部加入 tags 属性，值为标签名:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories: 分类名</span><br><span class="line">tags: [标签a,标签b] <span class="comment"># 数组形式，添加a和b两个标签</span></span><br><span class="line"><span class="comment"># 短横线形式</span></span><br><span class="line"><span class="comment"># - 标签a</span></span><br><span class="line"><span class="comment"># - 标签b</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>至此，完成以上配置，可以执行调试命令查看效果。以后就可以使用Hexo发布文章了，当然还可以添加其他配置如文章阅读统计、评论等，可自行探索。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>万事开头难，但总算开头了💔，从此开启自己的博客生涯。第一次写Blog，写作思路不是很清晰流畅，花费了比较多的时间，希望以后会越来越好，Fighting！！！</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Git入门指南</title>
    <url>/2020/07/21/Git%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要是学习和记录在工作中经常用到的一些Git命令。这里推荐几个练习和学习Git命令的网站：</p>
<blockquote>
<p><strong><a href="https://learngitbranching.js.org/?locale=zh_CN" target="_blank" rel="noopener">Learn Git Branching</a></strong>、<strong><a href="https://git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository" target="_blank" rel="noopener">《Git文档》</a></strong>、<strong><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">《廖雪峰的Git教程》</a></strong></p>
</blockquote>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、基础必读"><a href="#一、基础必读" class="headerlink" title="一、基础必读"></a>一、基础必读</h4><h5 id="Git是什么"><a href="#Git是什么" class="headerlink" title="Git是什么"></a>Git是什么</h5><blockquote>
<p>Git is a <a href="https://git-scm.com/about/free-and-open-source" target="_blank" rel="noopener">free and open source</a> distributed version control system designed to handle everything from small to very large projects with speed and efficiency. </p>
<p>Git是一个免费和开源的分布式版本控制系统，致力于高效和快速的处理任何小或者大的项目。</p>
</blockquote>
<a id="more"></a>

<h5 id="Git中的几个概念"><a href="#Git中的几个概念" class="headerlink" title="Git中的几个概念"></a>Git中的几个概念</h5><p><strong>工作区、暂存区、版本库</strong></p>
<ul>
<li>工作区：就是在电脑里能够看到的目录，存放项目的文件夹。</li>
<li>暂存区：是在版本库<code>.git</code>目录下的<code>index</code>文件，称为stage（或者叫index）的暂存区。</li>
<li>版本库：工作区有一个隐藏目录<code>.git</code>，就是Git的版本库，主要存放暂存区和分支，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</li>
</ul>
<p>三者的关系如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3mg3awoxj30cq06iaa8.jpg" alt=""></p>
<p><code>git add</code> 命令把文件修改从工作目录添加到暂存区，<code>git commit</code> 命令把暂存区的所有内容提交到版本库当前分支。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3mizv2xbj30yg0ktgn7.jpg" alt=""><center>Git的过程</center></p>
<h5 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h5><p>如果我们想看一下工作区和暂存区文件的状态，可以使用命令 <code>git status</code>，</p>
<ul>
<li><code>Changes to be committed</code>：暂存区的文件。</li>
<li><code>Changes not staged for commit</code>：工作区的文件，还未保存到暂存区。</li>
<li><code>Untracked files</code>：指那些第一次创建，还没有加入版本更新的文件。</li>
</ul>
<p>对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。</p>
<h5 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h5><p>分支是多人协作开发中必不可少的角色，因为在我们的开发过程中，至少会有两个分支：</p>
<ul>
<li>正式版本的分支：线上代码版本保存的分支，需要稳定的运行。</li>
<li>开发主线的分支：下个版本需求的开发分支。</li>
<li>Bug分支：修复Bug的分支。</li>
</ul>
<h4 id="二、基础命令"><a href="#二、基础命令" class="headerlink" title="二、基础命令"></a>二、基础命令</h4><h5 id="暂存区相关"><a href="#暂存区相关" class="headerlink" title="暂存区相关"></a>暂存区相关</h5><h6 id="添加进暂存区"><a href="#添加进暂存区" class="headerlink" title="添加进暂存区"></a>添加进暂存区</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add .       <span class="comment"># 添加全部文件</span></span><br><span class="line">$ git add &lt;file&gt;  <span class="comment"># 添加某个文件</span></span><br></pre></td></tr></table></figure>

<h6 id="撤销工作区的修改"><a href="#撤销工作区的修改" class="headerlink" title="撤销工作区的修改"></a>撤销工作区的修改</h6><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -- &lt;file&gt;  <span class="comment"># 把工作区指定文件的修改全部撤销</span></span><br></pre></td></tr></table></figure>

<p>这里有两种情况：</p>
<p>一种是<code>file</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>file</code>已经添加到暂存区后，又作了修改，现在撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<h6 id="撤销暂存区的修改"><a href="#撤销暂存区的修改" class="headerlink" title="撤销暂存区的修改"></a>撤销暂存区的修改</h6><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD &lt;file&gt;  <span class="comment"># 把暂存区的修改撤销掉（unstage），重新放回工作区</span></span><br></pre></td></tr></table></figure>

<h5 id="版本库相关"><a href="#版本库相关" class="headerlink" title="版本库相关"></a>版本库相关</h5><h6 id="提交到版本库"><a href="#提交到版本库" class="headerlink" title="提交到版本库"></a>提交到版本库</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m &lt;message&gt;  <span class="comment"># message描述提交信息</span></span><br></pre></td></tr></table></figure>

<h6 id="撤销提交"><a href="#撤销提交" class="headerlink" title="撤销提交"></a>撤销提交</h6><p>在没有上传到远程分支时，进行版本库的撤销。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD~1  <span class="comment"># HEAD 代表当前的头结点，HEAD~n 代表当前节点的前n个节点</span></span><br></pre></td></tr></table></figure>

<h6 id="查看改动"><a href="#查看改动" class="headerlink" title="查看改动"></a>查看改动</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff HEAD -- &lt;file&gt;  <span class="comment"># 比较当前工作区和上一个版本的差异</span></span><br></pre></td></tr></table></figure>

<h6 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h6><p>直接在文件管理器中把文件删了，或者执行<code>rm</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm file  <span class="comment"># 仅从工作区删除文件</span></span><br></pre></td></tr></table></figure>

<p>在Git中删除也是一个修改操作，要想从版本库中删除文件，需执行两步。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm &lt;file&gt;  <span class="comment"># 从工作区删除文件并add到了暂存区</span></span><br><span class="line">$ git commit -m <span class="string">'remove file'</span>  <span class="comment"># 提交到版本库中</span></span><br></pre></td></tr></table></figure>

<h5 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h5><h6 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch  <span class="comment"># 查看本地所有分支，*是当前分支</span></span><br></pre></td></tr></table></figure>

<h6 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch &lt;name&gt;  <span class="comment"># name 分支名</span></span><br></pre></td></tr></table></figure>

<p>在本地创建和远程分支对应的分支，本地和远程分支的名称最好一致，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b branch-name origin/branch-name</span><br></pre></td></tr></table></figure>

<h6 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout &lt;name&gt;  <span class="comment"># 切换到name分支 或者 git switch &lt;name&gt;</span></span><br><span class="line">$ git checkout -b &lt;name&gt; <span class="comment"># 创建并切换name分支 或者 git switch -c &lt;name&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h6><p>合并保留之前的提交顺序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge &lt;name&gt;  <span class="comment"># 合并分支name到当前分支</span></span><br></pre></td></tr></table></figure>

<p>得到的提交历史更加线性，看着更加简洁。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rebase &lt;name&gt;  <span class="comment"># 合并分支name到当前分支</span></span><br></pre></td></tr></table></figure>

<h6 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d &lt;name&gt; <span class="comment"># 删除name分支</span></span><br></pre></td></tr></table></figure>

<h4 id="三、远程命令"><a href="#三、远程命令" class="headerlink" title="三、远程命令"></a>三、远程命令</h4><h5 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h5><p>远程仓库的默认名称是<code>origin</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote -v  <span class="comment"># -v 查看详细信息</span></span><br></pre></td></tr></table></figure>

<h5 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h5><h6 id="拉取最新代码"><a href="#拉取最新代码" class="headerlink" title="拉取最新代码"></a>拉取最新代码</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull &lt;origin&gt; &lt;branch-name&gt;  <span class="comment"># origin是我们远程分支的别名</span></span><br></pre></td></tr></table></figure>

<h6 id="上传代码"><a href="#上传代码" class="headerlink" title="上传代码"></a>上传代码</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push &lt;origin&gt; &lt;branch-name&gt; <span class="comment"># 推送到指定分支</span></span><br></pre></td></tr></table></figure>

<p>在上面的更新/推送命令中，默认了远程仓库的分支和当前的分支名一致，比如 <code>git push origin master</code>，本地分支名和远程分支的名称都为 <code>master</code>，如果不一致，则需要给定名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push/pull &lt;origin&gt; &lt;本地分支:远程分支&gt;</span><br></pre></td></tr></table></figure>

<h5 id="进阶命令"><a href="#进阶命令" class="headerlink" title="进阶命令"></a>进阶命令</h5><h6 id="追加更新"><a href="#追加更新" class="headerlink" title="追加更新"></a>追加更新</h6><p>更新上次 commit 的代码，避免再次生成一个 commit 记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<h6 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h6><p>建立本地分支和远程分支的关联。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream branch-name origin/branch-name</span><br></pre></td></tr></table></figure>

<h6 id="上一个版本"><a href="#上一个版本" class="headerlink" title="上一个版本"></a>上一个版本</h6><p>指定当前版本的上一个版本，比如想在 <code>master</code> 分支上一个版本的基础上对代码进行修改，我可以输入 <code>git checkout -b bugfix master^</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HEAD^</span><br><span class="line">分支^</span><br><span class="line">Hash值^</span><br></pre></td></tr></table></figure>

<h6 id="工作现场暂存和恢复"><a href="#工作现场暂存和恢复" class="headerlink" title="工作现场暂存和恢复"></a>工作现场暂存和恢复</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash  <span class="comment"># 把当前工作现场“储藏”起来，等以后恢复现场后继续工作</span></span><br><span class="line">$ git stash pop  <span class="comment"># 恢复工作现场，同时把stash内容也删了</span></span><br></pre></td></tr></table></figure>

<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>
<h6 id="复制一个特定的提交到当前分支"><a href="#复制一个特定的提交到当前分支" class="headerlink" title="复制一个特定的提交到当前分支"></a>复制一个特定的提交到当前分支</h6><p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;commit&gt;  <span class="comment"># commit 某次提交</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Git命令暂时先学习这些，掌握了这些可以胜任平时的开发，对于一些复杂的命令，使用的时候再查。</p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://juejin.im/post/5a2cdfe26fb9a0452936b07f" target="_blank" rel="noopener">《🛠Git 常用操作总结》</a><br><a href="https://juejin.im/post/5ba3aad7f265da0a8e6d801c" target="_blank" rel="noopener">《关于Android Studio使用Git的总结》</a><br><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">《廖雪峰的Git教程》</a></p>
<p><a href="https://juejin.im/post/5f0281aaf265da230f2838ba#heading-30" target="_blank" rel="noopener">《团队协作Git入门指南》</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>BroadcastReceiver必备基础</title>
    <url>/2020/07/27/BroadcastReceiver%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android的四大组件之一的BroadcastReceiver。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是BroadcastReceiver"><a href="#一、什么是BroadcastReceiver" class="headerlink" title="一、什么是BroadcastReceiver"></a>一、什么是BroadcastReceiver</h4><p>广播是一种广泛运用的在应用程序之间传输信息的机制，<strong>BroadcastReceiver</strong> 主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。广播机制是一个典型的发布-订阅模式，就是观察者模式。</p>
<a id="more"></a>

<h4 id="二、广播的种类"><a href="#二、广播的种类" class="headerlink" title="二、广播的种类"></a>二、广播的种类</h4><h5 id="普通广播-Normal-Broadcast"><a href="#普通广播-Normal-Broadcast" class="headerlink" title="普通广播(Normal Broadcast)"></a>普通广播(Normal Broadcast)</h5><p>普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。同级别接收是先后是随机的；级别低的收到广播；消息传递的效率比较高，并且无法中断广播的传播。</p>
<h5 id="有序广播-Ordered-Broadcast"><a href="#有序广播-Ordered-Broadcast" class="headerlink" title="有序广播(Ordered Broadcast)"></a>有序广播(Ordered Broadcast)</h5><p>有序广播是一种同步执行的广播。在有序广播发出之后同一时刻只会有一个广播接收器能收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传播。</p>
<p>所有的广播接收器按照优先级顺序依次执行，优先级高的先执行，低的后执行。广播接收器的优先级通过清单文件中 receiver 标签下 <code>intent-filter</code> 中的 <code>android:priority</code> 属性来设置，数值越大优先级越高，数值越小优先级越低。</p>
<p>在广播传递的过程中可对广播进行中断操作，通过在 onReceiver() 方法中调用 abortBroadcast() 方法实现，这样后面的广播接收器就无法收到广播消息了。</p>
<h5 id="本地广播-Local-Broadcast"><a href="#本地广播-Local-Broadcast" class="headerlink" title="本地广播(Local Broadcast)"></a>本地广播(Local Broadcast)</h5><p>为了解决广播的安全性问题，Android引入了本地广播机制，该机制能够在应用内部进行传递，并且广播接收器也只能接收来自本应用发出的广播，安全性高和效率高。本地广播主要是一个 LocalBroadcastManager 对广播进行管理，并提供发送跟注册广播接收器的方法。</p>
<h5 id="粘性广播-Sticky-Broadcast"><a href="#粘性广播-Sticky-Broadcast" class="headerlink" title="粘性广播(Sticky Broadcast)"></a>粘性广播(Sticky Broadcast)</h5><p>指广播在发出后，还会保存在 AMS 中，在广播发出之后注册的广播接收器也能收到之前发送的该广播，该广播在 Android 5.0 被废弃。</p>
<h4 id="三、广播的使用"><a href="#三、广播的使用" class="headerlink" title="三、广播的使用"></a>三、广播的使用</h4><h5 id="创建BroadcastReceiver"><a href="#创建BroadcastReceiver" class="headerlink" title="创建BroadcastReceiver"></a>创建BroadcastReceiver</h5><p>需要继承 BroadcastReceiver 基类，并重写 onReceive() 方法来接收消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承BroadcastReceivre基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 复写onReceive()方法</span></span><br><span class="line">  <span class="comment">// 接收到广播后，则自动调用该方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//写入接收广播后的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注册BroadcastReceiver"><a href="#注册BroadcastReceiver" class="headerlink" title="注册BroadcastReceiver"></a>注册BroadcastReceiver</h5><ul>
<li><p><strong>静态注册</strong></p>
<p>在 AndroidManifest.xml 里通过 <code>&lt;receiver&gt;</code> 标签声明，并在标签内用 <code>&lt;intent-filter&gt;</code> 标签设置过滤器。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;application&gt;</span><br><span class="line"> &lt;receiver </span><br><span class="line">    <span class="comment">//是否可以被系统实例化</span></span><br><span class="line">    android:enabled=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">   <span class="comment">//此broadcastReceiver能否接收其他App的发出的广播</span></span><br><span class="line">   <span class="comment">//默认值是由receiver中有无intent-filter决定的：如果有intent-filter，默认值为true，否则为false</span></span><br><span class="line">    android:exported=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:icon=<span class="string">"drawable resource"</span></span><br><span class="line">    android:label=<span class="string">"string resource"</span></span><br><span class="line">   <span class="comment">//继承BroadcastReceiver子类的类名</span></span><br><span class="line">    android:name=<span class="string">".CustomBroadcastReceiver"</span></span><br><span class="line"> <span class="comment">//具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收；</span></span><br><span class="line">    android:permission=<span class="string">"string"</span></span><br><span class="line"><span class="comment">//BroadcastReceiver运行所处的进程</span></span><br><span class="line"><span class="comment">//默认为app的进程，可以指定独立的进程</span></span><br><span class="line"><span class="comment">//注：Android四大基本组件都可以通过此属性指定自己的独立进程</span></span><br><span class="line">    android:process=<span class="string">"string"</span> &gt;</span><br><span class="line"><span class="comment">//用于指定此广播接收器将接收的广播类型</span></span><br><span class="line">  &lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">"com.sample.custom.actionName"</span> /&gt;</span><br><span class="line">  &lt;/intent-filter&gt;</span><br><span class="line"> &lt;/receiver&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态注册</strong></p>
<p>在代码中调用<code>Context.registerReceiver()</code>方法注册，<code>unregisterReceiver()</code> 方法取消注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择在Activity生命周期方法中的onResume()中注册</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onResume();</span><br><span class="line">    <span class="comment">// 1. 实例化BroadcastReceiver子类 &amp;  IntentFilter</span></span><br><span class="line">     mBroadcastReceiver mBroadcastReceiver = <span class="keyword">new</span> CustomBroadcastReceiver();</span><br><span class="line">     IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    <span class="comment">// 2. 设置接收广播的类型</span></span><br><span class="line">    intentFilter.addAction(<span class="string">"CustomActionName"</span>);</span><br><span class="line">    <span class="comment">// 3. 动态注册：调用Context的registerReceiver（）方法</span></span><br><span class="line">     registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册广播后，要在相应位置记得销毁广播</span></span><br><span class="line"><span class="comment">// 即在onPause() 中unregisterReceiver(mBroadcastReceiver)</span></span><br><span class="line"><span class="comment">// 当此Activity销毁前，onPause方法一定会执行，所以在此方法中取消注册。</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onPause();</span><br><span class="line">      <span class="comment">//销毁在onResume()方法中的广播</span></span><br><span class="line">     unregisterReceiver(mBroadcastReceiver);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:red">两者区别：</span></p>
<p><strong>静态注册</strong>：常驻型，不受组件生命周期影响。静态注册是在应用安装的时候由系统 PMS（PackageManagerService）完成整个注册过程。</p>
<p><strong>动态注册</strong>：非常驻型，广播接收器跟随组件的生命周期变化，有注册就必然得有注销，否则会导致<strong>内存泄露</strong>。对 Activity 最好在 <code>onResume()</code> 注册，在 <code>onPause()</code> 注销。如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。动态注册由 ContextImpl 来实现的，会调到 AMS.registerReceiver() 注册。</p>
<p>当广播接收者通过 intent 启动一个 activity 或者 service 时，如果 intent 中无法匹配到相应的组件，动态注册的广播接收者将会导致应用报错，而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。</p>
</li>
</ul>
<h5 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h5><p><strong>发送普通广播</strong>：定义广播所具备的“意图 (<code>Intent</code>) ”，使用 <strong>Context.sendBroadcast()</strong> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line"><span class="comment">//对应BroadcastReceiver中intentFilter的action</span></span><br><span class="line">intent.setAction(BROADCAST_ACTION);</span><br><span class="line"><span class="comment">//适配7.0及以上静态注册的广播收不到，静态注册需发送显式广播，即给intent指定包名。若是动态注册的则不需要</span></span><br><span class="line"><span class="comment">//intent.setComponent(new ComponentName(getPackageName(),getPackageName()+".CustomBroadcastReceiver"));</span></span><br><span class="line"><span class="comment">//发送广播</span></span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p><strong>发送有序广播</strong>：<strong>Context.sendOrderedBroadcast()</strong>，该方法接收两个参数，Intent &amp; 权限相关的字符串，无特殊要求可置为null。</p>
<p><strong>发送本地广播</strong>：使用 <strong>LocalBroadcastManager</strong> 类的 sendBroadcast()、registerReceiver()、unregisterReceiver()等方法，用于应用内部传递消息。对于LocalBroadcastManager方式发送的应用内广播，只能通过LocalBroadcastManager动态注册，不能静态注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册应用内广播接收器</span></span><br><span class="line"><span class="comment">//步骤1：实例化BroadcastReceiver子类 &amp; IntentFilter mBroadcastReceiver </span></span><br><span class="line">mBroadcastReceiver = <span class="keyword">new</span> CustomBroadcastReceiver(); </span><br><span class="line">IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter(); </span><br><span class="line"><span class="comment">//步骤2：实例化LocalBroadcastManager的实例</span></span><br><span class="line">localBroadcastManager = LocalBroadcastManager.getInstance(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//步骤3：设置接收广播的类型 </span></span><br><span class="line">intentFilter.addAction(BROADCAST_ACTION);</span><br><span class="line"><span class="comment">//步骤4：调用LocalBroadcastManager单一实例的registerReceiver（）方法进行动态注册 </span></span><br><span class="line">localBroadcastManager.registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line"><span class="comment">//取消注册应用内广播接收器</span></span><br><span class="line">localBroadcastManager.unregisterReceiver(mBroadcastReceiver);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送应用内广播</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(BROADCAST_ACTION);</span><br><span class="line"><span class="comment">//适配7.0及以上静态注册的广播收不到，静态注册需发送显式广播，即给intent指定包名。若是动态注册的则不需要</span></span><br><span class="line"><span class="comment">//intent.setComponent(new ComponentName(getPackageName(),getPackageName()+".CustomBroadcastReceiver"));</span></span><br><span class="line">localBroadcastManager.sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<h4 id="四、广播发送和接收原理"><a href="#四、广播发送和接收原理" class="headerlink" title="四、广播发送和接收原理"></a>四、广播发送和接收原理</h4><p>广播队列传送广播给 Receiver 的原理其实就是将 BroadcastReceiver 和消息都放到 BroadcastRecord 里面,然后通过 Handler 机制遍历 BroadcastQueue 里面的 BroadcastRecord，将消息发送给 BroadcastReceiver。详细细节可参考：<a href="https://www.jianshu.com/p/02085150339c" target="_blank" rel="noopener">广播的底层实现原理</a></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghb614kgilj30ng07edg2.jpg" alt=""></p>
<p>整个广播的机制可以总结成下面这张图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghb5zyxep8j30g00aqaa4.jpg" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>使用注意</strong>：</p>
<p> 当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过 action 匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，运行在 <code>UI</code> 线程，执行其中的 onReceiver() 方法，这个实例的生命周期只有10秒，10秒内没有执行结束 onReceiver() 系统将会导致 ANR ；<br>    在 onReceiver() 执行完毕之后，该实例将会被销毁，所以不要在 onReceiver() 中执行耗时操作，也不要在里面创建子线程处理业务（可能子线程没处理完，接收者就被回收了，子线程也会跟着被回收掉）；正确的处理方法就是通过 intent 调用 Activity 或者 Service 处理业务。</p>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://blog.csdn.net/xubinjie517/article/details/90239812#Sticky_Broadcast_38" target="_blank" rel="noopener">Android开发之BroadcastReceiver</a></p>
<p><a href="https://www.jianshu.com/p/ca3d87a4cdf3" target="_blank" rel="noopener">BroadcastReceiver史上最全面解析</a></p>
<p><a href="https://www.jianshu.com/p/02085150339c" target="_blank" rel="noopener">广播的底层实现原理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Fragment必备基础</title>
    <url>/2020/07/31/Fragment%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android常用的组件之一的Fragment。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是Fragment"><a href="#一、什么是Fragment" class="headerlink" title="一、什么是Fragment"></a>一、什么是Fragment</h4><p>Fragment，简称碎片，是 Android最基本，最重要的基础概念之一。Fragment 官方的定义是：</p>
<blockquote>
<p>A Fragment represents a behavior or a portion of user interface in an Activity. You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activities. You can think of a fragment as a modular section of an activity, which has its own lifecycle, receives its own input events, and which you can add or remove while the activity is running.</p>
</blockquote>
<a id="more"></a>

<ul>
<li>Fragment 是依赖于 Activity 的，不能独立存在的。</li>
<li>一个 Activity 里可以有多个 Fragment 。</li>
<li>一个 Fragment 可以被多个 Activity 重用。</li>
<li>Fragment 有自己的生命周期，并能接收输入事件。</li>
<li>我们能在 Activity 运行时动态地添加或删除 Fragment 。</li>
</ul>
<p><strong>Fragment 的优势有以下几点：</strong></p>
<ul>
<li><strong>模块化(Modularity)</strong>：我们不必把所有代码全部写在Activity中，而是把代码写在各自的Fragment中。</li>
<li><strong>可重用(Reusability)</strong>：多个Activity可以重用一个Fragment。</li>
<li><strong>可适配(Adaptability)</strong>：根据硬件的屏幕尺寸、屏幕方向，能够方便地实现不同的布局，这样用户体验更好。</li>
</ul>
<p><strong>Fragment核心的类有：</strong></p>
<ul>
<li><strong>Fragment</strong>：Fragment 的基类，任何创建的 Fragment 都需要继承该类。</li>
<li><strong>FragmentManager</strong>：管理和维护 Fragment。它是抽象类，具体的实现类是 <strong>FragmentManagerImpl</strong>。</li>
<li><strong>FragmentTransaction</strong>：对 Fragment 的添加、删除等操作都需要通过事务方式进行。它是抽象类，具体的实现类是 <strong>BackStackRecord</strong>。</li>
</ul>
<h4 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h4><p>Fragment的生命周期和Activity类似，但比Activity的生命周期复杂一些，基本的生命周期方法如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghguz2jnu5j30b409uq34.jpg" alt=""></p>
<ul>
<li><strong>onAttach</strong>：Fragment 和 Activity 相关联时调用。可以通过该方法获取 Activity 引用，还可以通过getArguments() 获取参数。</li>
<li><strong>onCreate</strong>：Fragment 被创建时调用。</li>
<li><strong>onCreateView</strong>：创建 Fragment 的布局。</li>
<li><strong>onActivityCreated</strong>：当 Activity 完成 onCreate() 时调用，在 onCreateView() 方法之后调用该方法。</li>
<li><strong>onStart</strong>：当 Fragment 开始可见时调用，此时还不可交互。</li>
<li><strong>onResume</strong>：当 Fragment 可见且可交互时调用。</li>
<li><strong>onPause</strong>：当 Fragment 不可交互但可见时调用，表明用户将要离开当前 Fragment 。</li>
<li><strong>onStop</strong>：当 Fragment 不可见时调用，Fragment 被停止。</li>
<li><strong>onDestroyView</strong>：当 Fragment 的 UI 从视图结构中移除时调用，销毁与 Fragment 有关的视图。</li>
<li><strong>onDestroy</strong>：销毁 Fragment 时调用。</li>
<li><strong>onDetach</strong>：当 Fragment 和 Activity 解除关联时调用。</li>
</ul>
<p>当一个 fragment 被创建的时候，需调用以下生命周期方法：onAttach(), onCreate(), onCreateView(), onActivityCreated()；</p>
<p>当这个 fragment 对用户可见可交互的时候，需调用：onStart() ,onResume()；</p>
<p>当这个 fragment 对用户不可交互不可见，进入后台模式需调用：onPause(),onStop()；</p>
<p>当这个 fragment 被销毁或者是持有它的 Activity 被销毁了，调用：onPause() ,onStop(), onDestroyView(), onDestroy(),onDetach()。</p>
<p>因为 Fragment 是依赖 Activity 的，Fragment 和 Activity 的生命周期方法有密切的关系和顺序，如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghgwq0ptw2j30hs0l4jsp.jpg" alt=""></p>
<p>举例来理解Fragment生命周期方法，共有两个Fragment：F1和F2，F1在初始化时就加入Activity，点击F1中的按钮调用replace替换为F2。</p>
<p>当F1在Activity的<code>onCreate()</code>中被添加时，日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BasicActivity: [onCreate] BEGIN</span><br><span class="line">BasicActivity: [onCreate] END</span><br><span class="line">BasicActivity: [onStart] BEGIN</span><br><span class="line">Fragment1: [onAttach] BEGIN </span><br><span class="line">Fragment1: [onAttach] END</span><br><span class="line">BasicActivity: [onAttachFragment] BEGIN</span><br><span class="line">BasicActivity: [onAttachFragment] END</span><br><span class="line">Fragment1: [onCreate] BEGIN</span><br><span class="line">Fragment1: [onCreate] END</span><br><span class="line">Fragment1: [onCreateView]</span><br><span class="line">Fragment1: [onViewCreated] BEGIN</span><br><span class="line">Fragment1: [onViewCreated] END</span><br><span class="line">Fragment1: [onActivityCreated] BEGIN</span><br><span class="line">Fragment1: [onActivityCreated] END</span><br><span class="line">Fragment1: [onStart] BEGIN</span><br><span class="line">Fragment1: [onStart] END</span><br><span class="line">BasicActivity: [onStart] END</span><br><span class="line">BasicActivity: [onPostCreate] BEGIN</span><br><span class="line">BasicActivity: [onPostCreate] END</span><br><span class="line">BasicActivity: [onResume] BEGIN</span><br><span class="line">BasicActivity: [onResume] END</span><br><span class="line">BasicActivity: [onPostResume] BEGIN</span><br><span class="line">Fragment1: [onResume] BEGIN</span><br><span class="line">Fragment1: [onResume] END</span><br><span class="line">BasicActivity: [onPostResume] END</span><br><span class="line">BasicActivity: [onAttachedToWindow] BEGIN</span><br><span class="line">BasicActivity: [onAttachedToWindow] END</span><br></pre></td></tr></table></figure>

<p>从上图可以看出：</p>
<ul>
<li><p>Fragment 的 onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()都是在 Activity 的 onStart() 中调用的。</p>
</li>
<li><p>Fragment 的 onResume() 在 Activity 的 onResume() 之后调用。</p>
</li>
</ul>
<p>当点击F1的按钮，调用<code>replace()</code>替换为F2，且不加<code>addToBackStack()</code>时，日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Fragment2: [onAttach] BEGIN</span><br><span class="line">Fragment2: [onAttach] END</span><br><span class="line">BasicActivity: [onAttachFragment] BEGIN</span><br><span class="line">BasicActivity: [onAttachFragment] END</span><br><span class="line">Fragment2: [onCreate] BEGIN</span><br><span class="line">Fragment2: [onCreate] END</span><br><span class="line">Fragment1: [onPause] BEGIN</span><br><span class="line">Fragment1: [onPause] END</span><br><span class="line">Fragment1: [onStop] BEGIN</span><br><span class="line">Fragment1: [onStop] END</span><br><span class="line">Fragment1: [onDestroyView] BEGIN</span><br><span class="line">Fragment1: [onDestroyView] END</span><br><span class="line">Fragment1: [onDestroy] BEGIN</span><br><span class="line">Fragment1: [onDestroy] END</span><br><span class="line">Fragment1: [onDetach] BEGIN</span><br><span class="line">Fragment1: [onDetach] END</span><br><span class="line">Fragment2: [onCreateView]</span><br><span class="line">Fragment2: [onViewCreated] BEGIN</span><br><span class="line">Fragment2: [onViewCreated] END</span><br><span class="line">Fragment2: [onActivityCreated] BEGIN</span><br><span class="line">Fragment2: [onActivityCreated] END</span><br><span class="line">Fragment2: [onStart] BEGIN</span><br><span class="line">Fragment2: [onStart] END</span><br><span class="line">Fragment2: [onResume] BEGIN</span><br><span class="line">Fragment2: [onResume] END</span><br></pre></td></tr></table></figure>

<p>可以看到，F1最后调用了<code>onDestroy()</code>和<code>onDetach()</code>。</p>
<p>当点击F1的按钮，调用<code>replace()</code>替换为F2，且加<code>addToBackStack()</code>时，日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Fragment2: [onAttach] BEGIN</span><br><span class="line">Fragment2: [onAttach] END</span><br><span class="line">BasicActivity: [onAttachFragment] BEGIN</span><br><span class="line">BasicActivity: [onAttachFragment] END</span><br><span class="line">Fragment2: [onCreate] BEGIN</span><br><span class="line">Fragment2: [onCreate] END</span><br><span class="line">Fragment1: [onPause] BEGIN</span><br><span class="line">Fragment1: [onPause] END</span><br><span class="line">Fragment1: [onStop] BEGIN</span><br><span class="line">Fragment1: [onStop] END</span><br><span class="line">Fragment1: [onDestroyView] BEGIN</span><br><span class="line">Fragment1: [onDestroyView] END</span><br><span class="line">Fragment2: [onCreateView]</span><br><span class="line">Fragment2: [onViewCreated] BEGIN</span><br><span class="line">Fragment2: [onViewCreated] END</span><br><span class="line">Fragment2: [onActivityCreated] BEGIN</span><br><span class="line">Fragment2: [onActivityCreated] END</span><br><span class="line">Fragment2: [onStart] BEGIN</span><br><span class="line">Fragment2: [onStart] END</span><br><span class="line">Fragment2: [onResume] BEGIN</span><br><span class="line">Fragment2: [onResume] END</span><br></pre></td></tr></table></figure>

<p>可以看到，F1被替换时，最后只调到了<code>onDestroyView()</code>，并没有调用<code>onDestroy()</code>和<code>onDetach()</code>。当用户点返回按钮回退事务时，F1会调 onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume()，因此在 Fragment 事务中加不加<code>addToBackStack()</code>会影响 Fragment 的生命周期。</p>
<p>FragmentTransaction 有一些基本方法，下面给出调用这些方法时，Fragment 生命周期的变化：</p>
<ul>
<li>add(): onAttach()-&gt;…-&gt;onResume()，添加进来的 fragment 都是可见的，不能重复添加同一 fragment，切换 fragment 时，不销毁当前的，创建新的，不会重新创建，一般配合 hide 或 remove 使用。</li>
<li>remove(): onPause()-&gt;…-&gt;onDetach()，销毁 fragment 。</li>
<li>replace(): 相当于旧 Fragment 调用remove()，新 Fragment 调用 add()，切换 fragment 时每次都会销毁当前的，创建新的，会重新创建初始化。和 add() 区别：<strong>是否要销毁当前fragment清空容器再添加新fragment</strong></li>
<li>show(): 不调用任何生命周期方法，调用该方法的前提是要显示的 Fragment 已经被添加到容器，只是纯粹把 Fragment UI 的 setVisibility 为 true。</li>
<li>hide(): 不调用任何生命周期方法，调用该方法的前提是要显示的 Fragment 已经被添加到容器，只是纯粹把Fragment UI的setVisibility为false。</li>
<li>detach(): onPause()-&gt;onStop()-&gt;onDestroyView()。UI从布局中移除，但是仍然被 FragmentManager 管理。</li>
<li>attach(): onCreateView()-&gt;onStart()-&gt;onResume()。</li>
</ul>
<h4 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h4><h5 id="创建-Fragment"><a href="#创建-Fragment" class="headerlink" title="创建 Fragment"></a>创建 Fragment</h5><p>首先创建继承 Fragment 的类，名为Fragment1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment1</span> <span class="keyword">extends</span> <span class="title">Fragment</span></span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String ARG_PARAM = <span class="string">"param_key"</span>; </span><br><span class="line">     <span class="keyword">private</span> String mParam; </span><br><span class="line">     <span class="keyword">private</span> Activity mActivity; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mActivity = (Activity) context;</span><br><span class="line">        mParam = getArguments().getString(ARG_PARAM);  <span class="comment">//获取参数</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View root = inflater.inflate(R.layout.fragment_1, container, <span class="keyword">false</span>);</span><br><span class="line">        TextView view = root.findViewById(R.id.text);</span><br><span class="line">        view.setText(mParam);</span><br><span class="line">             <span class="keyword">return</span> root;</span><br><span class="line">    &#125;    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fragment1 <span class="title">newInstance</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Fragment1 frag = <span class="keyword">new</span> Fragment1();</span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.putString(ARG_PARAM, str);</span><br><span class="line">        fragment.setArguments(bundle);   <span class="comment">//设置参数</span></span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fragment 有很多可以复写的方法，其中最常用的就是<code>onCreateView()</code>，该方法返回 Fragment 的UI布局，需要注意的是<code>inflate()</code>的第三个参数是 <strong>false</strong> ，因为在 Fragment 内部实现中，会把该布局添加到 container 中，如果设为 true，那么就会重复做两次添加，则会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: The specified child already has a parent. <span class="function">You must call <span class="title">removeView</span><span class="params">()</span> on the child's parent first.</span></span><br></pre></td></tr></table></figure>

<p>如果在创建Fragment时要传入参数，必须要通过<code>setArguments(Bundle bundle)</code>方式添加，而不建议通过为Fragment 添加带参数的构造函数，因为通过<code>setArguments()</code>方式添加，在由于内存紧张导致Fragment被系统杀掉并恢复（re-instantiate）时能保留这些数据。官方建议如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">It is strongly recommended that subclasses <span class="keyword">do</span> not have other constructors with parameters, since these constructors will not be called when the fragment is re-instantiated.</span><br></pre></td></tr></table></figure>

<p>我们可以在 Fragment 的<code>onAttach()</code>中通过<code>getArguments()</code>获得传进来的参数，并在之后使用这些参数。如果要获取 Activity 对象，不建议调用<code>getActivity()</code>，而是在<code>onAttach()</code>中将 Context 对象强转为 Activity 对象。</p>
<h5 id="添加Fragment到Activity"><a href="#添加Fragment到Activity" class="headerlink" title="添加Fragment到Activity"></a>添加Fragment到Activity</h5><ul>
<li><p><strong>静态添加</strong>：通过 <code>&lt;fragment&gt;</code> 标签的形式添加到 Activity 的布局 xml 当中，缺点是一旦添加就不能在运行时删除。</p>
</li>
<li><p><strong>动态添加</strong>：通过 java 代码将 fragment 添加到宿主 Activity 中，这种方式比较灵活，常用这种方式。</p>
</li>
</ul>
<p>这里只给出动态添加的方式。首先Activity需要有一个容器存放 Fragment ，一般是 FrameLayout，因此在Activity 的布局文件中加入 FrameLayout：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;FrameLayout</span><br><span class="line">    android:id=<span class="string">"@+id/container"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>然后在<code>onCreate()</code>中，通过以下代码将 Fragment 添加进 Activity 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bundle == <span class="keyword">null</span>) &#123;</span><br><span class="line">    getSupportFragmentManager().beginTransaction()</span><br><span class="line">        .add(R.id.container, Fragment1.newInstance(<span class="string">"hello world"</span>),<span class="string">"f1"</span>)</span><br><span class="line">      <span class="comment">//.addToBackStack("fname")</span></span><br><span class="line">        .commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意几点：</p>
<ul>
<li>使用<code>getSupportFragmentManager()</code>获取 FragmentManager。</li>
<li><code>add()</code>是对 Fragment 众多操作中的一种，还有<code>remove()</code>, <code>replace()</code>等，第一个参数是根容器的id（FrameLayout的id，即”@id/container”），第二个参数是 Fragment 对象，第三个参数是 fragment 的 tag 名，指定 tag 的好处是后续我们可以通过<code>Fragment1 frag = getSupportFragmentManager().findFragmentByTag(&quot;f1&quot;)</code>从 FragmentManager 中查找 Fragment 对象。</li>
<li>在一次事务中，可以做多个操作，比如同时做<code>add().remove().replace()</code>。</li>
<li><code>commit()</code>操作是异步的，内部通过<code>mManager.enqueueAction()</code>加入处理队列。对应的同步方法为<code>commitNow()</code>，<code>commit()</code>内部会有<code>checkStateLoss()</code>操作，如果开发人员使用不当（比如<code>commit()</code>操作在<code>onSaveInstanceState()</code>之后），可能会抛出异常，而<code>commitAllowingStateLoss()</code>方法则是不会抛出异常版本的<code>commit()</code>方法，但是尽量使用<code>commit()</code>，而不要使用<code>commitAllowingStateLoss()</code>。</li>
<li><code>addToBackStack(&quot;fname&quot;)</code>是可选的。FragmentManager 拥有回退栈（BackStack），类似于 Activity 的任务栈，如果添加了该语句，就把该事务加入回退栈，当用户点击返回按钮，会回退该事务（回退指的是如果事务是<code>add(frag1)</code>，那么回退操作就是<code>remove(frag1)</code>）；如果没添加该语句，用户点击返回按钮会直接销毁Activity。</li>
<li>Fragment 有一个常见的问题，即 Fragment 重叠问题，这是由于页面发生销毁重建(旋转屏幕、内存不足等情况被强杀重启)回到前台，重新初始化时，再次将 fragment 加入 activity，而 FragmentActivity 帮我们保存了 Fragment 的状态，并且在页面重启后会帮我们恢复，因此可在Activity的<code>onCreate()</code>里加上页面是否是重启的判断<code>if(saveInstanceState == null){}</code>。</li>
</ul>
<p><strong>Fragment有个常见的异常：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalStateException: Can not perform <span class="keyword">this</span> action after onSaveInstanceState</span><br><span class="line">    at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:<span class="number">1341</span>)</span><br><span class="line">    at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:<span class="number">1352</span>)</span><br><span class="line">    at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:<span class="number">595</span>)</span><br><span class="line">    at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:<span class="number">574</span>)</span><br></pre></td></tr></table></figure>

<p>该异常出现的原因是：commit() 在 onSaveInstanceState() 后调用。首先，onSaveInstanceState() 是在 Activity 有可能被系统回收的异常终止情况下，而且是在 onPause() 之后，onStop() 之前调用。onRestoreInstanceState() 在onStart() 之后，onResume() 之前。</p>
<p><strong>因此避免出现该异常的方案有：</strong></p>
<ul>
<li>不要把 Fragment 事务放在异步线程的回调中，比如不要把 Fragment 事务放在 AsyncTask 的onPostExecute()，因此 onPostExecute() 可能会在 onSaveInstanceState() 之后执行。</li>
<li>逼不得已时使用 commitAllowingStateLoss()，允许丢失一些界面的状态和信息。</li>
</ul>
<h4 id="四、Fragment实现原理和Back-Stack"><a href="#四、Fragment实现原理和Back-Stack" class="headerlink" title="四、Fragment实现原理和Back Stack"></a>四、Fragment实现原理和Back Stack</h4><p>我们知道 Activity 有任务栈，用户通过 startActivity 将 Activity 加入栈，点击返回按钮将 Activity 出栈。Fragment 也有类似的栈，称为回退栈（Back Stack），回退栈是由 FragmentManager 管理的。默认情况下，Fragment 事务是不会加入回退栈的，如果想将 Fragment 事务加入回退栈，则可以加入<code>addToBackStack(&quot;&quot;)</code>。如果没有加入回退栈，则用户点击返回按钮会直接将 Activity 出栈；如果加入了回退栈，则用户点击返回按钮会回滚 Fragment 事务。</p>
<p>我们将通过最常见的 Fragment 用法，讲解 Back Stack 的实现原理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getSupportFragmentManager().beginTransaction()</span><br><span class="line">    .add(R.id.container, f1, <span class="string">"f1"</span>)</span><br><span class="line">    .addToBackStack(<span class="string">""</span>)</span><br><span class="line">    .commit();</span><br></pre></td></tr></table></figure>

<p>上面这个代码的功能就是将 Fragment 加入 Activity 中，内部实现为：创建一个 BackStackRecord 对象，该对象记录了这个事务的全部操作轨迹（这里只做了一次 add 操作，并且加入回退栈），随后将该对象提交到 FragmentManager 的执行队列中，等待执行。</p>
<p>BackStackRecord 类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//androidx之前</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BackStackRecord</span> <span class="keyword">extends</span> <span class="title">FragmentTransaction</span> <span class="keyword">implements</span> <span class="title">FragmentManager</span>.<span class="title">BackStackEntry</span>, <span class="title">Runnable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// androidx之后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BackStackRecord</span> <span class="keyword">extends</span> <span class="title">FragmentTransaction</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">FragmentManager</span>.<span class="title">BackStackEntry</span>, <span class="title">FragmentManagerImpl</span>.<span class="title">OpGenerator</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>从定义可以看出，BackStackRecord 有三重含义：</p>
<ul>
<li>继承了 FragmentTransaction，即是事务，保存了整个事务的全部操作轨迹。</li>
<li>实现了 BackStackEntry，作为回退栈的元素，正是因为该类拥有事务全部的操作轨迹，因此在popBackStack() 时能回退整个事务。</li>
<li>继承了 Runnable，即被放入 FragmentManager 执行队列，等待被执行。</li>
</ul>
<p>先看第一层含义，<code>getSupportFragmentManager.beginTransaction()</code>返回的就是 BackStackRecord 对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">beginTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BackStackRecord(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>BackStackRecord 类包含了一次事务的整个操作轨迹，是以链表形式存在的，链表的元素是 Op 类，androidx 之后是保存在一个<code>ArrayList&lt;Op&gt; mOps = new ArrayList&lt;&gt;()</code>中，表示其中某个操作，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//androidx之前</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Op</span> </span>&#123;</span><br><span class="line">    Op next; <span class="comment">//链表后一个节点</span></span><br><span class="line">    Op prev; <span class="comment">//链表前一个节点</span></span><br><span class="line">    <span class="keyword">int</span> cmd;  <span class="comment">//操作是add或remove或replace或hide或show等</span></span><br><span class="line">    Fragment fragment; <span class="comment">//对哪个Fragment对象做操作</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// androidx之后</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Op</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mCmd;</span><br><span class="line">        Fragment mFragment;</span><br><span class="line">        <span class="keyword">int</span> mEnterAnim;</span><br><span class="line">        <span class="keyword">int</span> mExitAnim;</span><br><span class="line">        <span class="keyword">int</span> mPopEnterAnim;</span><br><span class="line">        <span class="keyword">int</span> mPopExitAnim;</span><br><span class="line">        Lifecycle.State mOldMaxState;</span><br><span class="line">        Lifecycle.State mCurrentMaxState;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下具体场景下这些类是怎么被使用的，比如我们的事务做add操作。add 函数的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">add</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag)</span> </span>&#123;</span><br><span class="line">   doAddOp(containerViewId, fragment, tag, OP_ADD);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>doAddOp()</code>方法就是创建 Op 对象，并加入链表，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAddOp</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag, <span class="keyword">int</span> opcmd)</span> </span>&#123;</span><br><span class="line">    fragment.mTag = tag;  <span class="comment">//设置fragment的tag</span></span><br><span class="line">    fragment.mContainerId = fragment.mFragmentId = containerViewId;  <span class="comment">//设置fragment的容器id</span></span><br><span class="line">    Op op = <span class="keyword">new</span> Op();</span><br><span class="line">    op.cmd = opcmd;</span><br><span class="line">    op.fragment = fragment;</span><br><span class="line">    addOp(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addOp() 是将创建好的 Op 对象加入链表，androidx 则加到列表，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOp</span><span class="params">(Op op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mHead = mTail = op;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        op.prev = mTail;</span><br><span class="line">        mTail.next = op;</span><br><span class="line">        mTail = op;</span><br><span class="line">    &#125;</span><br><span class="line">    mNumOp++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//androidx</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">addOp</span><span class="params">(Op op)</span> </span>&#123;</span><br><span class="line">        mOps.add(op);</span><br><span class="line">        op.mEnterAnim = mEnterAnim;</span><br><span class="line">        op.mExitAnim = mExitAnim;</span><br><span class="line">        op.mPopEnterAnim = mPopEnterAnim;</span><br><span class="line">        op.mPopExitAnim = mPopExitAnim;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>addToBackStack(“”)</code>是将 mAddToBackStack 变量记为 true，在 <code>commit()</code> 中会用到该变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">addToBackStack</span><span class="params">(@Nullable String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!mAllowAddToBackStack) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                   <span class="string">"This FragmentTransaction is not allowed to be added to the back stack."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       mAddToBackStack = <span class="keyword">true</span>;</span><br><span class="line">       mName = name;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>commit()</code>是异步的，即不是立即生效的，但是后面会看到整个过程还是在主线程完成，只是把事务的执行扔给主线程的 Handler，<code>commit()</code>内部是<code>commitInternal()</code>，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">commitInternal</span><span class="params">(<span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">    mCommitted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">        mIndex = mManager.allocBackStackIndex(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mIndex = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mManager.enqueueAction(<span class="keyword">this</span>, allowStateLoss); <span class="comment">//将事务添加进待执行队列中</span></span><br><span class="line">    <span class="keyword">return</span> mIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 mAddToBackStack 为 true，则调用<code>allocBackStackIndex(this)</code>将事务添加进回退栈，FragmentManager 类的变量 mBackStackIndices 就是回退栈。实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">allocBackStackIndex</span><span class="params">(BackStackRecord bse)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBackStackIndices == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mBackStackIndices = <span class="keyword">new</span> ArrayList&lt;BackStackRecord&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = mBackStackIndices.size();</span><br><span class="line">    mBackStackIndices.add(bse);</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>commitInternal()</code>中，<code>mManager.enqueueAction(this, allowStateLoss);</code>是将 BackStackRecord 加入待执行队列中，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueAction</span><span class="params">(Runnable action, <span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPendingActions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPendingActions = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingActions.add(action);</span><br><span class="line">    <span class="keyword">if</span> (mPendingActions.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        mHost.getHandler().removeCallbacks(mExecCommit);</span><br><span class="line">        mHost.getHandler().post(mExecCommit); <span class="comment">//调用execPendingActions()执行待执行队列的事务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mPendingActions 就是前面说的待执行队列，<code>mHost.getHandler()</code>就是主线程的Handler，因此 Runnable 是在主线程执行的，mExecCommit 的内部就是调用了<code>execPendingActions()</code>，即把 mPendingActions 中所有积压的没被执行的事务全部执行。执行队列中的事务会怎样被执行呢？就是调用<code>BackStackRecord的run()</code>方法，<code>run()</code>方法就是执行 Fragment 的生命周期函数，还有将视图添加进 container 中。</p>
<p>与<code>addToBackStack()</code>对应的是<code>popBackStack()</code>，有以下几种变种：</p>
<ul>
<li>popBackStack()：将回退栈的栈顶弹出，并回退该事务。</li>
<li>popBackStack(String name, int flag)：name 为 addToBackStack(String name) 的参数，通过 name 能找到回退栈的特定元素，flag 可以为0或者 FragmentManager.POP_BACK_STACK_INCLUSIVE ，0表示只弹出该元素以上的所有元素，POP_BACK_STACK_INCLUSIVE 表示弹出包含该元素及以上的所有元素。这里说的弹出所有元素包含回退这些事务。</li>
<li>popBackStack() 是异步执行的，是丢到主线程的 MessageQueue 执行，popBackStackImmediate() 是同步版本。</li>
</ul>
<p><code>getSupportFragmentManager().findFragmentByTag()</code>是经常用到的方法，是 FragmentManager 的方法，FragmentManager是抽象类，FragmentManagerImpl 是继承 FragmentManager 的实现类，他的内部实现是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FragmentManagerImpl</span> <span class="keyword">extends</span> <span class="title">FragmentManager</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Fragment&gt; mActive;</span><br><span class="line">    ArrayList&lt;Fragment&gt; mAdded;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">findFragmentByTag</span><span class="params">(String tag)</span> </span>&#123; </span><br><span class="line">           <span class="keyword">if</span> (mAdded != <span class="keyword">null</span> &amp;&amp; tag != <span class="keyword">null</span>) &#123; </span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i=mAdded.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                Fragment f = mAdded.get(i);</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">null</span> &amp;&amp; tag.equals(f.mTag)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> f;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">          <span class="keyword">if</span> (mActive != <span class="keyword">null</span> &amp;&amp; tag != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i=mActive.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                    Fragment f = mActive.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (f != <span class="keyword">null</span> &amp;&amp; tag.equals(f.mTag)) &#123;</span><br><span class="line">                          <span class="keyword">return</span> f;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面看到，先从 mAdded 中查找是否有该 Fragment，如果没找到，再从 mActive 中查找是否有该 Fragment。mAdded 是已经添加到 Activity 的 Fragment 的集合，mActive 不仅包含 mAdded，还包含虽然不在 Activity 中，但还在回退栈中的 Fragment。</p>
<h4 id="五、Fragment通信"><a href="#五、Fragment通信" class="headerlink" title="五、Fragment通信"></a>五、Fragment通信</h4><h5 id="Fragment向Activity传递数据"><a href="#Fragment向Activity传递数据" class="headerlink" title="Fragment向Activity传递数据"></a>Fragment向Activity传递数据</h5><p>首先，在 Fragment 中定义接口，并让 Activity 实现该接口（具体实现省略）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnFragmentInteractionListener</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(String str)</span></span>;  <span class="comment">//将str从Fragment传递给Activity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Fragment 的 onAttach() 中，将参数 Context 强转为 OnFragmentInteractionListener 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onAttach(context);</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> OnFragmentInteractionListener) &#123;</span><br><span class="line">        mListener = (OnFragmentInteractionListener) context;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(context.toString()</span><br><span class="line">                + <span class="string">" must implement OnFragmentInteractionListener"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在 Fragment 合适的地方调用<code>mListener.onItemClick(&quot;hello&quot;)</code>将”hello”从 Fragment 传递给 Activity。</p>
<h5 id="Activity向Fragment传递数据"><a href="#Activity向Fragment传递数据" class="headerlink" title="Activity向Fragment传递数据"></a>Activity向Fragment传递数据</h5><p>在 Fragment 初次创建时可通过 <code>fragment.setArguments(bundle)</code> 方法传递数据，其他时候，可以获取Fragment 对象，并调用 Fragment 的方法即可，比如要将一个字符串传递给 Fragment，则在 Fragment 中定义方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setString</span><span class="params">(String str)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.str = str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在 Activity 中调用<code>fragment.setString(&quot;hello&quot;)</code>即可。</p>
<h5 id="Fragment之间通信"><a href="#Fragment之间通信" class="headerlink" title="Fragment之间通信"></a>Fragment之间通信</h5><p>由于 Fragment 之间是没有任何依赖关系的，因此如果要进行 Fragment 之间的通信，建议通过 Activity 作为中介，不要 Fragment 之间直接通信。</p>
<h4 id="六、Fragment中的onActivityResult"><a href="#六、Fragment中的onActivityResult" class="headerlink" title="六、Fragment中的onActivityResult"></a>六、Fragment中的onActivityResult</h4><p>假设有一个 FragmentActivity 中嵌套一个 Fragment，它们各自使用 startActivityForResult 发起数据请求。<br>经测，目标所返回结果数据，能否被它们各自的 onActivityResult 方法所接收的情况如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghi3kbnbqwj30ks02tjrj.jpg" alt=""></p>
<ul>
<li>Fragment 和 FragmentActivity 都能接收到自己的发起的请求所返回的结果</li>
<li>FragmentActivity 发起的请求，Fragment 完全接收不到结果</li>
<li>Fragment 发起的请求，虽然在 FragmentActivity 中能获取到结果，但是requestCode完全对应不上</li>
</ul>
<blockquote>
<p>Fragment.startActivityForResult<br>↓<br>FragmentActivitymHost.HostCallbacks.onStartActivityFromFragment<br>↓<br>FragmentActivity.startActivityFromFragment</p>
</blockquote>
<p>从 Fragment 的 <code>startActivityForResult</code> 开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mHost == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fragment "</span> + <span class="keyword">this</span> + <span class="string">" not attached to Activity"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       mHost.onStartActivityFromFragment(<span class="keyword">this</span> <span class="comment">/*fragment*/</span>, intent, requestCode, options);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>调用了一个mHost.onStartActivityFromFragment 的方法。Fragment 被添加到一个 FragmentActivity 中之后，这里的 mHost 即是当前 FragmentActivity 的一个内部类 FragmentActivity.HostCallbacks，它持有对FragmentActivity 的引用，通过调用 <code>onStartActivityFromFragment</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartActivityFromFragment</span><span class="params">(@NonNull Fragment fragment, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">           FragmentActivity.<span class="keyword">this</span>.startActivityFromFragment(fragment, intent, requestCode, options);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>转发到当前 FragmentActivity 的 <code>startActivityFromFragment</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityFromFragment</span><span class="params">(Fragment fragment, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    mStartedActivityFromFragment = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode == -<span class="number">1</span>) &#123;</span><br><span class="line">            ActivityCompat.startActivityForResult(<span class="keyword">this</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((requestCode&amp;<span class="number">0xffff0000</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can only use lower 16 bits for requestCode"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> requestIndex = allocateRequestIndex(fragment);</span><br><span class="line">        ActivityCompat.startActivityForResult(</span><br><span class="line">            <span class="keyword">this</span>, intent, ((requestIndex+<span class="number">1</span>)&lt;&lt;<span class="number">16</span>) + (requestCode&amp;<span class="number">0xffff</span>), options);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mStartedActivityFromFragment = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析一下这段代码：<br>1.<code>mStartedActivityFromFragment = true</code>首先标记一下请求是来自于 Fragment。<br>2.<code>if(requestCode == -1)</code>的内容不用管，它是来自于 startActivity（没有ForResult）的情况。<br>3.然后的代码添加了对requestCode必须小于0xffff的限制 <code>if((requestCode&amp;0xffff0000) ！= 0){/*抛异常*/}</code><br>我们是从 Fragment.startActivityForResult 追踪到这里的，所以虽然文档没有明确说，但是从这里可以看出：<strong>Fragment.startActivityForResult的requestCode也是必须要&lt;=0xffff的。</strong></p>
<p><strong>然后，下面是关键点了：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ActivityCompat.startActivityForResult(</span><br><span class="line">            <span class="keyword">this</span>, intent, ((requestIndex+<span class="number">1</span>)&lt;&lt;<span class="number">16</span>) + (requestCode&amp;<span class="number">0xffff</span>), options);</span><br></pre></td></tr></table></figure>

<p>其中ActivityCompat是一个帮助类，ActivityCompat.startActivityForResult 最终还是调用的Activity.startActivityForResult。通过分析，得知 requestIndex 是请求的序号，值为从0递增的整数值。<br>又从前面得知，requestCode 的本身的值是小于0xffff的，所以<code>((requestIndex+1)&lt;&lt;16)+(requestCode&amp;0xffff)</code>简化一下就是：<code>(requestIndex+1)*65536+requestCode</code>——<strong>所以这个值是必定大于0xffff的。</strong></p>
<p>再看一下 <code>FragmentActivity.startActivityForResult</code> 的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If this was started from a Fragment we've already checked the upper 16 bits were not in</span></span><br><span class="line">    <span class="comment">// use, and then repurposed them for the Fragment's index.</span></span><br><span class="line">    <span class="keyword">if</span> (!mStartedActivityFromFragment) &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode != -<span class="number">1</span> &amp;&amp; (requestCode&amp;<span class="number">0xffff0000</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can only use lower 16 bits for requestCode"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.startActivityForResult(intent, requestCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，判断了一下如果请求不是来自于 Fragment，也就是来自于 FragmentActivity 自身，就限制 requestCode 不能大于0xffff。</p>
<p>再加上前文所说的，Fragment.startActivityForResult 最终映射的 requestCode 值必定大于0xffff，所以，现在可以得出了一个初步的结果：<br><strong>SDK 把 Fragment 和 FragmentActivity 的 requestCode 都限制在了0xffff以内，然后对于 Fragment 所发起的请求，都通过一个映射，把最终的 requestCode 变成了一个大于0xffff的值。</strong></p>
<p>可以推测到：<strong>在获取的结果的时候，也是会通过跟0xffff这个数值来比较，来区分是要把结果交给FragmentActivity 还是 Fragment 来处理。</strong></p>
<p>再来看一下 <code>FragmentActivity.onActivityResult</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    mFragments.noteStateNotSaved();</span><br><span class="line">    <span class="keyword">int</span> requestIndex = requestCode&gt;&gt;<span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestIndex != <span class="number">0</span>) &#123;</span><br><span class="line">        requestIndex--;</span><br><span class="line">        String who = mPendingFragmentActivityResults.get(requestIndex);</span><br><span class="line">        mPendingFragmentActivityResults.remove(requestIndex);</span><br><span class="line">        <span class="keyword">if</span> (who == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Activity result delivered for unknown Fragment."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Fragment targetFragment = mFragments.findFragmentByWho(who);</span><br><span class="line">        <span class="keyword">if</span> (targetFragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Activity result no fragment exists for who: "</span> + who);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            targetFragment.onActivityResult(requestCode&amp;<span class="number">0xffff</span>, resultCode, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>果然，证实了我们上面的推论。在FragmentActivity.onActivityResult 中，只有 <code>requestCode&gt;0xffff</code> 时，这里得到的 requestIndex 才能满足<code>requestIndex != 0</code>，然后进入下面的逻辑：把 requestCode 通过反向之前的映射关系，还原成最初 Fragment 所指定的 requestCode，交给 Fragment.onActivityResult 进行处理。</p>
<p><strong>注意：</strong>通过 FragementActivity 源码可以发现，源码里没有处理嵌套 Fragment 的情况，也就是说回调只到第一级Fragment，就没有继续分发。所以在第二级或者更深级别的 Fragment 调用 startActivityForResult 方法时，将无法收到 onActivityResult 回调。</p>
<ul>
<li><p><strong>使用 startActivityForResult 的时候，requestCode 一定不要大于 0xffff(65535)</strong>。</p>
</li>
<li><p>嵌套一层 Fragment 时，要在 Fragment 的 onActivityResult 接收数据，在 Fragment 中要使用 <code>Fragment.startActivityForResult</code>，而不是 <code>Fragment.getActivity().startActivityForResult</code>，如果 activity 中重写了 onActivityResult，那么一定要加上<code>super.onActivityResult(requestCode, resultCode, data)</code>。</p>
</li>
<li><p>嵌套多层 Fragment 时，要在第二级或更深级别的 Fragment 获取回调，需要重写 activity 的 onActivityResult 方法，继续分发回调给 Fragment。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAppCompatActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"TAG"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写onactivityresult方法，使二个或多个fragment嵌套使用时能收到onactivityresut回调</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        FragmentManager fm = getSupportFragmentManager();</span><br><span class="line">        <span class="keyword">int</span> index = requestCode &gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (fm.getFragments() == <span class="keyword">null</span> || index &lt; <span class="number">0</span></span><br><span class="line">                    || index &gt;= fm.getFragments().size()) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Activity result fragment index out of range: 0x"</span></span><br><span class="line">                        + Integer.toHexString(requestCode));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Fragment frag = fm.getFragments().get(index);</span><br><span class="line">            <span class="keyword">if</span> (frag == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Activity result no fragment exists for index: 0x"</span></span><br><span class="line">                        + Integer.toHexString(requestCode));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handleResult(frag, requestCode, resultCode, data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归调用，对所有子Fragement生效</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> frag</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(Fragment frag, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Intent data)</span> </span>&#123;</span><br><span class="line">        frag.onActivityResult(requestCode &amp; <span class="number">0xffff</span>, resultCode, data);</span><br><span class="line">        List&lt;Fragment&gt; frags = frag.getChildFragmentManager().getFragments();</span><br><span class="line">        <span class="keyword">if</span> (frags != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Fragment f : frags) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">null</span>)</span><br><span class="line">                    handleResult(f, requestCode, resultCode, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Fragment 中调用 startActivityForResult 时，一定要调用根 Fragment 的启动方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 得到根Fragment</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Fragment <span class="title">getRootFragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Fragment fragment = getParentFragment();</span><br><span class="line">  <span class="keyword">while</span> (fragment.getParentFragment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">   fragment = fragment.getParentFragment();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fragment;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 启动Activity</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onClickTextViewRemindAdvancetime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">  intent.setClass(getActivity(), YourActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  intent.putExtra(<span class="string">"TAG"</span>,<span class="string">"TEST"</span>); </span><br><span class="line">  getRootFragment().startActivityForResult(intent, <span class="number">1000</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="七、ViewPager-Fragment相关"><a href="#七、ViewPager-Fragment相关" class="headerlink" title="七、ViewPager+Fragment相关"></a>七、ViewPager+Fragment相关</h4><p>ViewPager 是 android 中提供界面滑动的类，继承自 ViewGroup。PagerAdapter 是 ViewPager 的适配器类，为ViewPager提供界面。但是一般来说，通常都会使用 PagerAdapter 的两个子类：FragmentPagerAdapter和FragmentStatePagerAdapter 作为 ViewPager 的适配器，他们的特点是界面是 Fragment 。</p>
<p>ViewPager 默认会缓存当前页相邻的<code>DEFAULT_OFFSCREEN_PAGES</code>(默认1)个界面，比如当滑动到第2页时，会初始化第1页和第3页的界面（即 Fragmen t对象，且生命周期函数运行到<code>onResume()</code>），可以通过<code>setOffscreenPageLimit(count)</code>设置当前页的左右两边的预加载界面数量。</p>
<p>FragmentPagerAdapter 和 FragmentStatePagerAdapter 需要重写的方法都一样，常见的重写方法如下：</p>
<ul>
<li>public FragmentPagerAdapter(FragmentManager fm)：构造函数，参数为 FragmentManager。如果是嵌套 Fragment 场景，子 PagerAdapter的参数传入 getChildFragmentManager()。</li>
<li>Fragment getItem(int position)：返回第 position 位置的 Fragment，必须重写。</li>
<li>int getCount(): 返回 ViewPager 的页数，必须重写。</li>
<li>Object instantiateItem(ViewGroup container, int position)：container 是 ViewPager 对象，返回第 position位置的 Fragment。</li>
<li>void destroyItem(ViewGroup container, int position, Object object)：container 是 ViewPager 对象，object 是 Fragment 对象。</li>
<li>getItemPosition(Object object)：object 是 Fragment 对象，如果返回 POSITION_UNCHANGED，则表示当前 Fragment 不刷新，如果返回 POSITION_NONE，则表示当前 Fragment 需要调用<code>destroyItem()</code>和<code>instantiateItem()</code>进行销毁和重建。 默认情况下返回 POSITION_UNCHANGED。</li>
</ul>
<p>FragmentPagerAdapter 和 FragmentStatePagerAdapter 的区别：</p>
<ul>
<li><strong>FragmentPagerAdapter</strong>：<strong>对Fragment的状态没有恢复和保存，对Fragment对象进行视图销毁</strong>。每个Fragment 会持久的保存在 FragmentManager 中，在 destroyItem() 中只是 detach，只是在页面上让 fragment 的UI脱离 Activity，但 fragment 仍然保存在内存里，并不会回收内存。因此适用于那些数据<strong>相对静态</strong>的页，Fragment <strong>数量也比较少</strong>的情况。</li>
<li><strong>FragmentStatePagerAdapter</strong>： <strong>对Fragment的状态进行了恢复和保存，对Fragment对象进行实例销毁</strong> 。只保留当前页面，当页面不可见时，在 destroyItem() 中会 remove 之前加载的 fragment，该 fragment 就会被消除，释放其内存资源。因此适用于那些<strong>数据动态性</strong>较大、<strong>占用内存</strong>较多，Fragment <strong>数量较多</strong>的情况。</li>
</ul>
<h4 id="八、懒加载"><a href="#八、懒加载" class="headerlink" title="八、懒加载"></a>八、懒加载</h4><h5 id="为什么要使用懒加载"><a href="#为什么要使用懒加载" class="headerlink" title="为什么要使用懒加载"></a>为什么要使用懒加载</h5><p>默认情况，ViewPager 会缓存当前页和左右相邻的界面。实现懒加载的主要原因是：用户没进入的界面需要有一系列的网络、数据库等耗资源、耗时的操作，预先做这些数据加载是不必要的。为了不做预先额外的数据加载，节省资源，就需要使用懒加载。</p>
<h5 id="什么是懒加载"><a href="#什么是懒加载" class="headerlink" title="什么是懒加载"></a>什么是懒加载</h5><p>当界面对用户可见时，才加载数据并更新UI，当界面对用户不可见时，停止加载数据等一切操作。</p>
<h5 id="如何实现懒加载"><a href="#如何实现懒加载" class="headerlink" title="如何实现懒加载"></a>如何实现懒加载</h5><p><strong>在 androidx 之前</strong>，懒加载主要依赖 Fragment 的<code>setUserVisibleHint(boolean isVisible)</code>方法，当Fragment变为可见时，会调用<code>setUserVisibleHint(true)</code>；当Fragment变为不可见时，会调用<code>setUserVisibleHint(false)</code>，且该方法调用时机：</p>
<ul>
<li>onAttach() 之前，调用<code>setUserVisibleHint(false)</code>。</li>
<li>onCreateView() 之前，如果该界面为当前页，则调用<code>setUserVisibleHint(true)</code>，否则调用<code>setUserVisibleHint(false)</code>。</li>
<li>界面变为可见时，调用<code>setUserVisibleHint(true)</code>。</li>
<li>界面变为不可见时，调用<code>setUserVisibleHint(false)</code>。</li>
</ul>
<p>懒加载 Fragment 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> View mRootView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsPrepared; <span class="comment">//表示UI是否准备好</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsInited;  <span class="comment">//表示是否已经做过数据加载</span></span><br><span class="line">                                            </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        mRootView = inflater.inflate(R.layout.fragment_lazy, container, <span class="keyword">false</span>);</span><br><span class="line">        mIsPrepared = <span class="keyword">true</span>;</span><br><span class="line">        lazyLoad();<span class="comment">// 解决第一次数据显示</span></span><br><span class="line">        <span class="keyword">return</span> mRootView;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lazyLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (getUserVisibleHint() &amp;&amp; mIsPrepared &amp;&amp; !mIsInited) &#123; </span><br><span class="line">           <span class="comment">//异步初始化，在初始化后显示正常UI</span></span><br><span class="line">           <span class="comment">//1. 加载数据  2. 更新UI  3. mIsInited = true</span></span><br><span class="line">           loadData();</span><br><span class="line">           mIsInited = <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//子类可重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加载数据</span></span><br><span class="line">    &#125;   </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserVisibleHint</span><span class="params">(<span class="keyword">boolean</span> isVisibleToUser)</span> </span>&#123; </span><br><span class="line">           <span class="keyword">super</span>.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">           <span class="keyword">if</span> (isVisibleToUser) &#123;</span><br><span class="line">             lazyLoad();</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyFragment <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> LazyFragment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>mIsPrepared：表示UI是否准备好，因为数据加载后需要更新UI，如果UI还没有inflate，就不需要做数据加载，因为setUserVisibleHint()会在onCreateView()之前调用一次，如果此时调用，UI还没有inflate，因此不能加载数据。</li>
<li>mIsInited：表示是否已经做过数据加载，如果做过了就不需要做了。因为 setUserVisibleHint(true) 在界面可见时都会调用，如果滑到该界面做过数据加载后，滑走，再滑回来，还是会调用 setUserVisibleHint(true)，此时由于mIsInited=true，因此不会再做一遍数据加载。</li>
<li>lazyLoad()：懒加载的核心类，在该方法中，只有界面可见（getUserVisibleHint()==true）、UI准备好（mIsPrepared==true）、过去没做过数据加载（mIsInited==false）时，才需要调loadData()做数据加载，数据加载做完后把mIsInited置为true。</li>
</ul>
<p><strong>在 androidx 之后</strong>，<code>setUserVisibleHint()</code>方法已经过时了，官方提出了<code>setMaxLifecycle()</code>方法来替代<code>setUserVisibleHint()</code>方法。</p>
<p><strong>setMaxLifecycle()方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set a ceiling for the state of an active fragment in this FragmentManager. If fragment is</span></span><br><span class="line"><span class="comment">     * already above the received state, it will be forced down to the correct state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The fragment provided must currently be added to the FragmentManager to have it's</span></span><br><span class="line"><span class="comment">     * Lifecycle state capped, or previously added as part of this transaction. The</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Lifecycle.State&#125; passed in must at least be &#123;<span class="doctag">@link</span> Lifecycle.State#CREATED&#125;, otherwise</span></span><br><span class="line"><span class="comment">     * an &#123;<span class="doctag">@link</span> IllegalArgumentException&#125; will be thrown.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragment the fragment to have it's state capped.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state the ceiling state for the fragment.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the same FragmentTransaction instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">setMaxLifecycle</span><span class="params">(@NonNull Fragment fragment,</span></span></span><br><span class="line"><span class="function"><span class="params">            @NonNull Lifecycle.State state)</span> </span>&#123;</span><br><span class="line">  addOp(<span class="keyword">new</span> Op(OP_SET_MAX_LIFECYCLE, fragment, state));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setMaxLifecycle()</code>方法定义在<strong>FragmentTransaction</strong>类中，它的内部逻辑很简单，其实我们经常使用的<code>add()</code>、<code>remove()</code>、<code>show()</code>、<code>hide()</code>等方法也是类似的逻辑，将操作封装为一个Op对象，最后调用<code>commit()</code>方法时再根据Op对象执行对应的操作。</p>
<p>注释中提到<code>setMaxLifecycle()</code>方法的作用是为 Fragment 的状态设置上限，如果当前 Fragment 的状态已经超过了设置的上限，就会强制被降到相应状态。在弄清楚上面这段文字的意义之前我首先要介绍两个相关概念：<strong>Fragment的状态</strong>和<strong>Lifecycle的状态</strong>。</p>
<ul>
<li><strong>Fragment的状态</strong></li>
</ul>
<p>在Fragment类中定义了5个int常量，表示Fragment的状态值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIALIZING = <span class="number">0</span>;     <span class="comment">// Not yet created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATED = <span class="number">1</span>;          <span class="comment">// Created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTIVITY_CREATED = <span class="number">2</span>; <span class="comment">// Fully created, not started.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STARTED = <span class="number">3</span>;          <span class="comment">// Created and started, not resumed.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESUMED = <span class="number">4</span>;          <span class="comment">// Created started and resumed.</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Lifecycle的状态</strong></li>
</ul>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">Lifecycle</a>是 Android Jetpack 中的架构组件之一，用于帮助我们方便地管理 Activity 和 Fragment 的生命周期，关于 Lifecycle 的详细介绍和使用网上有很多文章，我这里就不说了，如果此前没有接触过可以自行了解一下哈。<br>在 Lifecycle 定义了一个枚举类<strong>State</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    DESTROYED,</span><br><span class="line">    INITIALIZED,</span><br><span class="line">    CREATED,</span><br><span class="line">    STARTED,</span><br><span class="line">    RESUMED;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAtLeast</span><span class="params">(@NonNull State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 Lifecycle 中同样定义了5个状态，不过这里的状态和 Fragment中 定义的状态还是有一些区别的。</p>
<p>回到<code>setMaxLifecycle()</code>方法，需要传入的参数有两个：fragment和state。fragment不用多说，就是要设置的目标Fragment，不过需要注意的是<strong>此时Fragment必须已经被添加到了FragmentManager中，也就是调用了<code>add()</code>方法</strong>，否则会抛出异常。state就是Lifecycle中定义的枚举类型，同样需要注意<strong>传入的state应该至少为CREATED，换句话说就是只能传入CREATED、STARTED和RESUMED</strong>，否则同样会抛出异常。</p>
<p>下面就以我们最熟悉的生命周期方法来说明这个状态的限制，先上一张图总结一下结论：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghkm2rcvpcj32bg0u0tn8.jpg" alt=""></p>
<p>图中展示了 Fragment 状态间切换会执行的生命周期方法以及 Lifecycle.State 对应的 Fragment 状态，由于<code>setMaxLifecycle()</code>方法要求传入的state至少为<strong>CREATED</strong>，因此我们只需研究<strong>CREATED</strong>、<strong>STARTED</strong>和<strong>RESUMED</strong>这三个状态，结合上图解释一下<code>setMaxLifecycle()</code>方法的作用。</p>
<ul>
<li><strong>参数传入Lifecycle.State.CREATED</strong></li>
</ul>
<p><strong>Lifecycle.State.CREATED</strong>对应Fragment的<strong>CREATED</strong>状态，如果当前Fragment状态低于<strong>CREATED</strong>，也就是<strong>INITIALIZING</strong>，那么Fragment的状态会变为<strong>CREATED</strong>，依次执行<code>onAttach()</code>、<code>onCreate()</code>方法；如果当前Fragment状态高于<strong>CREATED</strong>，那么Fragment的状态会被强制降为<strong>CREATED</strong>，以当前Fragment状态为<strong>RESUMED</strong>为例，接下来会依次执行<code>onPause()</code>、<code>onStop()</code>和<code>onDestoryView()</code>方法。如果当前Fragment的状态恰好为<strong>CREATED</strong>，那么就什么都不做。</p>
<ul>
<li><strong>参数传入Lifecycle.State.STARTED</strong></li>
</ul>
<p><strong>Lifecycle.State.STARTED</strong>对应Fragment的<strong>STARTED</strong>状态，如果当前Fragment状态低于<strong>STARTED</strong>，那么Fragment的状态会变为<strong>STARTED</strong>，以当前Fragment状态为<strong>CREATED</strong>为例，接下来会依次执行<code>onCreateView()</code>、<code>onActivityCreate()</code>和<code>onStart()</code>方法；如果当前Fragment状态高于<strong>STARTED</strong>，也就是<strong>RESUMED</strong>，那么Fragment的状态会被强制降为<strong>STARTED</strong>，接下来会执行<code>onPause()</code>方法。如果当前Fragment的状态恰好为<strong>STARTED</strong>，那么就什么都不做。</p>
<ul>
<li><strong>参数传入Lifecycle.State.RESUMED</strong></li>
</ul>
<p><strong>Lifecycle.State.RESUMED</strong>对应Fragment的<strong>RESUMED</strong>状态，如果当前Fragment状态低于<strong>RESUMED</strong>，那么Fragment的状态会变为<strong>RESUMED</strong>，以当前Fragment状态为<strong>STARTED</strong>为例，接下来会执行<code>onResume()</code>方法。如果当前Fragment的状态恰好为<strong>RESUMED</strong>，那么就什么都不做。</p>
<p>那么 androidx 之后懒加载的新方案，这次的切入点在 <strong>FragmentPagerAdapter</strong> 中，我们会发现之前继承自 FragmentPagerAdapter 的构造方法同样过时了。提供了新的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FragmentPagerAdapter</span><span class="params">(@NonNull FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @Behavior <span class="keyword">int</span> behavior)</span> </span>&#123;</span><br><span class="line">    mFragmentManager = fm;</span><br><span class="line">    mBehavior = behavior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多了一个 int 类型的参数 behavior，可选的值有以下两个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BEHAVIOR_SET_USER_VISIBLE_HINT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出一个参数的构造方法默认传入<strong>BEHAVIOR_SET_USER_VISIBLE_HINT</strong>，将其赋值给mBehavior，那么这个mBehavior在什么地方用到了呢。在<strong>FragmentPagerAdapter.java</strong>文件中全局搜索一下，发现只有两个地方用到了mBehavior：<code>instantiateItem()</code>方法和<code>setPrimaryItem()</code>方法。<code>instantiateItem()</code>方法我们很熟悉，是初始化ViewPager中每个Item的方法，<code>setPrimaryItem()</code>方法我此前没有接触过，简单地看了一下源码发现它的作用是设置ViewPager将要显示的Item，在ViewPager切换时会调用该方法，我们来看一下FragmentPagerAdapter中的<code>setPrimaryItem()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrimaryItem</span><span class="params">(@NonNull ViewGroup container, <span class="keyword">int</span> position, @NonNull Object object)</span> </span>&#123;</span><br><span class="line">        Fragment fragment = (Fragment)object;</span><br><span class="line">        <span class="keyword">if</span> (fragment != mCurrentPrimaryItem) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCurrentPrimaryItem != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mCurrentPrimaryItem.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mCurrentPrimaryItem.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fragment.setMenuVisibility(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">                &#125;</span><br><span class="line">                mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fragment.setUserVisibleHint(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mCurrentPrimaryItem = fragment;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果 mBehavior 的值为<strong>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</strong>，那么就调用<code>setMaxLifecycle()</code>方法将上一个Fragment的状态设置为<strong>STARTED</strong>，将当前要显示的Fragment的状态设置为<strong>RESUMED</strong>；反之如果mBehavior的值为<strong>BEHAVIOR_SET_USER_VISIBLE_HINT</strong>，那么依然使用<code>setUserVisibleHint()</code>方法设置Fragment的可见性，相应地可以根据<code>getUserVisibleHint()</code>方法获取到Fragment是否可见，从而实现懒加载，具体做法：</p>
<ul>
<li><p>在构造 Adapter 对象的时候 behavior 参数传入 <strong>FragmentPagerAdapter.BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</strong>；</p>
</li>
<li><p>将 Fragment 加载数据的逻辑放到 onResume() 方法中，这样就保证了 Fragment 可见时才会加载数据。</p>
</li>
<li><p>声明一个变量标记是否是首次执行<code>onResume()</code>方法，因为每次 Fragment 由不可见变为可见都会执行<code>onResume()</code>方法，需要防止数据的重复加载。此外，如果我们使用的是 FragmentPagerAdapter，切换导致Fragment被销毁时是不会执行<code>onDestory()</code>和<code>onDetach()</code>方法的，只会执行到<code>onDestroyView()</code>方法，因此在<code>onDestroyView()</code>方法中我们还需要将这个变量重置，否则当Fragment再次可见时就不会重新加载数据了。</p>
</li>
</ul>
<p>以上几点我们就可以封装出新的懒加载 Fragment 了，完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NewLazyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isFirstLoad = <span class="keyword">true</span>; <span class="comment">// 是否第一次加载</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mContext = getActivity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View view = inflater.inflate(getLayoutRes(),container,<span class="keyword">false</span>);</span><br><span class="line">        initView(view);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroyView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView();</span><br><span class="line">        isFirstLoad = <span class="keyword">true</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        <span class="keyword">if</span> (isFirstLoad) &#123;</span><br><span class="line">            <span class="comment">// 将数据加载逻辑放到onResume()方法中</span></span><br><span class="line">            initData();</span><br><span class="line">            isFirstLoad = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置布局资源id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getLayoutRes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化视图</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文记录 Android 中 Fragment 的相关知识点，包括 Fragment 的基本定义及使用、生命周期、回退栈的内部实现、Fragment 通信、ViewPager+Fragment 的使用、AndroidX前、后的懒加载等，加深了对 Fragment 的理解和学习。</p>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/dUuGSVhWinAnN9uMiBaXgw" target="_blank" rel="noopener">Android基础：Fragment，看这篇就够了</a></p>
<p><a href="https://www.jianshu.com/p/ca91fa528d5c" target="_blank" rel="noopener">彻底搞懂startActivityForResult在FragmentActivity和Fragment中的异同</a></p>
<p><a href="https://www.cnblogs.com/xjx22/p/5263658.html" target="_blank" rel="noopener">Android的Fragment中onActivityResult不被调用的解决方案</a></p>
<p><a href="https://blog.csdn.net/qq_36486247/article/details/102531304" target="_blank" rel="noopener">androidx中的Fragment懒加载方案</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Service必备基础</title>
    <url>/2020/07/25/Service%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android的四大组件之一的Service。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是Service"><a href="#一、什么是Service" class="headerlink" title="一、什么是Service"></a>一、什么是Service</h4><p>Service 是一个应用程序组件，它能在后台执行一些耗时较长的操作，并且不提供用户界面。服务能被其他应用程序的组件启动，即使用户切换到另外的应用时还能保持后台运行。此外，应用程序组件还能与服务绑定，并与服务进行交互，甚至能进行进程间通信（IPC）。 比如，服务可以处理网络传输、音乐播放、执行文件I/O、或者与 content provider 进行交互，所有这些都是后台进行的。</p>
<a id="more"></a>

<ul>
<li><p>运行完全不依赖UI的，只要进程还在，Service 就可以继续运行，可以和其他组件组件交互；</p>
</li>
<li><p>一般运行在与创建服务时所在的应用程序进程中，要运行在单独的进程当中，在声明时需指定 <code>android:process</code>；</p>
</li>
<li><p>服务不会自动开启线程，我们需要在服务的内部手动创建子线程，并在这里执行具体的耗时任务。</p>
</li>
</ul>
<h4 id="二、Service分类"><a href="#二、Service分类" class="headerlink" title="二、Service分类"></a>二、Service分类</h4><h5 id="按运行分类"><a href="#按运行分类" class="headerlink" title="按运行分类"></a>按运行分类</h5><p><strong>前台服务</strong>：指那些经常会被用户关注的服务，因此内存过低时它不会成为被杀的对象。 前台服务必须提供一个状态栏通知，比较不容易被系统回收。</p>
<p><strong>后台服务</strong>：指在后台默默工作，提供数据运算等的服务，它优先级还是比较低的，当系统出现内存不足情况时，就有可能会回收掉正在后台运行的Service。</p>
<h5 id="按使用分类"><a href="#按使用分类" class="headerlink" title="按使用分类"></a>按使用分类</h5><p><strong>本地服务</strong>：用于应用程序内部，实现一些耗时任务，并不占用应用程序所属线程，而是单开线程后台执行。 </p>
<p><strong>远程服务</strong>：用于 Android 系统内部的应用程序之间，可被其他应用程序复用，比如天气预报服务，其他应用程序不需要再写这样的服务，调用已有的即可。</p>
<h4 id="三、Service启动状态"><a href="#三、Service启动状态" class="headerlink" title="三、Service启动状态"></a>三、Service启动状态</h4><h5 id="启动状态-Started"><a href="#启动状态-Started" class="headerlink" title="启动状态(Started)"></a>启动状态(Started)</h5><p>当应用组件（如 Activity）通过调用 <strong>startService()</strong> 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响，除非外部手动调用 <strong>stopService()</strong> 或内部调用 <strong>stopSelf()</strong> 才能停止服务， 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。</p>
<h5 id="绑定状态-Bound"><a href="#绑定状态-Bound" class="headerlink" title="绑定状态(Bound)"></a>绑定状态(Bound)</h5><p>当应用组件通过调用 <strong>bindService()</strong> 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器 <strong>IBinder</strong> 接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</p>
<h4 id="四、Service生命周期"><a href="#四、Service生命周期" class="headerlink" title="四、Service生命周期"></a>四、Service生命周期</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh7ysawqzfj30at0e3abt.jpg" alt=""></p>
<p><strong>onCreate()</strong>：首次创建服务时，将调用此方法，如果服务已在运行，则不会调用此方法，该方法只调用一次；</p>
<p><strong>onStartComand()</strong>：服务通过 <strong>startService()</strong> 启动时会调用，多次执行 <strong>startService()</strong> 方法，该方法也会相应的多次调用；</p>
<p><strong>onBind()</strong>：服务通过 <strong>bindService()</strong> 启动且服务是第一次创建时会调用，在此方法必须返回 一个 IBinder 接口的实现类对象，供客户端用来与服务进行通信，服务在启动状态的情况下可返回 null ；</p>
<p><strong>onUnBind()</strong>：服务通过 <strong>unbindService()</strong> 被解绑时调用；</p>
<p><strong>onDestroy()</strong>：服务停止或被解绑后调用；</p>
<h4 id="五、Service使用"><a href="#五、Service使用" class="headerlink" title="五、Service使用"></a>五、Service使用</h4><h5 id="Service在清单文件中的声明"><a href="#Service在清单文件中的声明" class="headerlink" title="Service在清单文件中的声明"></a>Service在清单文件中的声明</h5><p>通过继承Service基类自定义而来，都需要在AndroidManifest.xml中声明，Service在AndroidManifest.xml中的声明语法，其格式如下(不是所有都必填)：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;service android:enabled=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:exported=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:icon=<span class="string">"drawable resource"</span></span><br><span class="line">    android:isolatedProcess=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:label=<span class="string">"string resource"</span></span><br><span class="line">    android:name=<span class="string">"string"</span></span><br><span class="line">    android:permission=<span class="string">"string"</span></span><br><span class="line">    android:process=<span class="string">"string"</span> &gt;</span><br><span class="line">    . . .</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>android:exported：代表是否能被其他应用隐式调用，其默认值是由 service 中有无 intent-filter 决定的，如果有 intent-filter ，默认值为 true ，否则为 false 。为 false 的情况下，即使有 intent-filter 匹配，也无法打开，即无法被其他应用隐式调用。</li>
<li>android:name：对应 Service 类名，唯一必需的属性。</li>
<li>android:permission：申明此服务的权限。</li>
<li>android:process：是否需要在单独的进程中运行，当设置为 android:process=”:remote” 时，代表Service 在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以 “remote” 和 ”:remote” 不是同一个意思，前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。</li>
<li>android:isolatedProcess ：设置 true 意味着，服务会在一个特殊的进程下运行，这个进程与系统其他进程分开且没有自己的权限。与其通信的唯一途径是通过服务的API(bind and start)。</li>
<li>android:enabled：是否可以被系统实例化，默认为 true因为父标签 也有 enable 属性，所以必须两个都为默认值 true 的情况下服务才会被激活，否则不会激活。</li>
</ul>
<h5 id="通过startService启动"><a href="#通过startService启动" class="headerlink" title="通过startService启动"></a>通过startService启动</h5><ul>
<li><p>service 会一直无限期运行下去，只有外部调用了 stopService() 或 stopSelf() 方法时，该 Service 才会停止运行并销毁。</p>
</li>
<li><p>多次 startService 不会重复执行onCreate回调，但每次都会执行 onStartCommand 回调</p>
</li>
<li><p><strong>onStartCommand()</strong> 方法的返回值int类型才值得注意的，它有三种可选值：</p>
<p>START_STICKY：“黏性的”，当 Service 因内存不足而被系统 kill 后，一段时间后内存再次空闲时，系统将会尝试重新创建此 Service ，一旦创建成功后将回调 onStartCommand 方法，但其中的 Intent 将是null，除非有挂起的Intent，如pendingintent，比较适用于不执行命令、但无限期运行并等待作业的媒体播放器或类似服务。</p>
<p>START_NOT_STICKY：“非黏性的”，当 Service 因内存不足而被系统kill后，即使系统内存再次空闲时，系统也不会尝试重新创建此Service。</p>
<p>START_REDELIVER_INTENT：当 Service 因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，任何挂起 Intent 均依次传递。与 START_STICKY 不同的是，其中的传递的 Intent 将是非空，是最后一次调用 startService 中的 intent 。这个值适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</p>
</li>
</ul>
<h5 id="通过bindService启动"><a href="#通过bindService启动" class="headerlink" title="通过bindService启动"></a>通过bindService启动</h5><ul>
<li><p>该启动方式的调用者和服务之间是典型的 <strong>client-server</strong> 模式。调用者是 client ，service 则是 server 端。<strong>service 只有一个</strong>，但绑定到 service 上面的 client 可以有一个或很多个。这里所提到的 client 指的是组件，比如某个Activity。</p>
</li>
<li><p><strong>client 可以通过 IBinder 接口获取 Service 实例</strong>，从而实现在 client 端直接调用 Service 中的方法以实现交互。</p>
</li>
<li><p>启动服务的生命周期与其绑定的 client 息息相关。当 client 销毁时，client 会自动与 Service 解除绑定。当然，client 也可以明确调用 Context的 <strong>unbindService()</strong> 方法与 Service 解除绑定。<strong>当没有任何 client 与 Service 绑定时，Service 会自行销毁</strong>。</p>
</li>
<li><p><strong>onBind()</strong> 方法必须返回一个 IBinder接口的实现类对象，该类用以提供客户端用来与服务进行交互的编程接口，该接口可以通过三种方法定义接口：</p>
<p><strong>扩展 Binder 类</strong> ：如果服务是提供给自有应用专用的，并且 Service (服务端)与客户端相同的进程中运行，即客户端和服务位于<strong>同一应用和进程</strong>内才有效。通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中以及 Service 中可用的公共方法。如果我们的服务只是自有应用的后台工作线程，则优先采用这种方法。不采用该方式创建接口的唯一原因是，服务被其他应用或不同的进程调用。</p>
<p><strong>使用 Messenger</strong> ：通过它可以在<strong>不同的进程</strong>中共传递Message对象(Handler中的Messager，因此 Handler 是 Messenger 的基础)，在Message中可以存放我们需要传递的数据，然后在进程间传递。因为 Messenger 会在单一线程中创建包含所有请求的队列，也就是说Messenger是以串行的方式处理客户端发来的消息，这样我们就不必对服务进行线程安全设计了。</p>
<p><strong>使用 AIDL</strong> ：由于 Messenger 是以串行的方式处理客户端发来的消息，如果当前有大量消息同时发送到Service(服务端)，Service 仍然只能一个个处理，这也就是 Messenger 跨进程通信的缺点了，因此如果有大量并发请求，Messenger 就会显得力不从心了，这时 AIDL（Android Interface Definition Language） Android 接口定义语言就派上用场了，但实际上 Messenger 的跨进程方式其底层实现就是AIDL，只不过 android 系统帮我们封装成透明的 Messenger 罢了。如果我们想让服务同时处理多个请求，则应该使用 AIDL。它可以用于让某个 Service 与多个应用程序组件之间进行跨进程通信，从而可以实现<strong>多个应用程序共享同一个 Service</strong> 的功能。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务端LocalService部分代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> MyBinder mBinder = <span class="keyword">new</span> MyBinder();</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//建Binder对象，返回给客户端使用，提供数据交换的接口</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line"> 	    <span class="comment">// 声明一个方法，getService。（提供给客户端调用）</span></span><br><span class="line">    <span class="function">LocalService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回当前对象LocalService,这样我们就可在客户端调用Service的公共方法了</span></span><br><span class="line">      <span class="keyword">return</span> LocalService.<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//定义交互方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端--绑定服务实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BindActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ServiceConnection conn;</span><br><span class="line">  <span class="keyword">private</span> LocalService.MyBinder mBinder;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Overrid</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_bind);</span><br><span class="line">        btnBind = (Button) findViewById(R.id.BindService);</span><br><span class="line">        btnUnBind = (Button) findViewById(R.id.unBindService);</span><br><span class="line">        btnGetDatas = (Button) findViewById(R.id.getServiceDatas);</span><br><span class="line">        <span class="comment">//创建绑定对象</span></span><br><span class="line">        <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LocalService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 开启绑定</span></span><br><span class="line">        btnBind.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"绑定调用：bindService"</span>);</span><br><span class="line">                <span class="comment">//调用绑定方法</span></span><br><span class="line">                bindService(intent, conn, Service.BIND_AUTO_CREATE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 解除绑定</span></span><br><span class="line">        btnUnBind.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"解除绑定调用：unbindService"</span>);</span><br><span class="line">                <span class="comment">// 解除绑定</span></span><br><span class="line">                <span class="keyword">if</span>(mBinder!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    mBinder = <span class="keyword">null</span>;</span><br><span class="line">                    unbindService(conn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="comment">// 获取数据</span></span><br><span class="line">        btnGetDatas.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mBinder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 通过绑定服务传递的Binder对象，获取Binder暴露出来的数据</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"从服务端获取数据："</span> + mBinder.getCount());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"还没绑定呢，先绑定,无法从服务端获取数据"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">       conn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 与服务器端交互的接口方法 绑定服务的时候被回调，在这个方法获取绑定Service传递过来的IBinder对象，</span></span><br><span class="line"><span class="comment">             * 通过这个IBinder对象，实现宿主和Service的交互。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"绑定成功调用：onServiceConnected"</span>);</span><br><span class="line">                <span class="comment">// 获取Binder</span></span><br><span class="line">                mBinder = (LocalService.LocalBinder) service;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当取消绑定的时候被回调。但正常情况下是不被调用的，它的调用时机是当Service服务被意外销毁时，</span></span><br><span class="line"><span class="comment">             * 例如内存的资源不足时这个方法才被自动调用。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">                mBinder = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>onServiceConnected(ComponentName name, IBinder service)</strong><br>服务绑定成功后系统会调用该方法以传递服务的 onBind() 方法返回的 IBinder。其中 service 便是服务端返回的 IBinder 实现类对象，ComponentName 是一个封装了组件信息的类。</p>
</li>
<li><p><strong>onServiceDisconnected(ComponentName name)</strong><br>系统会在与服务的连接意外中断时（例如<strong>当服务崩溃或被终止</strong>时）调用该方法。<span style="color:red">注意:当客户端取消绑定时，系统“绝对不会”调用该方法</span>。</p>
</li>
<li><p><strong>bindService(Intent service, ServiceConnection conn, int flags)</strong></p>
<p>其中 Intent 是我们要绑定的服务的意图，而 ServiceConnection 代表与服务的连接，它只有两个方法，前面已分析过，flags 则是指定绑定时是否自动创建 Service 。0代表不自动创建、BIND_AUTO_CREATE 则代表自动创建。</p>
</li>
<li><p><strong>unbindService(ServiceConnection conn)</strong><br>该方法执行解除绑定的操作，其中 ServiceConnection 代表与服务的连接。</p>
</li>
</ul>
<h4 id="六、启动服务与绑定服务间的转换问题"><a href="#六、启动服务与绑定服务间的转换问题" class="headerlink" title="六、启动服务与绑定服务间的转换问题"></a>六、启动服务与绑定服务间的转换问题</h4><p>​        虽然服务的状态有启动和绑定两种，但实际上一个服务可以同时是这两种状态，它既可以是启动服务（以无限期运行），也可以是绑定服务。有点需要注意的是 Android 系统仅会为一个 Service 创建一个实例对象，所以不管是启动服务还是绑定服务，操作的是同一个 Service 实例，而且由于绑定服务或者启动服务执行顺序问题将会出现以下两种情况：<strong>（启动服务的优先级比绑定服务高一些）</strong></p>
<ul>
<li><p><strong>先绑定服务后启动服务</strong></p>
<p>如果当前 Service 实例先以绑定状态运行，然后再以启动状态运行，那么绑定服务将会转为启动服务运行，这时如果之前绑定的宿主（Activity）被销毁了，也不会影响服务的运行，服务还是会一直运行下去，指定收到调用停止服务或者内存不足时才会销毁该服务。</p>
</li>
<li><p><strong>先启动服务后绑定服务</strong></p>
<p>如果当前 Service 实例先以启动状态运行，然后再以绑定状态运行，当前启动服务并不会转为绑定服务，但是还是会与宿主绑定，只是即使宿主解除绑定后，服务依然按启动服务的生命周期在后台运行，直到有 Context调用了 stopService() 或是服务本身调用了 stopSelf() 方法抑或内存不足时才会销毁服务。</p>
</li>
</ul>
<h4 id="七、前台服务"><a href="#七、前台服务" class="headerlink" title="七、前台服务"></a>七、前台服务</h4><p>前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。前台服务必须为状态栏提供通知，设置服务运行于前台的方法。</p>
<h5 id="设置服务运行于前台"><a href="#设置服务运行于前台" class="headerlink" title="设置服务运行于前台"></a>设置服务运行于前台</h5><ul>
<li><p><strong>startForeground(int id, Notification notification)</strong></p>
<p>在 Service 创建 onCreate 时调用，该方法的作用是把当前服务设置为前台服务，其中id参数代表唯一标识通知的整型数，需要注意的是提供给 startForeground() 的整型 ID 不得为 0，而notification是一个状态栏的通知。Android 8.0之后对于通知栏也进行了整改，增加了通知渠道，通知组的概念。</p>
</li>
<li><p><strong>stopForeground(boolean removeNotification)</strong> </p>
<p>在 Service 销毁时调用，该方法是用来从前台删除服务，removeNotification 是否也删除状态栏通知。</p>
</li>
</ul>
<h5 id="启动前台服务"><a href="#启动前台服务" class="headerlink" title="启动前台服务"></a>启动前台服务</h5><p>在Android 8.0 之后需要使用 <strong>startForegroundService()</strong> 启动前台服务，并在清单文件中添加前</p>
<p>台服务权限 <code>android.permission.FOREGROUND_SERVICE</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">       startForegroundService(mForegroundService);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       startService(mForegroundService);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="八、如何提高服务在后台运行时间"><a href="#八、如何提高服务在后台运行时间" class="headerlink" title="八、如何提高服务在后台运行时间"></a>八、如何提高服务在后台运行时间</h4><p>关于 Service 保活后期会整理一篇主流的具体解决方案，主要思路是：</p>
<p>1.<strong>用 startService 方式启动 Service ，onStartCommand 方式中，返回 START_STICKY</strong> 。</p>
<p>2.<strong>提高 Service 的优先级</strong>，在清单文件中对于 intent-filter 可以通过 android:priority = “1000” 属性设置，1000是最高值，如果数字越小则优先级越低。</p>
<p>3.<strong>提升 Service 进程的优先级</strong>，使用前台服务。</p>
<p>4.<strong>设置应用白名单和电量管理</strong>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Service 实例对象同一应用中同时只会有一个。</li>
<li>Service默认并不会运行在子线程中，也不运行在一个独立的进程中，它同样执行在主线程中（UI线程）。换句话说，不要在Service里执行耗时操作，除非手动打开一个子线程，否则有可能出现主线程被阻塞（ANR）的情况。(Service执行的操作耗时最多是20s，BroadcastReceiver是10s，Activity是5s)</li>
<li>使用了远程 Service 后，Service 已经在另外一个进程当中运行了，所以只会阻塞该进程中的主线程，并不会影响到当前的应用程序。</li>
<li>默认 Service 和创建者在同一个进程内，如果将 Service 的 android:process 属性指定成” :remote”，表示Service 是在单独的进程创建远程服务。调用 startService 可以启动服务，但不能调用 bindService 绑定服务，因为创建者和 Service 运行在两个不同的进程中，不能再使用传统的建立关联的方式，需要使用 AIDL 来跨进程通信才可以绑定。</li>
<li>只有Activity、Service、Content Provider 能够绑定服务；BroadcastReceiver 广播接收器不能绑定服务</li>
</ul>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://blog.csdn.net/hdhhd/article/details/80612726" target="_blank" rel="noopener">安卓Service 详解</a></p>
<p><a href="https://www.jianshu.com/p/4c798c91a613" target="_blank" rel="noopener">Android Service两种启动方式详解</a></p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/11952435" target="_blank" rel="noopener">Android Service完全解析，关于服务你所需知道的一切</a></p>
<p><a href="https://blog.csdn.net/lmj623565791/article/details/47017485" target="_blank" rel="noopener">Android 基于Message的进程间通信 Messenger完全解析</a></p>
<p><a href="https://blog.csdn.net/lmj623565791/article/details/38461079" target="_blank" rel="noopener">Android aidl Binder框架浅析</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler消息机制</title>
    <url>/2020/08/02/Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android中的Handler消息机制。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、Handler消息机制是什么"><a href="#一、Handler消息机制是什么" class="headerlink" title="一、Handler消息机制是什么"></a>一、Handler消息机制是什么</h4><p>Handler 机制是 Android 中用于线程间通信的一套异步通信机制。官方的介绍是：</p>
<blockquote>
<p>A Handler allows you to send and process <code>Message</code> and Runnable objects associated with a thread’s <code>MessageQueue</code>. Each Handler instance is associated with a single thread and that thread’s message queue. When you create a new Handler it is bound to a <code>Looper</code>. It will deliver messages and runnables to that Looper’s message queue and execute them on that Looper’s thread.</p>
</blockquote>
<a id="more"></a>

<p>Handler 允许你发送和处理与线程的 MessageQueue 关联的 Message 和 Runnable 对象。每个 Handler 实例都与一个线程和该线程的消息队列关联。当你创建一个新的 Handler，它将绑定到 Looper。它将消息和 runnables传递到该 Looper 的消息队列，并在该 Looper 的线程上执行它们。</p>
<p>一句话解释 Handler 消息机制：</p>
<blockquote>
<p>Handler 通过执行其绑定线程的消息队列（MessageQueue）中不断被 Looper 循环取出的消息（Message）来完成线程间的通信。</p>
</blockquote>
<p>Handler 消息机制主要包含四个类：</p>
<ul>
<li><strong>Message</strong>：需要被传递的消息，消息分为硬件产生的消息(如按钮、触摸)和软件生成的消息；</li>
<li><strong>MessageQueue</strong>：负责消息的存储与管理，负责管理由 Handler 发送过来的 Message，消息队列的主要功能向消息池投递消息(<code>MessageQueue.enqueueMessage</code>)和取走消息池的消息(<code>MessageQueue.next</code>)；</li>
<li><strong>Handler</strong>：负责 Message 的发送及处理，主要功能向消息池发送各种消息事件(<code>Handler.sendMessage</code>)和处理相应消息事件(<code>Handler.handleMessage</code>)；</li>
<li><strong>Looper</strong>：负责关联线程以及消息的分发，不断循环执行(<code>Looper.loop</code>)，从 MessageQueue 获取 Message，按分发机制将消息分发给对应的 Handler 处理。</li>
</ul>
<p>四者之间关系：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghm259akbpj30kb0iignf.jpg" alt=""></p>
<ul>
<li><strong>Looper</strong>有一个 MessageQueue 消息队列；</li>
<li><strong>MessageQueue</strong>有一组待处理的 Message；</li>
<li><strong>Message</strong>中有一个用于处理消息的 Handler；</li>
<li><strong>Handler</strong>中有 Looper 和 MessageQueue。</li>
</ul>
<p>Handler 消息机制工作流程可以理解为传送带模型：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghm4dup2wxj30rk0e8tlh.jpg" alt=""></p>
<p>异步消息处理线程的写法应该是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper.prepare();<span class="comment">//初始化Looper，一定要写在Handler初始化之前</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 定义消息处理逻辑</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//所有的事情处理完成后要退出looper，即终止Looper循环</span></span><br><span class="line">        <span class="comment">//这两个方法都可以</span></span><br><span class="line">        <span class="comment">// handler.getLooper().quit();</span></span><br><span class="line">        <span class="comment">// handler.getLooper().quitSafely();</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Looper.loop();<span class="comment">//启动Looper循环</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、Looper"><a href="#二、Looper" class="headerlink" title="二、Looper"></a>二、Looper</h4><p>用于运行线程的消息循环的类。默认情况下线程没有与之关联的消息循环；在要运行循环的线程中调用 prepare() 来创建一个 Looper，然后调用 loop() 使其循环处理消息，直到循环结束为止。</p>
<h5 id="prepare"><a href="#prepare" class="headerlink" title="prepare()"></a>prepare()</h5><p>初始化 Looper 对象，对于无参的情况，默认调用<code>prepare(true)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Initialize the current thread as a looper.</span></span><br><span class="line"><span class="comment">  * This gives you a chance to create handlers that then reference</span></span><br><span class="line"><span class="comment">  * this looper, before actually starting the loop. Be sure to call</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #quit()&#125;.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有参情况，参数 quitAllowed，true 表示当前 Looper 允许退出，而 false 表示当前 Looper 不允许退出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每个线程只允许执行一次该方法，第二次执行时线程的TLS已有数据，则会抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Looper对象，并保存到当前线程的TLS区域</span></span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Looper.prepare() 在<strong>当前线程</strong>使用 ThreadLocal <strong>保存一个通过构造方法生成的Looper实例</strong>，并在 Looper 构造方法中会创建一个 MessageQueue 对象，<strong>保存一个MessageQueue实例</strong>。该方法在<strong>同一个线程只能调用一次</strong>，所以<strong>一个线程只会存在一个 Looper 和一个 MessageQueue</strong> 。</p>
<p>看看 <code>sThreadLocal</code> 的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></span><br><span class="line">   <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure>

<p>可以看出 <code>sThreadLocal</code> 是 ThreadLocal 类型，操作的类型都是 <code>Looper</code> 类型。</p>
<p><strong>ThreadLocal</strong>： 线程本地存储区（Thread Local Storage，简称为TLS），提供线程局部变量，每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。</p>
<p>作用：<strong>为每个线程提供一个独立的变量副本，以解决并发访问的冲突问题</strong>。</p>
<p>本质：<strong>ThreadLocal 的静态内部类 ThreadLocalMap 为每个 Thread 都维护了一个 Entry 类型数组 table，ThreadLocal 对象确定了一个数组下标，而这个下标就是 value 存储的对应位置。get的时候，都是从自己的变量中取值，所以不存在线程安全问题</strong>。</p>
<p>Entry 类是继承自弱引用，弱引用里面放的就是 ThreadLocal 对象，Entry 的 value 存的是当前线程要存储的对象，value 作为 Entry 的成员变量。</p>
<p><strong>每个线程都持有一个 ThreadLocalMap 对象，而 threadlocal 负责访问和维护 ThreadLocalMap</strong>。</p>
<p><strong>ThreadLocal 内存泄漏的问题，从上面分析可以发现 ThreadLocalMap 里面的 Entry 对象存储的ThreadLocal 弱引用，它并不会影响GC对于 ThreadLocal 对象的回收，但 value 直接作为 Entry 的强引用，ThreadLocal 对象可能被回收了，但 value 还在，这就造成了内存泄漏，因此在用到了 ThreadLocal 的地方，防止内存泄漏，手动调用 remove 方法。</strong></p>
<p>ThreadLocal 常用的操作方法：</p>
<ul>
<li><code>ThreadLocal.set(T value)</code>：将value存储到当前线程的TLS区域，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment">     * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment">     * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment">     * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment">     *        this thread-local.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ThreadLocal.get()</code>：获取当前线程TLS区域的数据，源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment">    * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment">    * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment">    * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>对于 Looper 类型的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数私有化，外界只能通过静态方法prepare()初始化Looper</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">  mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);<span class="comment">//创建MessageQueue对象</span></span><br><span class="line">  mThread = Thread.currentThread();<span class="comment">//记录当前线程.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，与 <code>prepare()</code> 相近功能的，还有一个 <code>prepareMainLooper()</code> 方法，该方法主要在 ActivityThread 类中使用，初始化主线程的 Looper 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment">     * application's main looper. The main looper for your application</span></span><br><span class="line"><span class="comment">     * is created by the Android environment, so you should never need</span></span><br><span class="line"><span class="comment">     * to call this function yourself.  See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>);<span class="comment">//设置不允许退出的Looper</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Looper<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">           <span class="comment">//将当前的Looper保存为主Looper，每个线程只允许执行一次。</span></span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="myLooper"><a href="#myLooper" class="headerlink" title="myLooper()"></a>myLooper()</h5><p>用于获取 TLS 存储的 Looper 对象，外部通过调用 Looper.myLooper() 方法获取当前线程绑定的 Looper 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return the Looper object associated with the current thread.  Returns</span></span><br><span class="line"><span class="comment">    * null if the calling thread is not associated with a Looper.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>myLooper()</code> 相近功能的，还有一个 <code>getMainLooper()</code> 方法，获取主线程 Looper 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the application's main looper, which lives in the main thread of the application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Looper<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sMainLooper;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="loop"><a href="#loop" class="headerlink" title="loop()"></a>loop()</h5><p>loop() 方法作用是让消息队列循环起来和分发消息，需要注意的是 Looper.loop() 应该在该 Looper 所绑定的线程中执行。其核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();<span class="comment">//获取TLS存储的Looper对象</span></span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;<span class="comment">//获取Looper对象中的消息队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//进入loop的主循环方法</span></span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block 可能会阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">               <span class="comment">// 没有消息，则退出循环</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            ...</span><br><span class="line">              </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);<span class="comment">//用于分发Message </span></span><br><span class="line">              ...</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();<span class="comment">//将Message放入消息池</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>loop() 进入循环模式，不断重复下面的操作，直到没有消息时退出循环。</p>
<ul>
<li><strong>Message msg = queue.next()</strong>，通过消息队列 MessageQueue 的 next() 方法从消息队列中取出一条消息 Message，如果此时消息队列中有 Message，那么 next 方法会立即返回该 Message，如果此时消息队列中没有 Message，那么 next 方法就会<strong>阻塞式</strong>地等待获取 Message ；</li>
<li><strong>msg.target.dispatchMessage(msg)</strong>，把 Message 分发给相应的 target ，target 值是 Handler，让 Message 所关联的 Handler 通过 dispatchMessage 方法让 Handler 处理该 Message ；</li>
<li><strong>msg.recycleUnchecked()</strong>，把分发后的 Message 回收到消息池，以便重复利用。</li>
</ul>
<h5 id="quit"><a href="#quit" class="headerlink" title="quit()"></a>quit()</h5><p>子线程开启的Looper，在所有的事情处理完成后要退出 Looper，即终止 Looper 循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//退出Looper，移除所有的消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mQueue.quit(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//安全退出Looper，只移除尚未触发的所有消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mQueue.quit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Looper.quit()方法的实现最终调用的是 MessageQueue.quit() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当mQuitAllowed为false，表示不运行退出，强行调用quit()会抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Main thread not allowed to quit."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="comment">//防止多次执行退出操作</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mQuitting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">                removeAllFutureMessagesLocked();<span class="comment">//移除尚未触发的所有消息</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                removeAllMessagesLocked();<span class="comment">//移除所有的消息</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意：线程 Thread 和 Looper 是一对一绑定的，一个线程可以有多个 Handler，但只能有一个 Looper，一个MessageQueue。</p>
<h4 id="三、Handler"><a href="#三、Handler" class="headerlink" title="三、Handler"></a>三、Handler</h4><h5 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h5><p>对于 Handler 的无参构造方法，默认采用当前线程 TLS 中的 Looper 对象，并且 Callback 回调方法为 null，且消息为同步处理方式。通过 ThreadLocal 获取到当前线程的 Looper 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造默认会调用该构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(@Nullable Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//匿名类、内部类或本地类都必须申明为static，否则会警告可能出现内存泄露</span></span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//必须先执行Looper.prepare()，才能获取Looper对象，否则为null.</span></span><br><span class="line">        mLooper = Looper.myLooper();<span class="comment">//从当前线程的TLS中获取Looper对象</span></span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread "</span> + Thread.currentThread()</span><br><span class="line">                        + <span class="string">" that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;<span class="comment">//消息队列，来自Looper对象</span></span><br><span class="line">        mCallback = callback;<span class="comment">//回调方法</span></span><br><span class="line">        mAsynchronous = async;<span class="comment">//设置消息是否为异步处理方式</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h5><p>Handler 类在构造方法中，可指定 Looper，Callback 回调方法以及消息的处理方式(同步或异步)，对于无 Looper 参的 Handler，默认是当前线程的 Looper 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(@Nullable Callback callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(callback, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(@NonNull Looper looper)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(@NonNull Looper looper, @Nullable Callback callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(looper, callback, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="keyword">null</span>, async);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(@NonNull Looper looper, @Nullable Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">   mLooper = looper;</span><br><span class="line">   mQueue = looper.mQueue;</span><br><span class="line">   mCallback = callback;</span><br><span class="line">   mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：在主线程中可以直接创建 Handler 对象，在子线程中需要先调用 Looper.prepare() 才能创建 Handler 对象。(因为程序启动时，ActivityThread 中的 main() 方法调用了 <code>Looper.prepareMainLooper()</code>，主线程中会始终存在一个 Looper 对象)</p>
<p>Callback 是 Handler 中的内部接口，Handler.Callback 是用来处理 Message 的一种手段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Callback interface you can use when instantiating a Handler to avoid</span></span><br><span class="line"><span class="comment">     * having to implement your own subclass of Handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> True if no further handling is desired</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(@NonNull Message msg)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Handler 处理 Message 的两种方法：</p>
<p>1.向 Hanlder 的构造函数传入一个 Handler.Callback 对象，并实现 Handler.Callback 的 handleMessage 方法；</p>
<p>2.无需向 Hanlder 的构造函数传入 Handler.Callback 对象，但是需要重写 Handler 本身的 handleMessage 方法。 </p>
<h5 id="消息分发机制"><a href="#消息分发机制" class="headerlink" title="消息分发机制"></a>消息分发机制</h5><p>在 Looper.loop() 中，当发现有消息时，调用消息的目标 handler，执行 <strong>dispatchMessage()</strong> 方法来分发消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handle system messages here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//当Message存在回调方法，回调msg.callback.run()方法；</span></span><br><span class="line">      handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//当Handler存在Callback成员变量时，回调Callback的handleMessage()；</span></span><br><span class="line">          <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//Handler自身的回调方法handleMessage()</span></span><br><span class="line">      handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行Message的回调方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//Handler自身的回调方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分发消息流程：</strong></p>
<ol>
<li>当<code>Message</code>的回调方法不为空时，则回调方法<code>msg.callback.run()</code>，其中 callBack 数据类型为 Runnable ，否则进入步骤2；</li>
<li>当<code>Handler</code>的<code>mCallback</code>成员变量不为空时，则回调方法<code>mCallback.handleMessage(msg)</code>，且回调方法要返回 true，否则进入步骤3；</li>
<li>调用<code>Handler</code>自身的回调方法<code>handleMessage()</code>，该方法默认为空，Handler 子类通过覆写该方法来完成具体的逻辑。</li>
</ol>
<h5 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h5><p>发送消息调用链：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghmzljvv00j30mu0ccwer.jpg" alt=""></p>
<p>可以发现所有的发消息方式，最终都是调用<code>MessageQueue.enqueueMessage()</code> 方法。</p>
<p><strong>sendMessage</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final boolean sendMessage(@NonNull Message msg) &#123;</span><br><span class="line">    return sendMessageDelayed(msg, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sendEmptyMessage</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>sendEmptyMessageDelayed</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = what;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>sendMessageDelayed</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>sendMessageAtTime</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>sendMessageAtFrontOfQueue</strong></p>
<p>该方法通过设置消息的触发时间为0，从而使 Message 加入到消息队列的队头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtFrontOfQueue</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>enqueueMessage</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(@NonNull MessageQueue queue, @NonNull Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        msg.target = <span class="keyword">this</span>;<span class="comment">//将Message的target绑定为当前的Handler </span></span><br><span class="line">        msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<span class="comment">//将消息添加到消息队列中</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>post</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(@NonNull Runnable r)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建了一个Message对象，并将传入的Runnable对象赋值给Message的callback，然后返回该Message</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>postDelayed</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(@NonNull Runnable r, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四、MessageQueue"><a href="#四、MessageQueue" class="headerlink" title="四、MessageQueue"></a>四、MessageQueue</h4><p>MessageQueue 是消息机制的 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 native 层来处理，其中MessageQueue 类中涉及的 native 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeDestroy</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePollOnce</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> timeoutMillis)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nativeIsPolling</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeSetFileDescriptorEvents</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">  mQuitAllowed = quitAllowed;</span><br><span class="line">  <span class="comment">//通过native方法初始化消息队列，其中mPtr是供native代码使用</span></span><br><span class="line">  mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="enqueueMessage"><a href="#enqueueMessage" class="headerlink" title="enqueueMessage"></a>enqueueMessage</h5><p>添加一条消息到消息队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 每一个普通Message必须有一个target</span></span><br><span class="line">       <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">//正在退出时，回收msg，加入到消息池</span></span><br><span class="line">               IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                       msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">               Log.w(TAG, e.getMessage(), e);</span><br><span class="line">               msg.recycle();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           msg.markInUse();</span><br><span class="line">           msg.when = when;</span><br><span class="line">           Message p = mMessages;</span><br><span class="line">           <span class="keyword">boolean</span> needWake;</span><br><span class="line">           <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">               <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">              <span class="comment">//p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的， 则进入该该分支</span></span><br><span class="line">               msg.next = p;</span><br><span class="line">               mMessages = msg;</span><br><span class="line">               needWake = mBlocked; <span class="comment">//当阻塞时需要唤醒</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">               <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">               <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">              <span class="comment">//将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非</span></span><br><span class="line">              <span class="comment">//消息队头存在barrier，并且同时Message是队列中最早的异步消息。</span></span><br><span class="line">               needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">               Message prev;</span><br><span class="line">               <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                   prev = p;</span><br><span class="line">                   p = p.next;</span><br><span class="line">                   <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                       needWake = <span class="keyword">false</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">               prev.next = msg;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">          <span class="comment">//消息没有退出，我们认为此时mPtr != 0</span></span><br><span class="line">           <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">               nativeWake(mPtr);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>MessageQueue 是按照 Message 触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p>
<h5 id="next"><a href="#next" class="headerlink" title="next"></a>next</h5><p>取出下一条消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;<span class="comment">//当消息循环已经退出，则直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// 循环迭代的首次为-1</span></span><br><span class="line">        <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span></span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                <span class="comment">//当遇到target为null的Message，说明是同步屏障，则查询异步消息</span></span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                  <span class="comment">//循环遍历找出一条异步消息，当查询到异步消息，则立刻退出循环，然后处理</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                       <span class="comment">//当异步消息触发时间大于当前时间，则设置下一次轮询的超时时长</span></span><br><span class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Got a message.</span></span><br><span class="line">                       <span class="comment">// 获取一条消息，并返回</span></span><br><span class="line">                        mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                       <span class="comment">//设置消息的使用状态，即flags |= FLAG_IN_USE</span></span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        <span class="keyword">return</span> msg;<span class="comment">//成功地获取MessageQueue中的下一条即将要执行的消息</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// No more messages.</span></span><br><span class="line">                   <span class="comment">//没有消息</span></span><br><span class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">               <span class="comment">//消息正在退出，返回null  </span></span><br><span class="line">               <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">                <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">                <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">              <span class="comment">//当消息队列为空，或者是消息队列的第一个消息时间大于当前时间</span></span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                   <span class="comment">//没有idle handlers 需要运行，则循环并等待。</span></span><br><span class="line">                    mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Run the idle handlers.</span></span><br><span class="line">            <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">           <span class="comment">//只有第一次循环时，会运行idle handlers，执行完成后，重置pendingIdleHandlerCount为0.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">                mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler 去掉handler的引用</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    keep = idler.queueIdle();<span class="comment">//idle时执行的方法，获取返回值</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">//idler.queueIdle()返回false时会移除idler，只执行一次</span></span><br><span class="line">                <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">           <span class="comment">//重置idle handler个数为0，以保证不会再次重复运行</span></span><br><span class="line">            pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">            <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">          <span class="comment">//当调用一个空闲handler时，一个新message能够被分发，因此无需等待可以直接查询pending message.</span></span><br><span class="line">            nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>nativePollOnce</code> 是阻塞操作，其中<code>nextPollTimeoutMillis</code>代表下一个消息到来前，还需要等待的时长；当nextPollTimeoutMillis = -1时，表示消息队列中无消息，会一直阻塞等待下去。</p>
<p>当处于空闲时，往往会执行<code>IdleHandler</code>中的方法。当 nativePollOnce() 返回后，next() 从<code>mMessages</code>中提取一个消息。</p>
<p><code>nativePollOnce()</code>在 native 做了大量的工作，想进一步了解可查看 <a href="http://gityuan.com/2015/12/27/handler-message-native/#nativepollonce" target="_blank" rel="noopener">Android消息机制2-Handler(native篇)</a>。</p>
<p><strong>此处用到了Linux的pipe/epoll机制：没有消息时阻塞线程并进入休眠释放cpu资源，有消息时唤醒线程</strong>。</p>
<h5 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h5><p>当线程将要进入堵塞，以等待更多消息时，会回调这个接口，简单点说：当 MessageQueue 中无可处理的Message 时回调。作用：<strong>UI线程处理完所有View事务后，回调一些额外的操作，且不会堵塞主进程；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Callback interface for discovering when a thread is going to block</span></span><br><span class="line"><span class="comment">     * waiting for more messages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Called when the message queue has run out of messages and will now</span></span><br><span class="line"><span class="comment">         * wait for more.  Return true to keep your idle handler active, false</span></span><br><span class="line"><span class="comment">         * to have it removed.  This may be called if there are still messages</span></span><br><span class="line"><span class="comment">         * pending in the queue, but they are all scheduled to be dispatched</span></span><br><span class="line"><span class="comment">         * after the current time.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接口中只有一个 queueIdle() 函数，线程进入堵塞时执行的额外操作可以写这里，返回值是 true 的话，执行完此方法后还会保留这个 IdleHandler，否则删除。</p>
<h5 id="removeMessages"><a href="#removeMessages" class="headerlink" title="removeMessages"></a>removeMessages</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="comment">// Remove all messages at front.</span></span><br><span class="line">           <span class="comment">//从消息队列的头部开始，移除所有符合条件的消息</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what</span><br><span class="line">                   &amp;&amp; (object == <span class="keyword">null</span> || p.obj == object)) &#123;</span><br><span class="line">                Message n = p.next;</span><br><span class="line">                mMessages = n;</span><br><span class="line">                p.recycleUnchecked();</span><br><span class="line">                p = n;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remove all messages after front.</span></span><br><span class="line">           <span class="comment">//移除剩余的符合要求的消息</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message n = p.next;</span><br><span class="line">                <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (n.target == h &amp;&amp; n.what == what</span><br><span class="line">                        &amp;&amp; (object == <span class="keyword">null</span> || n.obj == object)) &#123;</span><br><span class="line">                        Message nn = n.next;</span><br><span class="line">                        n.recycleUnchecked();</span><br><span class="line">                        p.next = nn;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                p = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个移除消息的方法，采用了两个 while 循环，第一个循环是从队头开始，移除符合条件的消息，第二个循环是从头部移除完连续的满足条件的消息之后，再从队列后面继续查询是否有满足条件的消息需要被移除。</p>
<h5 id="同步屏障机制"><a href="#同步屏障机制" class="headerlink" title="同步屏障机制"></a>同步屏障机制</h5><p>我们知道用 Handler 发送的 Message 后，MessageQueue 的 enqueueMessage() 按照 时间戳升序 将消息插入到队列中，而 Looper 则按照顺序，每次取出一枚Message进行分发，一个处理完到下一个。那么当<strong>有一个紧急的Message需要优先处理怎么破？</strong>一个 Message 分发给 Handler 后，执行了耗时操作，后面一堆本该到点执行的Message 在那里等着，这个时候你 sendMessage()，还是得排在这堆 Message 后，等他们执行完，再到你！</p>
<p>于是，Handler 中的 MessageQueue 加入了<strong>同步屏障</strong>这种机制，来实现<strong>异步消息优先执行</strong>的功能。</p>
<p>添加一个异步消息的方法很简单：</p>
<ul>
<li>Handler 构造方法中传入 async 参数，设置为 true，使用此 Handler 添加的 Message 都是异步的；</li>
<li>创建 Message 对象时，直接调用 setAsynchronous(true)</li>
</ul>
<h5 id="postSyncBarrier"><a href="#postSyncBarrier" class="headerlink" title="postSyncBarrier"></a>postSyncBarrier</h5><p>同步消息和异步消息没太大差别，但仅限于开启同步屏障之前。postSyncBarrier 只对同步消息产生影响，对于异步消息没有任何差别。可以通过 MessageQueue 的 postSyncBarrier 函数来开启同步屏障：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往消息队列合适的位置插入了同步屏障类型的Message (target属性为null)</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">       <span class="comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">           <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">           msg.markInUse();</span><br><span class="line">           msg.when = when;</span><br><span class="line">           msg.arg1 = token;<span class="comment">//初始化Msg时target没赋值，为null</span></span><br><span class="line"></span><br><span class="line">           Message prev = <span class="keyword">null</span>;</span><br><span class="line">           Message p = mMessages;</span><br><span class="line">           <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                   prev = p;</span><br><span class="line">                   p = p.next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">               msg.next = p;</span><br><span class="line">               prev.next = msg;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               msg.next = p;</span><br><span class="line">               mMessages = msg;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> token;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>每一个普通 Message 必须有一个 target，对于 target 为 null 的 Message，说明是同步屏障，循环遍历找出一条异步消息，然后处理。 这个消息的价值就是用于拦截同步消息，所以并不会唤醒 Looper。</p>
<h5 id="removeSyncBarrier"><a href="#removeSyncBarrier" class="headerlink" title="removeSyncBarrier"></a>removeSyncBarrier</h5><p>在同步屏障没移除前，只会处理异步消息，处理完所有的异步消息后，就会处于堵塞。如果想恢复处理同步消息，需要调用 removeSyncBarrier() 移除同步屏障：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">        <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            Message prev = <span class="keyword">null</span>;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">          <span class="comment">//从消息队列找到 target为空,并且token相等的Message</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The specified message queue synchronization "</span></span><br><span class="line">                        + <span class="string">" barrier token has not been posted or has already been removed."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = p.next;</span><br><span class="line">                needWake = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mMessages = p.next;</span><br><span class="line">                needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the loop is quitting then it is already awake.</span></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">            <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="五、Message"><a href="#五、Message" class="headerlink" title="五、Message"></a>五、Message</h4><h5 id="消息对象"><a href="#消息对象" class="headerlink" title="消息对象"></a>消息对象</h5><p>每个消息用 Message 表示，Message 主要包含以下内容：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">成员变量</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int</td>
<td align="left">what</td>
<td align="left">消息类别</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">when</td>
<td align="left">消息触发时间</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">arg1</td>
<td align="left">参数1</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">arg2</td>
<td align="left">参数2</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">obj</td>
<td align="left">消息内容</td>
</tr>
<tr>
<td align="left">Handler</td>
<td align="left">target</td>
<td align="left">消息响应方</td>
</tr>
<tr>
<td align="left">Runnable</td>
<td align="left">callback</td>
<td align="left">回调方法</td>
</tr>
</tbody></table>
<h5 id="消息池"><a href="#消息池" class="headerlink" title="消息池"></a>消息池</h5><p>静态变量<code>sPool</code>的数据类型为 Message，通过 next 成员变量，维护一个消息池；静态变量<code>MAX_POOL_SIZE</code>代表消息池的可用大小；消息池的默认大小为50。当消息池不为空时，可以直接从消息池中获取 Message 对象，而不是直接创建，提高效率。</p>
<p>消息池常用的操作方法是 obtain() 和 recycle()。</p>
<h5 id="obtain"><a href="#obtain" class="headerlink" title="obtain"></a>obtain</h5><p>从消息池中获取消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment">     * avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="keyword">null</span>;<span class="comment">//从sPool中取出一个Message对象，并消息链表断开</span></span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag 清除in-use flag</span></span><br><span class="line">                sPoolSize--;<span class="comment">//消息池的可用大小进行减1操作</span></span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>obtain()，从消息池取 Message，都是把消息池表头的 Message 取走，再把表头指向 next。</p>
<h5 id="recycle"><a href="#recycle" class="headerlink" title="recycle"></a>recycle</h5><p>把不再使用的消息加入消息池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isInUse()) &#123;<span class="comment">//判断消息是否正在使用</span></span><br><span class="line">            <span class="keyword">if</span> (gCheckRecycle) &#123;<span class="comment">//Android 5.0以后的版本默认为true,之前的版本默认为false.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span></span><br><span class="line">                        + <span class="string">"is still in use."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于不再使用的消息，加入到消息池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">        <span class="comment">// Clear out all other details.</span></span><br><span class="line">       <span class="comment">// 将消息标示位置为FLAG_IN_USE，并清空消息所有的参数，同时将其保留在回收对象池中</span></span><br><span class="line">        flags = FLAG_IN_USE;</span><br><span class="line">        what = <span class="number">0</span>;</span><br><span class="line">        arg1 = <span class="number">0</span>;</span><br><span class="line">        arg2 = <span class="number">0</span>;</span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        replyTo = <span class="keyword">null</span>;</span><br><span class="line">        sendingUid = UID_NONE;</span><br><span class="line">        workSourceUid = UID_NONE;</span><br><span class="line">        when = <span class="number">0</span>;</span><br><span class="line">        target = <span class="keyword">null</span>;</span><br><span class="line">        callback = <span class="keyword">null</span>;</span><br><span class="line">        data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;<span class="comment">//当消息池没有满时，将Message对象加入消息池</span></span><br><span class="line">                next = sPool;</span><br><span class="line">                sPool = <span class="keyword">this</span>;</span><br><span class="line">                sPoolSize++;<span class="comment">//消息池的可用大小进行加1操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>recycle()，将 Message 加入到消息池的过程，会把消息标示位置为 FLAG_IN_USE，并清空消息所有的参数，都是把 Message 加到链表的表头。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Handler 消息机制：</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghndj328rcj30p20fatah.jpg" alt=""></p>
<ul>
<li>Handler 通过 sendMessage() 发送 Message 到 MessageQueue 队列；</li>
<li>Looper 通过 loop()，不断提取出达到触发条件的 Message，并将 Message 交给 target 来处理；</li>
<li>经过 dispatchMessage() 后，交回给 Handler 的 handleMessage() 来进行相应地处理。</li>
<li>将 Message 加入 MessageQueue 时，往管道写入字符，可以会唤醒 loop 线程；如果 MessageQueue 中没有 Message，并处于 Idle 状态，则会执行 IdelHandler 接口中的方法，往往用于做一些清理性地工作。</li>
</ul>
<p><strong>Handler：</strong></p>
<p>内部实现主要涉及到如下几个类：Thread、MessageQueue 和 Looper，它们之间的关系：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghp0auiuk8j309r06qglm.jpg" alt=""></p>
<p>Thread 是最基础的，Looper 和 MessageQueue 都构建在 Thread 之上，Handler 又构建在 Looper 和 MessageQueue 之上，我们通过 Handler 间接地与下面这几个相对底层一点的类打交道。</p>
<p>Handler 创建的时候会采用当前线程的 Looper 来构造消息循环系统，<strong>Looper 在哪个线程创建，就跟哪个线程绑定</strong>，并且 <strong>Handler 处理消息是在它关联的 Looper 对应的线程中</strong>。</p>
<p><strong>消息分发的优先级：</strong></p>
<ol>
<li>Message 的回调方法：<code>message.callback.run()</code>，优先级最高；</li>
<li>Handler.Callback 的回调方法：<code>Handler.mCallback.handleMessage(msg)</code>，返回 true 时不会轮到步骤3，优先级仅次于1；</li>
<li>Handler 自身的默认方法：<code>Handler.handleMessage(msg)</code>，优先级最低。</li>
</ol>
<p><strong>消息缓存：</strong></p>
<p>为了提供效率，提供了一个大小为50的 Message 缓存队列，减少对象不断创建与销毁的过程。</p>
<p>引用文章：</p>
<blockquote>
<p><a href="http://blog.csdn.net/iispring/article/details/47180325" target="_blank" rel="noopener">深入源码解析Handler</a><br><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="noopener">Gityuan–消息机制Handler</a></p>
<p><a href="https://mp.weixin.qq.com/s/vCnftbD3z07X79gHj30Kiw" target="_blank" rel="noopener">关于Handler 的这 15 个问题，你都清楚吗？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler常见面试题</title>
    <url>/2020/08/10/Handler%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Handler机制是面试官非常喜欢问的知识点，本文主要是记录整理Handler相关面试题和解答。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h5 id="1、Handler：是什么？有什么用？为什么要用Handler，不用行不行？"><a href="#1、Handler：是什么？有什么用？为什么要用Handler，不用行不行？" class="headerlink" title="1、Handler：是什么？有什么用？为什么要用Handler，不用行不行？"></a>1、Handler：是什么？有什么用？为什么要用Handler，不用行不行？</h5><p>Android定义的一套 线程(子线程与主线程)间通讯的消息传递机制 。把子线程中的 UI更新信息，传递给主线程(UI线程)，以此完成UI更新操作。Android建议要求：我们在主线程(UI)线程中更新UI。Android的UI控件不是<strong>线程安全</strong>的，用Handler在多个线程并发更新UI的同时，保证线程的安全。</p>
<a id="more"></a>

<h5 id="2、真的只能在主-UI-线程中更新UI吗？子线程一定不能更新UI吗？"><a href="#2、真的只能在主-UI-线程中更新UI吗？子线程一定不能更新UI吗？" class="headerlink" title="2、真的只能在主(UI)线程中更新UI吗？子线程一定不能更新UI吗？"></a>2、真的只能在主(UI)线程中更新UI吗？子线程一定不能更新UI吗？</h5><p><strong>并不是的</strong>，子线程更新UI也行，但是只能更新自己创建的View！只有创建这个view的线程才能操作这个view，但不建议在子线程更新UI。Android的UI更新被设计成了单线程。ViewRootImp 在 onCreate() 时还没创建；在 onResume()时，即ActivityThread 的 handleResumeActivity() 执行后才创建，调用 requestLayout()，走到 checkThread() 时就报错了。</p>
<h5 id="3、真的不能在主-UI-线程中执行网络操作吗？"><a href="#3、真的不能在主-UI-线程中执行网络操作吗？" class="headerlink" title="3、真的不能在主(UI)线程中执行网络操作吗？"></a>3、真的不能在主(UI)线程中执行网络操作吗？</h5><p>把 StrictMode 的网络检测关了，就可以在主线程中执行网络操作了，不过一般是不建议这样做的。</p>
<h5 id="4、谈谈消息机制Handler作用-？有哪些要素-？流程是怎样的-？"><a href="#4、谈谈消息机制Handler作用-？有哪些要素-？流程是怎样的-？" class="headerlink" title="4、谈谈消息机制Handler作用 ？有哪些要素 ？流程是怎样的 ？"></a>4、谈谈消息机制Handler作用 ？有哪些要素 ？流程是怎样的 ？</h5><p>作用：负责<strong>线程间通信</strong>，这是因为<strong>在主线程不能做耗时操作，而子线程不能更新UI</strong></p>
<p>四大要素：</p>
<p><strong>Message</strong>：需要被传递的消息，消息分为硬件产生的消息（如按钮、触摸）和软件生成的消息。</p>
<p><strong>MessageQueue</strong>：负责消息的存储与管理，负责管理由 Handler发送过来的Message。</p>
<p><strong>Handler</strong>：负责Message的发送及处理。主要向消息池发送各种消息事件（Handler.sendMessage()）和处理相应消息事件（Handler.handleMessage()）。</p>
<p><strong>Looper</strong>：负责关联线程以及消息的分发，在该线程下从 MessageQueue获取 Message，分发给Handler，Looper创建的时候会创建一个 MessageQueue，调用loop()方法的时候消息循环开始，其中会不断调用messageQueue的next()方法，当有消息就处理，否则阻塞在messageQueue的next()方法中。当Looper的quit()被调用的时候会调用messageQueue的quit()，此时next()会返回null，然后loop()方法也就跟着退出。</p>
<p>具体流程：</p>
<p>在主线程创建的时候会创建一个Looper，同时也会在在Looper内部创建一个消息队列。而在创键Handler的时候取出当前线程的Looper，并通过该Looper对象获得消息队列，然后Handler在子线程中通过<strong>MessageQueue.enqueueMessage</strong>在消息队列中添加一条Message。</p>
<p>通过<strong>Looper.loop()</strong> 开启消息循环不断轮询调用 <strong>MessageQueue.next()</strong>，取得对应的Message并且通过<strong>Handler.dispatchMessage</strong>传递给Handler，最终调用<strong>Handler.handlerMessage</strong>处理消息。</p>
<h5 id="5、一个线程能否创建多个Handler，Handler跟Looper之间的对应关系-？"><a href="#5、一个线程能否创建多个Handler，Handler跟Looper之间的对应关系-？" class="headerlink" title="5、一个线程能否创建多个Handler，Handler跟Looper之间的对应关系 ？"></a>5、一个线程能否创建多个Handler，Handler跟Looper之间的对应关系 ？</h5><ul>
<li>一个Thread可以有多个Handler，但只能有一个Looper，一个MessageQueue。</li>
<li>以一个线程为基准，他们的数量级关系是： Thread(1) : Looper(1) : MessageQueue(1) : Handler(N)</li>
</ul>
<p>看Looper的创建，是在prepare()方法里。在创建之前去判断looper是否存在，存在就会抛出<code>Only one Looper may be created per thread</code>异常，这是在告诉我们一个线程只能有一个Looper。而TreadLocal的作用就是线程间隔离，确保一个线程对应一个Looper。然后在Looper构造方法中，初始化了一个MessageQueue。所以不管一个线程有多少个Handler，它们相关联的都是同一个Looper和MessageQueue。</p>
<h5 id="6、Message可以如何创建？哪种效果更好，为什么？"><a href="#6、Message可以如何创建？哪种效果更好，为什么？" class="headerlink" title="6、Message可以如何创建？哪种效果更好，为什么？"></a>6、Message可以如何创建？哪种效果更好，为什么？</h5><ul>
<li>直接生成实例<code>Message m = new Message()</code></li>
<li>通过<code>Message m = Message.obtain()</code></li>
<li>通过<code>Message m = mHandler.obtainMessage()</code></li>
</ul>
<p>建议使用后两者效果更好，默认的消息池中消息数量是50，后两者是直接在消息池中取出一个Message实例，这样做就可以避免多生成Message实例。</p>
<h5 id="7、为什么子线程中不可以直接new-Handler-而主线程中可以？"><a href="#7、为什么子线程中不可以直接new-Handler-而主线程中可以？" class="headerlink" title="7、为什么子线程中不可以直接new Handler()而主线程中可以？"></a>7、为什么子线程中不可以直接new Handler()而主线程中可以？</h5><p>因为在主线程启动时，主线程的Looper在ActivityThread中就通过prepareMainLooper() 完成了初始化。而子线程还需要调用手动调用 Looper.prepare()初始化Looper 和 Looper.loop()开启轮询。所以要在子线程创建Handler要先创建Looper，并开启Looper循环。主线程与子线程不共享同一个Looper实例。</p>
<h5 id="8、主线程给子线程的Handler发送消息怎么写？"><a href="#8、主线程给子线程的Handler发送消息怎么写？" class="headerlink" title="8、主线程给子线程的Handler发送消息怎么写？"></a>8、主线程给子线程的Handler发送消息怎么写？</h5><p>多线程并发的问题，当主线程执行到 sendEnptyMessage 时，子线程的 Handler 可能还没有创建，解决方法是：<strong>主线程延时给子线程发消息</strong>或者<strong>使用 HandlerThread 异步类</strong>。HandlerThread提供了主线程向子线程的通信。</p>
<h5 id="9、HandlerThread实现的核心原理？"><a href="#9、HandlerThread实现的核心原理？" class="headerlink" title="9、HandlerThread实现的核心原理？"></a>9、HandlerThread实现的核心原理？</h5><p><strong>HandlerThread = 继承Thread + 封装Looper + Handler</strong></p>
<p>源码分析：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghogfu4j9xj30hu08dt9j.jpg" alt=""></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghoggpff6kj30c1067jsa.jpg" alt=""></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghoghg7a2qj30jz0b5jsy.jpg" alt=""></p>
<p>HandlerThread的核心原理就是：</p>
<ul>
<li>继承Thread，getLooper()加锁死循环wait()堵塞；</li>
<li>run()加锁等待Looper对象创建成功，notifyAll()唤醒；</li>
<li>唤醒后，getLooper返回由run()中生成的Looper对象；</li>
</ul>
<p>总结：</p>
<ul>
<li><p>HandlerThread本质上是一个线程类，它继承了Thread。</p>
</li>
<li><p>HandlerThread有自己内部的Looper对象，可以进行Looper循环。</p>
</li>
<li><p>通过获取HandlerThread的Looper对象传递给Handler对象，可以在handlerMessage方法中执行异步任务。</p>
</li>
<li><p>优点是不会有堵塞，多次创建和销毁子线程是很耗费资源的，减少对性能的消耗，缺点是不能进行多任务的处理，需要等待进行处理，处理效率较低。</p>
</li>
<li><p>与线程池注重并发不同，HandlerThread是一个串行队列，HandlerThread背后只有一个线程。</p>
</li>
<li><p>在 HandlerThread 不使用的时候，需要调用退出方法<code>quit()/quitSafely()</code>，停止Looper。</p>
</li>
</ul>
<h5 id="10、Looper是怎么拣队列里的消息的？"><a href="#10、Looper是怎么拣队列里的消息的？" class="headerlink" title="10、Looper是怎么拣队列里的消息的？"></a>10、Looper是怎么拣队列里的消息的？</h5><p>由 Looper -&gt; loop函数-&gt;MessageQueue -&gt; next函数：</p>
<p>关键其实就是：nextPollTimeoutMillis，决定了堵塞与否，以及堵塞的时间，三种情况：</p>
<ol>
<li>等于0时，不堵塞，立即返回，Looper第一次处理消息，有一个消息处理完 ；</li>
<li>大于0时，最长堵塞等待时间，期间有新消息进来，可能会了立即返回(立即执行)；</li>
<li>等于-1时，无消息时，会一直堵塞；</li>
</ol>
<p><strong>此处用到了Linux的pipe/epoll机制：没有消息时阻塞线程并进入休眠释放cpu资源，有消息时唤醒线程；</strong></p>
<h5 id="11、分发给Handler的消息是怎么处理的？"><a href="#11、分发给Handler的消息是怎么处理的？" class="headerlink" title="11、分发给Handler的消息是怎么处理的？"></a>11、分发给Handler的消息是怎么处理的？</h5><p>通过MessageQueue的queue.next()拣出消息后，调用<code>msg.target.dispatchMessage(msg)</code><br>把消息分发给对应的Handler，调用 <code>dispatchMessage()</code> 方法。</p>
<p>回调优先级：</p>
<ol>
<li>Message 的回调方法：<code>message.callback.run()</code>，优先级最高；</li>
<li>Handler.Callback 的回调方法：<code>Handler.mCallback.handleMessage(msg)</code>，返回 true 时不会轮到步骤3，优先级仅次于1；</li>
<li>Handler 自身的默认方法：<code>Handler.handleMessage(msg)</code>，优先级最低。</li>
</ol>
<h5 id="12、IdleHandler是什么？"><a href="#12、IdleHandler是什么？" class="headerlink" title="12、IdleHandler是什么？"></a>12、IdleHandler是什么？</h5><p>在 MessageQueue 类中有一个 static 的接口 IdleHanlder。当线程将要进入堵塞，以等待更多消息时，会回调这个接口；简单点说：当MessageQueue中无可处理的Message时回调。</p>
<p>作用：<strong>UI线程处理完所有View事务后，回调一些额外的操作，且不会堵塞主进程；</strong></p>
<p>接口中只有一个 queueIdle() 函数，线程进入堵塞时执行的额外操作可以写这里，返回值是true的话，执行完此方法后还会保留这个IdleHandler，否则删除。使用方法：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gho6gn418dj30aq03mweo.jpg" alt=""></p>
<h5 id="13、Looper在主线程中死循环，为啥不会ANR？"><a href="#13、Looper在主线程中死循环，为啥不会ANR？" class="headerlink" title="13、Looper在主线程中死循环，为啥不会ANR？"></a>13、Looper在主线程中死循环，为啥不会ANR？</h5><ol>
<li><p>主线程的主要方法就是<strong>消息循环</strong>，一旦退出消息循环，那么你的应用也就退出了，Looer.loop() 方法可能会引起主线程的阻塞，但只要它的<strong>消息循环没有被阻塞</strong>，能一直处理事件就不会产生ANR异常。</p>
</li>
<li><p>造成<strong>ANR</strong>的不是主线程阻塞，而是主线程的Looper消息处理过程发生了<strong>任务阻塞</strong>，无法响应手势操作，不能及时刷新UI。</p>
</li>
<li><p><strong>阻塞与程序无响应</strong>没有必然关系，虽然主线程在没有消息可处理的时候是阻塞的，但是只要保证有消息的时候能够立刻处理，程序是不会无响应的。</p>
</li>
<li><p>真正会卡死主线程的操作是在回调方法onCreate/onStart/onResume等操作时间过长，会导致掉帧，甚至发生ANR，Looper.loop() 本身不会导致应用卡死。</p>
</li>
<li><p>Looper通过queue.next()获取消息队列消息，当队列为空，会堵塞，此时主线程也堵塞在这里，好处是：main函数无法退出，APP不会一启动就结束！</p>
<p>application启动时，可不止一个main线程，还有其他两个Binder线程：<strong>ApplicationThread</strong> 和 <strong>ActivityManagerProxy</strong>，用来和系统进程进行通信操作，接收系统进程发送的通知。</p>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gho6y2oscoj30ei094jtf.jpg" alt=""></p>
<ul>
<li><p>当系统受到因用户操作产生的通知时，会通过 Binder 方式跨进程通知 ApplicationThread;</p>
</li>
<li><p>它通过Handler机制，往 ActivityThread 的 MessageQueue 中插入消息，唤醒了主线程；</p>
</li>
<li><p>queue.next() 能拿到消息了,然后 dispatchMessage 完成事件分发。</p>
<p>死循环不会ANR，但是 dispatchMessage 中又可能会ANR哦！如果你在此执行一些耗时操作，导致这个消息一直没处理完，后面又接收到了很多消息，堆积太多，从而引起ANR异常。</p>
</li>
</ul>
<h5 id="14、主线程的死循环一直运行是不是特别消耗CPU资源呢？"><a href="#14、主线程的死循环一直运行是不是特别消耗CPU资源呢？" class="headerlink" title="14、主线程的死循环一直运行是不是特别消耗CPU资源呢？"></a>14、主线程的死循环一直运行是不是特别消耗CPU资源呢？</h5><p>其实不然，这里就涉及到Linux pipe/epoll机制，简单说就是在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。 </p>
<h5 id="15、Handler导致内存泄露的原因及正确写法"><a href="#15、Handler导致内存泄露的原因及正确写法" class="headerlink" title="15、Handler导致内存泄露的原因及正确写法"></a>15、Handler导致内存泄露的原因及正确写法</h5><p>泄露原因：非静态内部类默认持有外部类引用 + 生命周期不一致</p>
<p><strong>当Handler消息队列还有未处理的消息 或 正在处理消息而外部类需要销毁时，将使得外部类无法被垃圾回收器GC回收，从而造成内存泄露</strong>。</p>
<p>当Handler消息队列还有未处理的消息 / 正在处理消息，而外部类需销毁时，<strong>存在引用关系</strong>： <strong>“未被处理 / 正处理的消息Message -&gt; Handler实例 -&gt; 外部类Activity实例”</strong>，将使得外部类无法被垃圾回收器GC回收，从而造成内存泄露。</p>
<p>Handler 允许我们发送延时消息，如果在延时期间用户关闭了 Activity，那么该 Activity 无法被GC导致泄露。是因为 Message 会持有 Handler，由于 Java 的特性，非静态内部类 / 匿名内部类会持有外部类，使得 Activity 会被 Handler 持有，这样最终就导致 Activity 泄露。在Java中，非静态内部类 / 匿名内部类会持有一个外部类的隐式引用，可能会造成外部类无法被GC。</p>
<p>解决方案有两种：</p>
<ul>
<li><p>1.<strong>静态内部类+弱引用</strong></p>
<p>静态内部类默认不持有外部类的引用，<strong>将 Handler 定义成静态内部类，在内部持有Activity的弱引用</strong>。而单单使用静态内部类，Handler就不能调用Activity里的非静态方法了，所以加上弱引用持有外部Activity。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个弱引用持有外部类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;MainActivity&gt; context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyHandler</span><span class="params">(MainActivity context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = <span class="keyword">new</span> WeakReference&lt;MainActivity&gt;(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        MainActivity activity = context.get();</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                    activity.notifyUI();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>2.<strong>当外部类结束生命周期时，清空Handler内消息队列的消息</strong></p>
<p>在Acitivity的onDestroy()中调用<strong>handler.removeCallbacksAndMessages(null)</strong>移除所有消息。使得 Handler 的生命周期(即消息存在的时期)与外部类的生命周期同步。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 外部类Activity生命周期结束时，同时清空消息队列 &amp; 结束Handler生命周期</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用建议：为了保证Handler中消息队列中的所有消息都能被执行，推荐使用解决方案1解决内存泄露问题，即 <strong>静态内部类 + 弱引用的方式</strong></p>
<h5 id="16、Handler中的同步屏障机制"><a href="#16、Handler中的同步屏障机制" class="headerlink" title="16、Handler中的同步屏障机制"></a>16、Handler中的同步屏障机制</h5><p>作用：用来处理紧急的事件消息，View的刷新(16ms刷新)等。</p>
<p>我们知道用Handler发送的Message后，MessageQueue的enqueueMessage()按照 时间戳升序 将消息插入到队列中，而Looper则按照顺序，每次取出一枚Message进行分发，一个处理完到下一个。</p>
<p><strong>这时候，问题来了：有一个紧急的Message需要优先处理怎么破？</strong></p>
<p>Handler中加入了「同步屏障」这种机制，来实现「异步消息优先执行」的功能。</p>
<p>添加一个异步消息的方法很简单：</p>
<p>1、Handler构造方法中传入async参数，设置为true，使用此Handler添加的Message都是异步的；</p>
<p>2、创建Message对象时，直接调用setAsynchronous(true)</p>
<p>可以通过 MessageQueue 的 postSyncBarrier 函数来开启同步屏障：往消息队列合适的位置插入了同步屏障类型的Message (target属性为null)，接着，在 MessageQueue 执行到 next() 函数时：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOu2ZNAwZwOPb5hszoy7LYnoN5FKueEqsPG4gXiawQtIibMg4JqZL9O3mGKwTvjrSvT25IiaRAf7DWd9NtbhsSJTA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt=""></p>
<p>遇到target为null的Message，说明是同步屏障，循环遍历找出一条异步消息，然后处理。</p>
<p>在同步屏障没移除前，只会处理异步消息，处理完所有的异步消息后，就会处于堵塞。如果想恢复处理同步消息，需要调用 removeSyncBarrier() 移除同步屏障。</p>
<p>在API 28的版本中，postSyncBarrier()已被标注@hide被隐藏，如果要调用的话只能通过反射机制进行调用。在系统源码可找到相关应用，为了更快地响应UI刷新事件，在ViewRootImpl的scheduleTraversals函数中就用到了同步屏障：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gho7zziasxj30g5063wf2.jpg" alt=""></p>
<h5 id="17、当Activity有多个Handler的时候，Message消息是否会混乱？怎么样区分当前消息由哪个Handler处理？"><a href="#17、当Activity有多个Handler的时候，Message消息是否会混乱？怎么样区分当前消息由哪个Handler处理？" class="headerlink" title="17、当Activity有多个Handler的时候，Message消息是否会混乱？怎么样区分当前消息由哪个Handler处理？"></a>17、当Activity有多个Handler的时候，Message消息是否会混乱？怎么样区分当前消息由哪个Handler处理？</h5><p>不会混乱，哪个Handler发送的消息，到时候也是这个handler处理。在发送消息的时候，msg会绑定target，这个target就是Handler本身，在循环取出消息时会调用<code>msg.target.dispatchMessage(msg)</code>分发处理消息，这里的target就是当时发送消息绑定的 handler 。</p>
<h5 id="18、在子线程发送消息，却能够在主线程接收消息，主线程和子线程是怎么样切换的？"><a href="#18、在子线程发送消息，却能够在主线程接收消息，主线程和子线程是怎么样切换的？" class="headerlink" title="18、在子线程发送消息，却能够在主线程接收消息，主线程和子线程是怎么样切换的？"></a>18、在子线程发送消息，却能够在主线程接收消息，主线程和子线程是怎么样切换的？</h5><p>在子线程中用主线程 handler 发送消息，发送的消息被送到与主线程相关联的MessageQueue，也是主线程相关联的Looper在循环消息，handler所关联的是主线程的Looper和MessageQueue，所以最后消息的处理逻辑也是在主线程。只有发送消息是在子线程，其他都是在主线程。Handler与哪个线程的Looper相关联，消息处理逻辑就在与之关联的线程中执行，相应的消息的走向也就在相关联的MessageQueue中。所以子线程切换到主线程是很自然的过程，并没有想象中的复杂。</p>
<p>Handler消息机制用于同进程的线程间通信，其核心是<strong>线程间共享内存地址空间</strong>。即Handler实例对象mHandler位于线程间共享的内存堆上，工作线程与主线程都能直接使用该对象，只需要注意多线程的同步问题。</p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/vCnftbD3z07X79gHj30Kiw" target="_blank" rel="noopener">关于Handler 的这 15 个问题，你都清楚吗？</a></p>
<p><a href="https://blog.csdn.net/qian520ao/article/details/78262289#4-handler-是如何能够线程切换" target="_blank" rel="noopener">Android 消息机制——你真的了解Handler？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>HandlerThread源码分析</title>
    <url>/2020/08/04/HandlerThread%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android中的HandlerThread。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、HandlerThread是什么"><a href="#一、HandlerThread是什么" class="headerlink" title="一、HandlerThread是什么"></a>一、HandlerThread是什么</h4><p>HandlerThread 是 Android 已封装好的轻量级异步通信类。官方介绍：</p>
<blockquote>
<p>A <code>Thread</code> that has a <code>Looper</code>. The <code>Looper</code> can then be used to create <code>Handler</code>s.</p>
<p>Note that just like with a regular <code>Thread</code>, <code>Thread.start()</code> must still be called.</p>
</blockquote>
<p>一个具有 Looper 的线程。该 Looper 可以用来创建 Handler。和使用常规线程一样，<code>Thread.start()</code> 仍必须调用。</p>
<a id="more"></a>

<p><strong>产生背景</strong>：我们知道，耗时任务需要在子线程中进行，而线程的创建和销毁是非常消耗系统资源的，如果当任务 A 执行完了后，如果还需要执行任务 B， 那么就还需要创建一个新的子线程进行。这样性能问题就会凸显。为此，可以子线程中创建一个轮询器 Looper，当有新任务时，Looper 就开启并处理，否则就阻塞，直到下一个耗时任务的到来。因此，HandlerThread 内部封装了 Handler 和 Looper ，<strong>可以避免多次创建和销毁线程带来的性能问题</strong>。</p>
<p><strong>本质</strong>：HandlerThread 是一个线程，它继承自 Thread。内部封装了 Handler 和 Looper 来进行消息的分发、循环以及处理。<strong>通过继承Thread类</strong>和<strong>封装Handler类的使用</strong>，从而使得<strong>创建新线程和与其他线程进行通信</strong>变得更加方便易用。</p>
<p><strong>作用</strong>：实现多线程，在工作线程中执行任务，如耗时任务；实现异步通信、消息传递，实现工作线程和主线程(UI线程)之间的通信，即：将工作线程的执行结果传递给主线程，从而在主线程中执行相关的UI操作。</p>
<h4 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：创建HandlerThread实例对象</span></span><br><span class="line"><span class="comment">// 传入参数 = 线程名字，作用 = 标记该线程</span></span><br><span class="line">   HandlerThread mHandlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"handlerThread"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：启动线程</span></span><br><span class="line">   mHandlerThread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：创建工作线程Handler &amp; 复写handleMessage（）</span></span><br><span class="line"><span class="comment">// 作用：关联HandlerThread的Looper对象、实现消息处理操作 &amp; 与其他线程进行通信</span></span><br><span class="line"><span class="comment">// 注：消息处理操作handleMessage()的执行线程 = mHandlerThread所创建的工作线程中执行</span></span><br><span class="line">  Handler workHandler = <span class="keyword">new</span> Handler( handlerThread.getLooper() ) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                ...<span class="comment">//消息处理，通知主线程等</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤4：使用工作线程Handler向工作线程的消息队列发送消息</span></span><br><span class="line"><span class="comment">// 在工作线程中，当消息循环时取出对应消息 &amp; 在工作线程执行相关操作</span></span><br><span class="line">  <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">  Message msg = Message.obtain();</span><br><span class="line">  msg.what = <span class="number">2</span>; <span class="comment">//消息的标识</span></span><br><span class="line">  msg.obj = <span class="string">"B"</span>; <span class="comment">// 消息的存放</span></span><br><span class="line">  <span class="comment">// b. 通过Handler发送消息到其绑定的消息队列</span></span><br><span class="line">  workHandler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤5：结束线程，即停止线程的消息循环</span></span><br><span class="line">  mHandlerThread.quit();</span><br></pre></td></tr></table></figure>

<h4 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入线程名，默认优先级</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">super</span>(name);</span><br><span class="line">    mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义设置优先级</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a HandlerThread.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priority The priority to run the thread at. The value supplied must be from </span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> android.os.Process&#125; and not from java.lang.Thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    mPriority = priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>HandlerThread</code>类继承自<code>Thread</code>类；</li>
<li>创建<code>HandlerThread</code>类对象 = 创建<code>Thread</code>类对象 + 设置线程优先级 = <strong>新开1个工作线程 + 设置线程优先级</strong>。</li>
</ul>
<h5 id="run"><a href="#run" class="headerlink" title="run"></a>run</h5><p>启动线程，<code>mHandlerThread.start()</code>最终会回调 HandlerThread 的 run() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mTid = Process.myTid();</span><br><span class="line">  Looper.prepare(); <span class="comment">//为当前线程创建Looper对象</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//同步代码块</span></span><br><span class="line">  	mLooper = Looper.myLooper();<span class="comment">//获取Looper对象</span></span><br><span class="line">    <span class="comment">//阻塞--等待机制</span></span><br><span class="line">    <span class="comment">//发出通知，当前线程已经创建mLooper对象成功，这里主要是通知getLooper()中的等待锁wait()，结束阻塞等待</span></span><br><span class="line">    notifyAll();<span class="comment">//不会释放锁，继续执行后面的代码</span></span><br><span class="line">    <span class="comment">//此处使用持有锁机制 + notifyAll() 是为了保证后面获得Looper对象前就已创建好Looper对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  Process.setThreadPriority(mPriority);<span class="comment">//设置当前线程的优先级</span></span><br><span class="line">  onLooperPrepared();<span class="comment">//在线程循环消息之前做一些准备工作</span></span><br><span class="line">  Looper.loop(); <span class="comment">//开启循环，Handler从消息队列中处理消息</span></span><br><span class="line">  mTid = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为当前工作线程（即步骤1创建的线程）创建1个<code>Looper</code>对象 &amp; <code>MessageQueue</code>对象；</p>
</li>
<li><p>通过持有锁机制来获得当前线程的<code>Looper</code>对象；</p>
</li>
<li><p>发出通知：当前线程已经创建 mLooper 对象成功；</p>
</li>
<li><p>工作线程进行消息循环，即不断从 MessageQueue 中取消息 &amp; 派发消息。</p>
</li>
</ul>
<h5 id="onLooperPrepared"><a href="#onLooperPrepared" class="headerlink" title="onLooperPrepared"></a>onLooperPrepared</h5><p>重写该方法，可在 Looper 创建完成之后，开始循环消息之前可做一些准备工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Call back method that can be explicitly overridden if needed to execute some</span></span><br><span class="line"><span class="comment">    * setup before Looper loops.</span></span><br><span class="line"><span class="comment">    * 重写该方法，可在循环消息之前可做一些准备工作，在Loop.loop()方法之前调用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="getLooper"><a href="#getLooper" class="headerlink" title="getLooper"></a>getLooper</h5><p>获得当前 HandlerThread 线程中的 Looper 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method returns the Looper associated with this thread. If this thread not been started</span></span><br><span class="line"><span class="comment">     * or for any reason isAlive() returns false, this method will return null. If this thread</span></span><br><span class="line"><span class="comment">     * has been started, this method will block until the looper has been initialized.  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The looper.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 若线程不是存活的，则直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">      <span class="comment">//同步代码块：如果线程已经启动，但是Looper还未创建的话，就阻塞等待，直到run()中的Looper对象创建成功</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//阻塞-等待机制，确保已经创建了mLooper对象</span></span><br><span class="line">            <span class="comment">//开始循环等待，调用wait()去阻塞线程，</span></span><br><span class="line">            <span class="comment">//当run()中的notifyAll()调用之后，通知当前线程的wait方法结束等待，跳出循环。</span></span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();<span class="comment">//阻塞线程，等待，会释放锁，不再继续执行</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待唤醒后，结束等待，跳出循环，返回在run()中创建的mLooper对象</span></span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在获得<code>HandlerThread</code>工作线程的<code>Looper</code>对象时存在一个同步的问题：只有当线程创建成功 &amp; 其对应的<code>Looper</code>对象也创建成功后才能获得<code>Looper</code>的值，才能将创建的<code>Handler</code> 与 工作线程的<code>Looper</code>对象绑定，从而将<code>Handler</code>绑定工作线程。</p>
</li>
<li><p>解决方案：即保证同步的解决方案 = 同步锁、<code>wait（）</code> 和 <code>notifyAll（）</code>，即 在<code>run()</code>中成功创建<code>Looper</code>对象后，立即调用<code>notifyAll（）</code>通知 <code>getLooper()</code>中的<code>wait（）</code>结束等待 &amp; 返回<code>run()</code>中成功创建的<code>Looper</code>对象，使得<code>Handler</code>与该<code>Looper</code>对象绑定。</p>
</li>
</ul>
<h5 id="quit-quitSafely"><a href="#quit-quitSafely" class="headerlink" title="quit/quitSafely"></a>quit/quitSafely</h5><p>在 HandlerThread 不使用的时候，需要调用退出方法<code>quit()/quitSafely()</code>，结束线程，即停止线程的消息循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Looper looper = getLooper();</span><br><span class="line">       <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">           looper.quit();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Looper looper = getLooper();</span><br><span class="line">       <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">           looper.quitSafely();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HandlerThread 本质是一个线程类，继承自 Thread；</li>
<li>HandlerThread 有自己的内部 Looper 对象，可以进行 Looper 循环；</li>
<li>通过获取 HandlerThread 的 Looper 对象传递给 Handler，可以在 <code>handlerMessage()</code>中执行异步任务；</li>
<li>优点是减少了对性能的消耗，缺点是不能同时进行多任务的处理，需要等待处理，效率较低；</li>
<li>与线程池注重并发不同，HandlerThread 是一个串行队列，HandlerThread 背后已只有一个线程；</li>
<li>在 HandlerThread 不使用的时候，需要调用退出方法<code>quit()/quitSafely()</code>。</li>
</ul>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/4a8dc2f50ae6" target="_blank" rel="noopener">Android多线程：这是一份详细的HandlerThread源码分析攻略</a></p>
<p><a href="https://blog.csdn.net/hust_twj/article/details/87884318?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">Android消息机制之HandlerThread</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>IntentService源码分析</title>
    <url>/2020/08/06/IntentService%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android中的IntentService。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、IntentService是什么"><a href="#一、IntentService是什么" class="headerlink" title="一、IntentService是什么"></a>一、IntentService是什么</h4><p>IntentService 是 Android 里的一个封装的抽象类，继承自 Service。官方介绍：</p>
<blockquote>
<p>IntentService is a base class for <code>Service</code>s that handle asynchronous requests (expressed as <code>Intent</code>s) on demand. Clients send requests through <code>Context.startService(Intent)</code> calls; the service is started as needed, handles each Intent in turn using a worker thread, and stops itself when it runs out of work.</p>
</blockquote>
<a id="more"></a>

<p>IntentService 是处理异步请求服务的基类。客户端通过调用 Context.startService(Intent)发送请求，服务会使用一个工作线程依次处理每个意图，并在用完工作时自动停止。</p>
<p><strong>产生背景</strong>：如果想要在 Service 中做些耗时的操作，需要开启一个子线程然后内部执行耗时的操作，在执行完毕后如果需要自动停止服务需要在子线程的 run 方法中调用 stopSelf() 来停止服务，IntentService 类可以很方便的解决了自己开启线程和手动停止服务的问题，适合需要在工作线程处理 UI 无关任务的场景。</p>
<p><strong>本质</strong>：可以看做是 Service 和 HandlerThread 的结合体，封装了一个 HandlerThread 和 Handler 的异步框架，在完成了任务之后会自动停止。</p>
<p><strong>作用</strong>：处理异步请求和实现多线程。</p>
<h4 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h4><p>IntentService 是一个抽象类内部有一个抽象的方法 <code>onHandleIntent()</code>，继承至 Service 类。所以使用它需要继承它实现抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyIntentService"</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//构造函数，传入的字符串就是worker thread的名字  </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyIntentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">"MyIntentService"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//在这里通过intent携带的数据，开进行任务的操作。</span></span><br><span class="line">      Log.d(TAG, <span class="string">"onHandleIntent: "</span> + Thread.currentThread().getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onDestroy();</span><br><span class="line">      Log.d(TAG, <span class="string">"onDestroy: "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用 StartService() 启动异步后台服务类 IntentService。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">startService.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, MyIntentService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            startService(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h4><h5 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate"></a>onCreate</h5><p>方法会开启一个新的子线程 HandlerThread ( HandlerThread 内部封装了 Looper )，然后创建一个 ServiceHandler 与子线程中的 Looper 对象绑定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 通过实例化andlerThread新建线程 &amp; 启动；故 使用IntentService时，不需额外新建线程</span></span><br><span class="line">    <span class="comment">// HandlerThread继承自Thread，内部封装了 Looper</span></span><br><span class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2. 获得工作线程的 Looper &amp; 维护自己的工作队列</span></span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 新建mServiceHandler &amp; 绑定上述获得Looper</span></span><br><span class="line">    <span class="comment">// 新建的Handler 属于工作线程 -&gt;&gt;分析1</span></span><br><span class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 分析1：ServiceHandler源码分析</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 构造函数</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>(looper);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// IntentService的handleMessage（）把接收的消息交给onHandleIntent()处理</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// onHandleIntent 方法在工作线程中执行</span></span><br><span class="line">          <span class="comment">// onHandleIntent() = 抽象方法，使用时需重写 -&gt;&gt;分析2</span></span><br><span class="line">          onHandleIntent((Intent)msg.obj);</span><br><span class="line">          <span class="comment">// 执行完调用 stopSelf(startId) 结束服务</span></span><br><span class="line">          stopSelf(msg.arg1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="onHandleIntent"><a href="#onHandleIntent" class="headerlink" title="onHandleIntent"></a>onHandleIntent</h5><p>重写此方法进行耗时任务操作处理，该方法在工作线程上调用并请求处理，一次只处理一个意图，处理完所有意图请求后，会调用 <code>stopSelf(satrtId)</code> 停止 IntentService。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 分析2： onHandleIntent()源码分析</span></span><br><span class="line"><span class="comment">     * onHandleIntent() = 抽象方法，使用时需重写</span></span><br><span class="line"><span class="comment">     **/</span> </span><br><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="stopSelf"><a href="#stopSelf" class="headerlink" title="stopSelf"></a>stopSelf</h5><p>根据传入的 startId 来判断是否停止 IntentService。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stopSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stopSelf(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stopSelf</span><span class="params">(<span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mActivityManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mActivityManager.stopServiceToken(</span><br><span class="line">                    <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, mClassName), mToken, startId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在stopServiceToken() -&gt;&gt; mServices.stopServiceTokenLocked() 方法中会进行判断：</p>
<ul>
<li>startId &lt; 0：stopSelf() 方法会直接停止 Service；</li>
<li>startId &gt; 0 &amp;&amp; startId != ServiceRecord.lastStartId：不会停止 Service，代码流程直接返回；</li>
<li>startId &gt; 0 &amp;&amp; startId == ServiceRecord.lastStartId：直接停止 Service。</li>
</ul>
<h5 id="onStartCommand"><a href="#onStartCommand" class="headerlink" title="onStartCommand"></a>onStartCommand</h5><p>将 Intent 传递给 ServiceHandler 并依次插入到工作队列中，在方法中调用<code>onStart()</code>构建一个 Message 对象，并且将传递进来的 Intent 封装在 Message，通过 mServiceHandler 发送到消息队列中。经过 Looper 循环将消息分发到 ServiceHandler 的 handleMessage 中处理，从而传递给 <code>onHandleIntent()</code> 方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * onStartCommand（）源码分析</span></span><br><span class="line"><span class="comment">  * onHandleIntent() = 抽象方法，使用时需重写</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用onStart（）-&gt;&gt;分析1</span></span><br><span class="line">    onStart(intent, startId);</span><br><span class="line">    <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 分析1：onStart(intent, startId)</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 获得ServiceHandler消息的引用</span></span><br><span class="line">    Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">    msg.arg1 = startId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 把 Intent参数 包装到 message 的 obj 发送消息中，</span></span><br><span class="line">    <span class="comment">//这里的Intent  = 启动服务时startService(Intent) 里传入的 Intent</span></span><br><span class="line">    msg.obj = intent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 发送消息，即 添加到消息队列里</span></span><br><span class="line">    mServiceHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy"></a>onDestroy</h5><p>IntentService 销毁时，停止 Looper 并把消息队列中的所有消息给移除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//将消息队列中的所有消息给移除，包括处理中的和未处理的</span></span><br><span class="line">      mServiceLooper.quit();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><strong>1.为什么不建议通过 bindService() 启动 IntentService？</strong></p>
<p>IntentService 源码中的 onBind() 默认返回 null，bindService() 启动服务生命周期：onCreate() -&gt;&gt; onBind() -&gt;&gt; onunbind()-&gt;&gt; onDestory()，并不会调用<code>onStart()</code> 或 <code>onStartcommand()</code>，<strong>故不会将消息发送到消息队列，那么onHandleIntent()将不会回调，即无法实现多线程的操作</strong>。</p>
<p><strong>2.为什么多次启动 IntentService 会顺序执行事件，停止服务后，后续的事件得不到执行？</strong></p>
<p>由于<code>onCreate()</code>只会调用一次 = 只会创建1个工作线程；</p>
<p>当多次调用 <code>startService(Intent)</code>时（即 <code>onStartCommand（）</code>也会调用多次），其实不会创建新的工作线程，只是把消息加入消息队列中等待执行。而如果服务停止，会清除消息队列中的消息，后续的事件得不到执行。</p>
<p>一个请求处理完毕，如果此时没有新的请求，那么 IntentService 会进行销毁；一个请求还在处理过程中，如果有新的请求，那么 IntentService 会在本次请求处理完成后接着去处理新的请求，此时不会销毁。待所有请求处理完毕后，再进行销毁。是通过调用 stopSelf(satrtId) 方法 根据传入的 startId 来判断是否停止 IntentService。</p>
<h5 id="3-在源码handleMessage方法中为什么执行完onHandleIntent方法会去调用带参数的stopSelf-satrtId-？"><a href="#3-在源码handleMessage方法中为什么执行完onHandleIntent方法会去调用带参数的stopSelf-satrtId-？" class="headerlink" title="3.在源码handleMessage方法中为什么执行完onHandleIntent方法会去调用带参数的stopSelf(satrtId)？"></a>3.在源码handleMessage方法中为什么执行完onHandleIntent方法会去调用带参数的stopSelf(satrtId)？</h5><p>因为 <code>stopSelf()</code> 的执行会立刻将服务停止掉，而带参数的 <code>stopSelf(int startId)</code>会在所有任务执行完毕后将服务给停止。通常情况下调用 <code>stopSelf(int satrtId)</code> 方法会去判断最近执行意图的 startId 是否和传入的 startId 相等，如果相等就立刻执行停止服务的操作。</p>
<p><strong>4.启动 IntentService 为什么不需要新建线程？</strong><br>IntentService 内部的 HandlerThread 继承自 Thread，内部封装了 Looper，在这里新建线程并启动，所以启动 IntentService 不需要新建线程。</p>
<p><strong>5.onHandleIntent() 方法是在工作线程中执行</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>IntentService 是继承自 Service 并处理异步请求的一个类，在 IntentService 内有一个工作线程来处理耗时操作。</p>
<p>当任务执行完后，IntentService 会自动停止，不需要我们去手动结束。</p>
<p>如果启动 IntentService 多次，那么每一个耗时操作会以工作队列的方式在 IntentService 的 onHandleIntent 回调方法中执行，依次去执行，使用串行的方式，执行完自动结束。</p>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://blog.csdn.net/xlh1191860939/article/details/107225817" target="_blank" rel="noopener">从源码角度理解HandlerThread和IntentService</a></p>
<p><a href="https://www.jianshu.com/p/8a3c44a9173a" target="_blank" rel="noopener">Android多线程：这是一份全面 &amp; 详细的IntentService源码分析指南</a></p>
<p><a href="https://www.jianshu.com/p/8c4181049564" target="_blank" rel="noopener">Android IntentService使用介绍以及原理分析</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal源码分析</title>
    <url>/2020/08/08/ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android中的ThreadLocal。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、ThreadLocal是什么"><a href="#一、ThreadLocal是什么" class="headerlink" title="一、ThreadLocal是什么"></a>一、ThreadLocal是什么</h4><p>ThreadLocal 是线程局部(本地)变量，也许把它命名为 ThreadLocalVariable 更容易让人理解一些。官方介绍：</p>
<blockquote>
<p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its <code>get</code> or <code>set</code> method) has its own, independently initialized copy of the variable. <code>ThreadLocal</code> instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</p>
</blockquote>
<a id="more"></a>

<p>ThreadLocal 提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过 get 和 set 方法就可以得到当前线程对应的值。</p>
<p><strong>产生背景</strong>：在 Java 的多线程编程中，为保证多个线程对共享变量的安全访问，通常会使用 synchronized 来保证同一时刻只有一个线程对共享变量进行操作。当<strong>每个线程需要一个独享的对象</strong>或者<strong>线程内要保存全局变量</strong>时，可以将变量放到 ThreadLocal 类型的对象中，使变量在每个线程中都有独立拷贝，不会出现一个线程读取变量时而被另一个线程修改的现象。最常见的 ThreadLocal 使用场景为用来解决数据库连接、Session 管理等。</p>
<p><strong>本质</strong>：Thread 类有一个 ThreadLocal.ThreadLocalMap 类型的实例变量 threadLocals，ThreadLocal 的静态内部类 ThreadLocalMap 为每个 Thread 都维护了一个数组 table，ThreadLocal 对象确定了一个数组下标，而这个下标就是 value 存储的对应位置。</p>
<p><strong>作用</strong>：为解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal 比直接使用 synchronized 同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><h5 id="创建ThreadLocal变量"><a href="#创建ThreadLocal变量" class="headerlink" title="创建ThreadLocal变量"></a>创建ThreadLocal变量</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 直接创建对象</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal myThreadLocal = <span class="keyword">new</span> ThreadLocal()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建泛型对象</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal myThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建泛型对象 &amp; 初始化值</span></span><br><span class="line"><span class="comment">// 指定泛型的好处：不需要每次对使用get()方法返回的值作强制类型转换</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal myThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is the initial value"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特别注意：</span></span><br><span class="line"><span class="comment">// 1. ThreadLocal实例 = 类中的private、static字段</span></span><br><span class="line"><span class="comment">// 2. 只需实例化对象一次 &amp; 不需知道它是被哪个线程实例化</span></span><br><span class="line"><span class="comment">// 3. 每个线程都保持 对其线程局部变量副本 的隐式引用</span></span><br><span class="line"><span class="comment">// 4. 线程消失后，其线程局部实例的所有副本都会被垃圾回收（除非存在对这些副本的其他引用）</span></span><br><span class="line"><span class="comment">// 5. 虽然所有的线程都能访问到这个ThreadLocal实例，但是每个线程只能访问到自己通过调用ThreadLocal的set（）设置的值</span></span><br><span class="line"> <span class="comment">// 即 哪怕2个不同的线程在同一个ThreadLocal对象上设置了不同的值，他们仍然无法访问到对方的值</span></span><br></pre></td></tr></table></figure>

<h5 id="访问ThreadLocal变量"><a href="#访问ThreadLocal变量" class="headerlink" title="访问ThreadLocal变量"></a>访问ThreadLocal变量</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 设置值：set()</span></span><br><span class="line"><span class="comment">// 需要传入一个Object类型的参数</span></span><br><span class="line">myThreadLocal.set(<span class="string">"初始值”);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 2. 读取ThreadLocal变量中的值：get()</span></span><br><span class="line"><span class="string">// 返回一个Object对象</span></span><br><span class="line"><span class="string">String threadLocalValue = (String) myThreadLocal.get();</span></span><br></pre></td></tr></table></figure>

<h4 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h4><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//set 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取当前线程</span></span><br><span class="line">      Thread t = Thread.currentThread();</span><br><span class="line">      <span class="comment">//获取该线程的ThreadLocalMap对象</span></span><br><span class="line">      ThreadLocalMap map = getMap(t);</span><br><span class="line">      <span class="comment">//若该线程的ThreadLocalMap对象已存在，则设置该Map里ThreadLocal的值；否则创建1个ThreadLocalMap对象</span></span><br><span class="line">      <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">          map.set(<span class="keyword">this</span>, value);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//getMap方法，获取当前线程的threadLocals变量引用</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//thred中维护了一个ThreadLocalMap</span></span><br><span class="line">      <span class="keyword">return</span> t.threadLocals;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//createMap方法，创建当前线程的ThreadLocalMap对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//实例化一个新的ThreadLocalMap，并赋值给线程的成员变量threadLocals</span></span><br><span class="line">      <span class="comment">// a. ThreadLocalMap的键Key = 当前ThreadLocal实例</span></span><br><span class="line">      <span class="comment">// b. ThreadLocalMap的值 = 该线程设置的存储在ThreadLocal变量的值</span></span><br><span class="line">      t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread类 源码分析</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">     <span class="comment">// 即 Thread类持有threadLocals变量</span></span><br><span class="line">     <span class="comment">// 线程类实例化后，每个线程对象拥有独立的threadLocals变量变量</span></span><br><span class="line">     <span class="comment">// threadLocals变量在 ThreadLocal对象中 通过set（） 或 get（）进行操作</span></span><br><span class="line">     ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出<strong>每个线程持有一个ThreadLocalMap对象</strong>。每一个新的线程Thread都会实例化一个ThreadLocalMap并赋值给成员变量 threadLocals，使用时若已经存在threadLocals则直接使用已经存在的对象。</p>
<h5 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Entry为ThreadLocalMap静态内部类，对ThreadLocal的弱引用</span></span><br><span class="line">  <span class="comment">//同时让ThreadLocal和储值形成key-value的关系</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">           <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//数组的初始容量大小</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">  <span class="comment">//存放数据的Entry类型数组</span></span><br><span class="line">  <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//ThreadLocalMap构造方法</span></span><br><span class="line"> ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="comment">//内部成员数组，INITIAL_CAPACITY值为16的常量</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">        <span class="comment">//位运算，结果与取模相同，计算出需要存放的位置</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化 ThreadLocalMap 时创建了一个长度为16的 Entry 数组。通过 hashCode 与 length 位运算确定出一个索引值i，这个i就是被存储在 table 数组中的位置。每个线程 Thread 持有一个 ThreadLocalMap 类型的实例threadLocals 可理解成每个线程 Thread 都持有一个 Entry 型的数组 table，而一切的读取过程都是通过操作这个数组 table 完成的。</p>
<h5 id="ThreadLocalMap的set"><a href="#ThreadLocalMap的set" class="headerlink" title="ThreadLocalMap的set"></a>ThreadLocalMap的set</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">  Entry[] tab = table;</span><br><span class="line">  <span class="keyword">int</span> len = tab.length;</span><br><span class="line">  <span class="comment">//获取索引值，</span></span><br><span class="line">  <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历tab如果已经存在则更新值</span></span><br><span class="line">  <span class="keyword">for</span> (Entry e = tab[i];e != <span class="keyword">null</span>;e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">    <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">      e.value = value;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">      replaceStaleEntry(key, value, i);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果上面没有遍历成功则创建新值</span></span><br><span class="line">  tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">  <span class="keyword">int</span> sz = ++size;</span><br><span class="line">  <span class="comment">//满足条件数组扩容x2</span></span><br><span class="line">  <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ThreadLocalMap 中的 set 方法与构造方法能看到以下代码片段。</p>
<ul>
<li><code>int i = key.threadLocalHashCode &amp; (len-1)</code></li>
<li><code>int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1)</code><br>简而言之就是将threadLocalHashCode进行一个位运算（取模）得到索引i，threadLocalHashCode代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal中threadLocalHashCode相关代码.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next hash code to be given out. Updated atomically. Starts at</span></span><br><span class="line"><span class="comment"> * zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">    <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The difference between successively generated hash codes - turns</span></span><br><span class="line"><span class="comment"> * implicit sequential thread-local IDs into near-optimally spread</span></span><br><span class="line"><span class="comment"> * multiplicative hash values for power-of-two-sized tables.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the next hash code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自增</span></span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为static的原因，在每次<code>new ThreadLocal</code>时因为 threadLocalHashCode 的初始化，会使threadLocalHashCode 值自增一次，增量为0x61c88647。</p>
<p>0x61c88647是斐波那契散列乘数,它的优点是通过它散列(hash)出来的结果分布会比较均匀，可以很大程度上避免hash冲突。</p>
<p>综上可以得出：</p>
<p>1.对于某一 ThreadLocal 来讲，他的索引值i是确定的，在不同线程之间访问时访问的是不同的 table 数组的同一位置即都为 table[i]，只不过这个不同线程之间的 table 是独立的。</p>
<p>2.对于同一线程的不同 ThreadLocal 来讲，这些 ThreadLocal 实例共享一个 table 数组，然后每个 ThreadLocal 实例在 table 中的索引 i 是不同的。</p>
<p>即 ThreadLocal 中 set 和 get 操作的都是对应线程的 table数组，因此在不同的线程中访问同一个 ThreadLocal 对象的 set 和 get 进行存取数据是不会相互干扰的。</p>
<h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><p>通过计算出索引直接从数组对应位置读取即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal中get方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//若该线程的ThreadLocalMap对象已存在，则直接获取该Map里的值；</span></span><br><span class="line">    <span class="comment">//否则通过初始化函数创建1个ThreadLocalMap对象</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//ThreadLocalMap中getEntry方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">       Entry e = table[i];</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="setInitialValue"><a href="#setInitialValue" class="headerlink" title="setInitialValue"></a>setInitialValue</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 初始化ThreadLocal的值</span></span><br><span class="line"><span class="comment">    **/</span> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        T value = initialValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获得当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取该线程的ThreadLocalMap对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 3. 若该线程的ThreadLocalMap对象已存在，则直接替换该值；否则则创建</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value); <span class="comment">// 替换</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value); <span class="comment">// 创建</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="initialValue"><a href="#initialValue" class="headerlink" title="initialValue"></a>initialValue</h5><p>重写该方法可初始化值，默认情况下，initialValue方法返回的是null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal中remove方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 			<span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Remove the entry for key.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      <span class="comment">//ThreadLocalMap中remove方法</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    e.clear();<span class="comment">//这里的clear()方法实际上Reference中提供的方法</span></span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h5 id="ThreadLocal如何做到线程安全"><a href="#ThreadLocal如何做到线程安全" class="headerlink" title="ThreadLocal如何做到线程安全"></a>ThreadLocal如何做到线程安全</h5><ul>
<li>每个线程拥有自己独立的<code>ThreadLocals</code>变量（指向<code>ThreadLocalMap</code>对象 ）</li>
<li>每当线程 访问 <code>ThreadLocals</code>变量时，访问的都是各自线程自己的<code>ThreadLocalMap</code>变量（键 - 值）</li>
<li><code>ThreadLocalMap</code>变量的键 <code>key</code> = 唯一 = 当前<code>ThreadLocal</code>实例</li>
</ul>
<h5 id="与同步机制的区别"><a href="#与同步机制的区别" class="headerlink" title="与同步机制的区别"></a>与同步机制的区别</h5><p>ThreadLocal 和 Synchronized 都是为了解决多线程中相同变量的访问冲突问题，不同的点是</p>
<ul>
<li>Synchronized 是通过线程等待，牺牲时间来解决访问冲突，以时间换空间</li>
<li>ThreadLocal 是通过每个线程单独一份存储空间，牺牲空间来解决冲突，以空间换时间，并且相比于Synchronized，ThreadLocal 具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。</li>
</ul>
<p>因为 ThreadLocal 的线程隔离特性，在 android 中Looper、ActivityThread 以及 AMS 中都用到了 ThreadLocal。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal。</p>
<h5 id="防止ThreadLocal中的内存泄漏"><a href="#防止ThreadLocal中的内存泄漏" class="headerlink" title="防止ThreadLocal中的内存泄漏"></a>防止ThreadLocal中的内存泄漏</h5><p><code>ThreadLocalMap</code>的键<code>Key</code> = 当前<code>ThreadLocal</code>实例、值<code>value</code> = 该线程设置的存储在<code>ThreadLocal</code>变量的值</p>
<p>该<code>key</code>是 <code>ThreadLocal</code>对象的弱引用；当要抛弃掉<code>ThreadLocal</code>对象时，垃圾收集器会忽略该 <code>key</code>的引用而清理掉<code>ThreadLocal</code>对象</p>
<p><strong>ThreadLocalMap底层会维护一个Entry数组，而Entry本身却是WeakReference的子类，并且在构造器中将ThreadLocal传给了父类WeakReference。也就是说，Entry对于ThreadLocal持有的引用是弱引用，它并不会影响GC对于ThreadLocal对象的回收</strong>。</p>
<p>但是对于value 依旧是强引用，如果一个ThreadLocal对象被回收了，我们往里面放的value对于<strong>【当前线程-&gt;当前线程的threadLocals(ThreadLocal.ThreadLocalMap对象）-&gt;Entry数组-&gt;某个entry.value】</strong>这样一条强引用链是可达的，因此value不会被回收。如果不及时清理释放，是会导致内存泄漏的。所以，我们在不使用时，最好调用 ThreadLocal 的 <code>remove()</code> 方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在每个线程 Thread 内部有一个 ThreadLocal.ThreadLocalMap 类型的成员变量 threadLocals，这个threadLocals 就是用来存储实际的变量副本的，键值为当前 ThreadLocal 变量，value 为变量副本值(即T类型对象值)。</p>
<p>初始时，在 Thread 里面，threadLocals 为空，当通过 ThreadLocal 变量调用 get() 方法或者 set() 方法，就会对Thread类中的 threadLocals 进行初始化，并且以当前 ThreadLocal 变量为键值，以 ThreadLocal 要保存的副本变量为 value，存到 threadLocals。 然后在当前线程里面，如果要使用副本变量，就可以通过 get 方法在threadLocals 里面查找。</p>
<ul>
<li>每个Thread维护着一个ThreadLocalMap的引用；</li>
<li>ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储；</li>
<li>ThreadLocal创建的副本是存储在线程自己的threadLocals中的，也就是线程自己的ThreadLocalMap；</li>
<li>ThreadLocalMap的键值为ThreadLocal对象，因为每个线程可以有多个threadLocal变量，因此保存在ThreadLocalMap中，键值为ThreadLocal对象；</li>
<li>ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。</li>
</ul>
<p>引用文章：</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/22be9653df3f" target="_blank" rel="noopener">Java多线程：带你了解神秘的线程变量 ThreadLocal</a></p>
<p><a href="https://www.jianshu.com/p/3c5d7f09dfbd" target="_blank" rel="noopener">ThreadLocal</a></p>
<p><a href="https://www.cnblogs.com/micrari/p/6790229.html" target="_blank" rel="noopener">ThreadLocal源码解读</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder机制</title>
    <url>/2020/08/12/Binder%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android中的Binder机制。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、Binder是什么"><a href="#一、Binder是什么" class="headerlink" title="一、Binder是什么"></a>一、Binder是什么</h4><p>Binder 是 Android 系统进程间的一种通信机制，官方介绍：</p>
<blockquote>
<p>Base class for a remotable object, the core part of a lightweight remote procedure call mechanism defined by <code>IBinder</code>. This class is an implementation of IBinder that provides standard local implementation of such an object.</p>
</blockquote>
<p>远程对象的基类，它是 IBinder 定义的轻量级远程过程调用机制的核心部分。此类是 IBinder 的实现，它提供此类本地对象的标准实现。</p>
<a id="more"></a>

<p>我们知道 Android 应用程序是由 Activity、Service、Broadcast Receiver 和 Content Provider 四大组件中的一个或者多个组成的。有时这些组件运行在同一进程，有时运行在不同的进程。这些进程间的通信就依赖于 Binder IPC 机制。不仅如此，Android 系统对应用层提供的各种服务如：ActivityManagerService、PackageManagerService 等都是基于 Binder IPC 机制来实现的。Binder 机制在 Android 中的位置非常重要。</p>
<h4 id="二、为什么要用Binder"><a href="#二、为什么要用Binder" class="headerlink" title="二、为什么要用Binder"></a>二、为什么要用Binder</h4><p>Android 系统是基于 Linux 内核的，Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制。那为什么 Android 还要提供 Binder 来实现 IPC 呢？主要是基于<strong>性能</strong>、<strong>稳定性</strong>和<strong>安全性</strong>几方面的原因。</p>
<h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。<strong>Binder 只需要一次数据拷贝</strong>，性能上仅次于共享内存。注：各种IPC方式数据拷贝次数，此表来源于<a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android Binder 设计与实现 - 设计篇</a></p>
<table>
<thead>
<tr>
<th>IPC方式</th>
<th><strong>数据拷贝次数</strong></th>
</tr>
</thead>
<tbody><tr>
<td>共享内存</td>
<td>0</td>
</tr>
<tr>
<td>Binder</td>
<td>1</td>
</tr>
<tr>
<td>Socket/管道/消息队</td>
<td>2</td>
</tr>
</tbody></table>
<h5 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h5><p>再说说稳定性，<strong>Binder 基于 C/S 架构</strong>，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</p>
<h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><p>另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。<strong>Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志</strong>。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 <strong>Binder 既支持实名 Binder，又支持匿名 Binder</strong>，安全性高。</p>
<p>基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是 Binder。</p>
<h4 id="三-Linux下传统的进程间通信原理"><a href="#三-Linux下传统的进程间通信原理" class="headerlink" title="三. Linux下传统的进程间通信原理"></a>三. Linux下传统的进程间通信原理</h4><p>了解 Linux IPC 相关的概念和原理有助于我们理解 Binder 通信原理。因此，在介绍 Binder 跨进程通信原理之前，我们先聊聊 Linux 系统下传统的进程间通信是如何实现。</p>
<h5 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h5><p>这里我们先从 Linux 中进程间通信涉及的一些基本概念开始介绍，然后逐步展开，向大家说明传统的进程间通信的原理。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghuz8xxeeej30zk0n675v.jpg" alt=""></p>
<p>上图展示了 Liunx 中跨进程通信涉及到的一些基本概念：</p>
<ul>
<li>进程隔离</li>
<li>进程空间划分：用户空间(User Space)/内核空间(Kernel Space)</li>
<li>系统调用：用户态/内核态</li>
</ul>
<h5 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h5><p>简单的说就是操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）。</p>
<h5 id="进程空间划分：用户空间-User-Space-内核空间-Kernel-Space"><a href="#进程空间划分：用户空间-User-Space-内核空间-Kernel-Space" class="headerlink" title="进程空间划分：用户空间(User Space)/内核空间(Kernel Space)"></a>进程空间划分：用户空间(User Space)/内核空间(Kernel Space)</h5><p>现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。</p>
<p><strong>内核空间</strong>：是系统内核运行的空间，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。<strong>数据可共享，所有进程共用1个内核空间</strong>。</p>
<p><strong>用户空间</strong>：是用户程序运行的空间，没有接触物理内存或设备的权限。<strong>数据不可共享</strong>。</p>
<h5 id="系统调用：用户态与内核态"><a href="#系统调用：用户态与内核态" class="headerlink" title="系统调用：用户态与内核态"></a>系统调用：用户态与内核态</h5><p>虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助<strong>系统调用</strong>来实现。<strong>系统调用是用户空间访问内核空间的唯一方式</strong>，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p>
<p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于<strong>内核运行态（内核态）</strong>。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</p>
<p>当进程在执行用户自己的代码的时候，我们称其处于<strong>用户运行态（用户态）</strong>。此时处理器在特权级最低的（3级）用户代码中运行。</p>
<p>系统调用主要通过如下两个函数来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy_from_user() &#x2F;&#x2F;将数据从用户空间拷贝到内核空间</span><br><span class="line">copy_to_user() &#x2F;&#x2F;将数据从内核空间拷贝到用户空间</span><br></pre></td></tr></table></figure>

<h5 id="传统-IPC-通信原理"><a href="#传统-IPC-通信原理" class="headerlink" title="传统 IPC 通信原理"></a>传统 IPC 通信原理</h5><p>传统的 IPC 的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copy_from_user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghv0v787nwj30zk0ogn0j.jpg" alt=""></p>
<p>这种传统的 IPC 通信方式有两个问题：</p>
<ol>
<li>性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</li>
<li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。</li>
</ol>
<h4 id="四、Binder跨进程通信原理"><a href="#四、Binder跨进程通信原理" class="headerlink" title="四、Binder跨进程通信原理"></a>四、Binder跨进程通信原理</h4><h5 id="动态内核可加载模块-amp-amp-内存映射"><a href="#动态内核可加载模块-amp-amp-内存映射" class="headerlink" title="动态内核可加载模块 &amp;&amp; 内存映射"></a>动态内核可加载模块 &amp;&amp; 内存映射</h5><p>正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的<strong>动态内核可加载模块</strong>（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<blockquote>
<p>在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 <strong>Binder 驱动</strong>（Binder Dirver）。</p>
</blockquote>
<p>那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？这就不得不通道 Linux 下的另一个概念：<strong>内存映射</strong>。</p>
<p>Binder IPC 机制中涉及到的内存映射通过 <strong>mmap()</strong> 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是<strong>将用户空间的一块内存区域映射到内核空间</strong>。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</p>
<p><strong>内存映射能减少数据拷贝次数</strong>，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。mmap能够让虚拟内存和<strong>指定</strong>物理空间（磁盘/内存）映射起来。</p>
<h5 id="Binder-IPC-实现原理"><a href="#Binder-IPC-实现原理" class="headerlink" title="Binder IPC 实现原理"></a>Binder IPC 实现原理</h5><p>Binder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。</p>
<p>比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘–&gt;内核空间–&gt;用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。</p>
<p>而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是<strong>用来在内核空间创建数据接收的缓存空间</strong>。</p>
<p>一次完整的 Binder IPC 通信过程通常是这样：</p>
<ol>
<li>首先 Binder 驱动在内核空间创建一个<strong>数据接收缓存区</strong>；</li>
<li>接着在内核空间开辟一块<strong>内核缓存区</strong>，建立<strong>内核缓存区</strong>和<strong>内核中数据接收缓存区</strong>之间的映射关系，以及<strong>内核中数据接收缓存区</strong>和<strong>接收进程用户空间地址</strong>的映射关系；</li>
<li>发送方进程通过系统调用 copy_from_user() 将数据 copy 到内核中的<strong>内核缓存区</strong>，由于<strong>内核缓存区和接收进程的用户空间都映射到数据接收缓存区，所以两者也存在内存映射关系</strong>，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li>
</ol>
<p>如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghv2qmtimuj30zk0pdwis.jpg" alt=""></p>
<p><strong>总结</strong>：</p>
<ol>
<li>Linux的虚拟内存机制导致内存的隔离，进而导致进程隔离</li>
<li>进程隔离的出现导致对内存的操作被划分为用户空间和内核空间</li>
<li>用户空间需要跨权限去访问内核空间，必须使用系统调用去实现</li>
<li>系统调用需要借助内核模块/驱动去完成</li>
</ol>
<p>前三步决定了进程间通讯需要借助<strong>内核模块/驱动</strong>去实现，而 Binder 驱动就是内核模块/驱动中用来实现进程间通讯的。</p>
<h4 id="五、Binder-通信模型"><a href="#五、Binder-通信模型" class="headerlink" title="五、Binder 通信模型"></a>五、Binder 通信模型</h4><p>介绍完 Binder IPC 的底层通信原理，接下来我们看看实现层面是如何设计的。</p>
<p>一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程（Client）和服务端进程（Server），由于进程隔离机制的存在，通信双方必然需要借助 Binder 来实现。</p>
<h5 id="Client-Server-ServiceManager-驱动"><a href="#Client-Server-ServiceManager-驱动" class="headerlink" title="Client/Server/ServiceManager/驱动"></a>Client/Server/ServiceManager/驱动</h5><p>前面我们介绍过，Binder 是基于 C/S 架构的。由一系列的组件组成，包括Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghv3pv6tj0j30zk0kv77j.jpg" alt=""></p>
<p>Client、Server、ServiceManager、Binder 驱动这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之前的关系。</p>
<p><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android Binder 设计与实现</a>一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：</p>
<blockquote>
<p><strong>Binder 驱动</strong><br>Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。 </p>
<p><strong>ServiceManager 与实名 Binder</strong><br>ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。</p>
<p>细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER_SET_CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（<strong>这就是那只预先造好的那只鸡</strong>）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。</p>
<p><strong>Client 获得实名 Binder 的引用</strong><br>Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。</p>
</blockquote>
<ul>
<li><strong>Client</strong>：客户端。</li>
<li><strong>Server</strong>：服务端。</li>
<li><strong>ServiceManager</strong>（如同DNS域名服务器）：服务的管理者，提供服务的注册和查询。将 Binder 名字转换为 Client 中对该 Binder 的引用，使得 Client 可以通过 Binder 名字获得 Server 中 Binder 实体的引用，本身也是一个 Binder 服务。</li>
<li><strong>Binder驱动</strong>（如同路由器）：进程通信的介质，负责进程之间 binder 通信的建立，传递，计数管理以及数据的传递交互等底层支持。</li>
</ul>
<h5 id="Binder通信过程"><a href="#Binder通信过程" class="headerlink" title="Binder通信过程"></a>Binder通信过程</h5><p>至此，我们大致能总结出 Binder 通信过程：</p>
<ol>
<li>首先，一个进程使用 BINDER_SET_CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>
<li>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>
</ol>
<p>架构图如下所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghv4ottvlkj30pl0cgjuv.jpg" alt=""></p>
<p>可以看出无论是注册服务和获取服务的过程都需要ServiceManager，需要注意的是此处的Service Manager是指Native层的ServiceManager（C++），并非指framework层的ServiceManager(Java)。ServiceManager是整个Binder通信机制的大管家，是Android进程间通信机制Binder的守护进程，要掌握Binder机制，首先需要了解系统是如何首次<a href="http://gityuan.com/2015/11/07/binder-start-sm/" target="_blank" rel="noopener">启动Service Manager</a>。当Service Manager启动之后，Client端和Server端通信时都需要先<a href="http://gityuan.com/2015/11/08/binder-get-sm/" target="_blank" rel="noopener">获取Service Manager</a>接口，才能开始通信服务。</p>
<p>图中Client/Server/ServiceManage之间的相互通信都是基于Binder机制。既然基于Binder机制通信，那么同样也是C/S架构，则图中的3大步骤都有相应的Client端与Server端。</p>
<ol>
<li><strong><a href="http://gityuan.com/2015/11/14/binder-add-service/" target="_blank" rel="noopener">注册服务(addService)</a></strong>：Server进程要先注册Service到ServiceManager。该过程：Server是客户端，ServiceManager是服务端。</li>
<li><strong><a href="http://gityuan.com/2015/11/15/binder-get-service/" target="_blank" rel="noopener">获取服务(getService)</a></strong>：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。该过程：Client是客户端，ServiceManager是服务端。</li>
<li><strong>使用服务</strong>：Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互。该过程：client是客户端，server是服务端。</li>
</ol>
<p>图中的Client,Server,Service Manager之间交互都是虚线表示，是由于它们彼此之间不是直接交互的，而是都通过与<a href="http://gityuan.com/2015/11/01/binder-driver/" target="_blank" rel="noopener">Binder驱动</a>进行交互的，从而实现IPC通信方式。其中Binder驱动位于内核空间，Client,Server,Service Manager位于用户空间。Binder驱动和Service Manager可以看做是Android平台的基础架构，而Client和Server是Android的应用层，开发人员只需自定义实现client、Server端，借助Android的基本平台架构便可以直接进行IPC通信。</p>
<p>注意：</p>
<ul>
<li>每个 Binder 的 Server 进程会创建很多线程来处理 Binder 请求</li>
<li>Binder 模型的线程管理 采用 Binder 驱动的线程池，并由 Binder 驱动自身进行管理，而不是由 Server 进程来管理的</li>
<li>一个进程的 Binder 线程数默认最大是16，超过的请求会被阻塞等待空闲的 Binder 线程。如使用ContentProvider 时，它的 CRUD 方法只能同时有16个线程同时工作。</li>
</ul>
<h5 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h5><p>BpBinder(客户端)和 BBinder(服务端)都是 Android 中 Binder 通信相关的代表，它们都从 IBinder 类中派生而来，它们属于 Native 层，关系图如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghw4y8di3ij30a107qq37.jpg" alt=""></p>
<ul>
<li>client端：BpBinder.transact()来发送事务请求，是 Binder 引用对象；</li>
<li>server端：BBinder.onTransact()会接收到相应事务，是 Binder 实体对象。</li>
</ul>
<h5 id="Binder通信中的代理模式"><a href="#Binder通信中的代理模式" class="headerlink" title="Binder通信中的代理模式"></a>Binder通信中的代理模式</h5><p>我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程 没法直接使用 B 进程中的 object。</p>
<p>前面我们介绍过跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。</p>
<p>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghw5dr45igj30zk0iwjtm.jpg" alt=""></p>
<ul>
<li>Binder对象：Binder机制中进行进程间通讯的对象，对于Server端为Binder本地对象，对于Client端为Binder代理对象。</li>
<li>Binder驱动：Binder机制中进行进程间通讯的介质，Binder驱动会对具有跨进程传递能力的对象做特殊处理，自动完成代理对象和本地对象的转换。因此在驱动中保存了每一个跨越进程的Binder对象的相关信息，Binder本地对象（或Binder实体）保存在binder_node的数据结构，Binder代理对象（或Binder引用/句柄）保存在binder_ref的数据结构。</li>
</ul>
<h5 id="Binder的完整定义"><a href="#Binder的完整定义" class="headerlink" title="Binder的完整定义"></a>Binder的完整定义</h5><p>现在我们可以对 Binder 做个更加全面的定义了：</p>
<ul>
<li>从进程间通信的角度看，Binder 是一种进程间通信的机制；</li>
<li>从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象；</li>
<li>从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理；</li>
<li>从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象做特殊处理，自动完成代理对象和本地对象之间的转换；</li>
<li>从 Android Driver 层的角度看，Binder 是一种虚拟的物理设备，它的设备驱动是 /dev/binder；</li>
<li>从 Android Framework 来讲，Binder是 Service Manager 连接各种 Manager 和对应的 ManagerService 的桥梁。</li>
</ul>
<h4 id="六、AIDL"><a href="#六、AIDL" class="headerlink" title="六、AIDL"></a>六、AIDL</h4><p>通常我们在做开发时，实现进程间通信用的最多的就是 AIDL——Android接口定义语言。当我们定义好 AIDL 文件，在编译时编译器会帮我们生成代码实现 IPC 通信。借助 AIDL 编译以后的代码能帮助我们进一步理解 Binder IPC 的通信原理。基于Binder，Android还实现了其他的IPC方式，比如 Messenger 和 ContentProvider 。</p>
<p>但是无论是从可读性还是可理解性上来看，编译器生成的代码对开发者并不友好。比如一个 BookManager.aidl 文件对应会生成一个 BookManager.java 文件，这个 java 文件包含了一个 BookManager 接口、一个 Stub 静态的抽象类和一个 Proxy 静态类。Proxy 是 Stub 的静态内部类，Stub 又是 BookManager 的静态内部类，这就造成了可读性和可理解性的问题。</p>
<blockquote>
<p>Android 之所以这样设计其实是有道理的，因为当有多个 AIDL 文件的时候把 BookManager、Stub、Proxy 放在同一个文件里能有效避免 Stub 和 Proxy 重名的问题。</p>
</blockquote>
<h5 id="各Java类职责描述"><a href="#各Java类职责描述" class="headerlink" title="各Java类职责描述"></a>各Java类职责描述</h5><p>在正式编码实现跨进程调用之前，先介绍下实现过程中用到的一些类。了解了这些类的职责，有助于我们更好的理解和实现跨进程通信。</p>
<ul>
<li><strong>IBinder</strong>：是一个接口，定义了Java层Binder通信的一些规则；提供了transact方法来调用远程服务，代表了一种跨进程通信的能力。只要实现了这个接口，这个对象就能跨进程传输。这是 Binder 驱动底层支持的，Binder 驱动会自动完成不同进程 Binder 本地对象以及Binder 代理对象的转换。</li>
<li><strong>IInterface</strong>：Client 端与 Server 端的调用契约，代表了 Server 进程对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口方法），所有的服务提供者，必须继承这个接口。</li>
<li><strong>Binder</strong>：Java 层的 Binder 类，代表的就是 Binder 本地对象。BinderProxy 类是代表远程进程的 Binder 本地对象的代理；这两个类都继承自 IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换。</li>
<li><strong>Stub</strong>：AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类；这个类继承了 Binder，说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。这里使用了策略模式。</li>
<li><strong>Proxy</strong>：服务端 Binder 本地对象代理，客户端通过这个类调用服务端的方法。</li>
<li><strong>Parcel</strong>：是一个容器，它主要用于存储序列化数据，然后可以通过 Binder 在进程间传递这些数据。</li>
</ul>
<h5 id="AIDL语法"><a href="#AIDL语法" class="headerlink" title="AIDL语法"></a>AIDL语法</h5><ul>
<li><p>文件类型：用AIDL书写的文件的后缀是 .aidl，而不是 .java。</p>
</li>
<li><p>数据类型：AIDL默认支持一些数据类型，在使用这些数据类型的时候是不需要导包的，但是除了这些类型之外的数据类型，在使用之前必须导包，<strong>就算目标文件与当前正在编写的 .aidl 文件在同一个包下</strong>——在 Java 中，这种情况是不需要导包的。比如，现在我们编写了两个文件，一个叫做 <strong>Book.java</strong> ，另一个叫做 <strong>BookManager.aidl</strong>，它们都在 <strong>com.prsuit.androidlearnsample</strong> 包下 ，现在我们需要在 .aidl 文件里使用 Book 对象，那么我们就必须在 .aidl 文件里面写上 <strong><code>import com.prsuit.androidlearnsample.Book;</code></strong> 哪怕 .java 文件和 .aidl 文件就在一个包下。<br>默认支持的数据类型包括： </p>
<ul>
<li>Java 中的基本数据类型( byte，short(不支持short，编译不通过)，int，long，float，double，boolean，char)，String 和 CharSequence类型。</li>
<li>List 和 Map：元素必须是 AIDL 支持的数据类型之一，Server 端具体的类里必须是 ArrayList 或者 HashMap。</li>
<li>AILD：其他 AIDL 生成的接口。</li>
<li>除了默认支持的数据类型外，AIDL 还支持自定义实现 Parcelable 接口的数据类型。</li>
</ul>
</li>
<li><p>定向tag：方法内如果有传输载体，就必须指明定向 tag (<a href="http://blog.csdn.net/luoyanglizi/article/details/51958091" target="_blank" rel="noopener">in,out,inout</a>)。</p>
<ul>
<li>in：<strong>客户端数据对象流向服务端</strong>，并且服务端对该数据对象的修改不会影响到客户端。</li>
<li>out： <strong>数据对象由服务端流向客户端</strong>，（客户端传递的数据对象此时服务端收到的对象内容为空，服务端可以对该数据对象修改，并传给客户端）。</li>
<li>inout：<strong>数据可在服务端与客户端之间双向流通</strong>，服务端将会接收到客户端传来对象的完整信息，并且客户端将会同步服务端对该对象的任何变动。（但是不建议用此 tag，会增加开销）。</li>
</ul>
</li>
<li><p>两种AIDL文件：<strong>一类是用来定义 parcelable 对象</strong>，以供其他 AIDL 文件使用非默认支持的数据类型。<strong>一类是用来定义方法接口</strong>，以供系统使用来完成跨进程通信的。<strong>所有的非默认支持数据类型必须通过第一类AIDL文件定义才能被使用。</strong></p>
</li>
</ul>
<h5 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h5><p><strong>创建实体类</strong></p>
<p>实体类要实现 Parcelable 接口，且要手动添加 <code>readFromParcel</code> 方法（不然只支持 in 的定向tag）。</p>
<p>注：<strong>若AIDL文件中涉及到的所有数据类型均为默认支持的数据类型，则无此步骤。因为默认支持的那些数据类型都是可序列化的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = in.readString();</span><br><span class="line">        <span class="keyword">this</span>.price = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Book&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法不是Parcelable自动生成的，需要自己手动添加，</span></span><br><span class="line">    <span class="comment">// 如果不添加，则在使用AIDL时只支持 in 的定向tag</span></span><br><span class="line">    <span class="comment">// 如果添加了，则支持 out、inout</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFromParcel</span><span class="params">(Parcel dest)</span></span>&#123;</span><br><span class="line">      <span class="comment">//注意，此处的读值顺序应当是和writeToParcel()方法中一致的</span></span><br><span class="line">        name = dest.readString();</span><br><span class="line">        price = dest.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">//get set方法</span></span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建定义parcelable对象的AIDL文件</strong></p>
<p>因为AIDL这个语言的规范就是 aidl 文件，所以我们必须将<code>Book</code>实体类转为 aidl 文件，供其它 aidl 的调用与交互。<strong>Book.aidl与Book.java的包名要是一样的</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Book.aidl</span></span><br><span class="line"><span class="comment">//第一类AIDL文件</span></span><br><span class="line"><span class="comment">//这个文件的作用是引入了一个序列化对象 Book 供其他的AIDL文件使用</span></span><br><span class="line"><span class="comment">//注意：Book.aidl与Book.java的包名应当是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.prsuit.androidlearnsample;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"><span class="comment">//注意parcelable是小写</span></span><br><span class="line">parcelable Book;</span><br></pre></td></tr></table></figure>

<p>如何在保证两个文件包名一样的情况下，让系统能够找到我们的 java 文件？思路：要么让系统来 aidl 包里面来找 java 文件，要么把 java 文件放到系统能找到的地方去，也即放到 java 包里面去。这两种方式具体做法：</p>
<ul>
<li><p>修改 build.gradle 文件，通过 sourceSets 配置把 java 的访问路径设置成了 java 包和 aidl 包，在 android{} 中加上下面的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        java.srcDirs = [<span class="string">'src/main/java'</span>, <span class="string">'src/main/aidl'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把 java 文件放到 java 包下去：把 Book.java 放到 java 包里任意一个包下，保持其包名不变，与 Book.aidl 一致。只要它的包名不变，Book.aidl 就能找到 Book.java ，而只要 Book.java 在 java 包下，那么系统也是能找到它的。注意在移植相关 .aidl 文件时，不能直接把整个 aidl 文件夹拿过去完事了，还要单独将 .java 文件放到 java 文件夹里去。</p>
</li>
</ul>
<p><strong>创建定义方法接口的AIDL文件</strong></p>
<p>该文件是 Client 端与 Server 端的调用契约，定义 Server 进程对象具备什么样的能力。</p>
<p>注：<strong>接口方法 aidl 中不能存在同方法名不同参数的方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.prsuit.androidlearnsample;</span><br><span class="line"><span class="keyword">import</span> com.prsuit.androidlearnsample.Book;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//有返回值前都不需要加任何东西，不管是什么数据类型</span></span><br><span class="line">  <span class="function">List&lt;Book&gt; <span class="title">getBooks</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Java基本类型以及String，CharSequence的 tag 默认且只能是 in</span></span><br><span class="line">  <span class="comment">//传参时除了Java基本类型以及String，CharSequence之外的类型</span></span><br><span class="line">  <span class="comment">//如果有传输对象载体，就必须指明定向tag(in,out,inout)</span></span><br><span class="line">  <span class="function">Book <span class="title">addBookIn</span><span class="params">(in Book book)</span></span>;<span class="comment">//客户端-&gt;服务端</span></span><br><span class="line">  <span class="comment">//out和inout都需要重写MessageBean的readFromParcel方法</span></span><br><span class="line">  <span class="function">Book <span class="title">addBookOut</span><span class="params">(out Book book)</span></span>;<span class="comment">//服务端-&gt;客户端</span></span><br><span class="line">  <span class="function">Book <span class="title">addBookInOut</span><span class="params">(inout Book book)</span></span>;<span class="comment">//客户端&lt;-&gt;服务端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编写服务端代码</strong></p>
<p>在我们写完AIDL文件并 Make Project 项目之后，编译器会根据AIDL文件为我们生成一个与AIDL文件同名的 .java 文件，这个 .java 文件才是与我们的跨进程通信密切相关的东西。在服务端实现AIDL中定义的方法接口的具体逻辑，创建一个服务，用来处理客户端发来的请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 服务端的AIDLService.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIDLService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = <span class="string">"AIDLService"</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; mBooks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由AIDL文件生成的IBookManager</span></span><br><span class="line">    <span class="keyword">private</span> IBookManager.Stub mBookManager = <span class="keyword">new</span> IBookManager.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBooks</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"getBooks: "</span>+ mBooks.toString());</span><br><span class="line">            <span class="keyword">if</span> (mBooks != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> mBooks;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">addBookIn</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookIn: 接收到的对象--&gt;"</span>+book.toString() );</span><br><span class="line">            <span class="keyword">if</span> (book == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"addBookIn: book is null in In"</span>);</span><br><span class="line">                book = <span class="keyword">new</span> Book();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尝试修改book的参数，主要是为了观察其到客户端的反馈</span></span><br><span class="line">            book.setPrice(<span class="number">2333</span>);</span><br><span class="line">            <span class="keyword">if</span> (!mBooks.contains(book))&#123;</span><br><span class="line">                mBooks.add(book);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookIn: now the list is "</span>+mBooks.toString() );</span><br><span class="line">            <span class="keyword">return</span> book;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">addBookOut</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookOut: 接收到的对象--&gt;"</span>+book.toString() );</span><br><span class="line">            <span class="keyword">if</span> (book == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"addBookOut: book is null in Out"</span>);</span><br><span class="line">                book = <span class="keyword">new</span> Book();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尝试修改book的参数，主要是为了观察其到客户端的反馈</span></span><br><span class="line">            book.setPrice(<span class="number">2333</span>);</span><br><span class="line">            <span class="keyword">if</span> (!mBooks.contains(book))&#123;</span><br><span class="line">                mBooks.add(book);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookOut: now the list is "</span>+ mBooks.toString());</span><br><span class="line">            <span class="keyword">return</span> book;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">addBookInOut</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookInOut: 接收到的对象--&gt;"</span>+book.toString() );</span><br><span class="line">            <span class="keyword">if</span> (book == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"addBookInOut: book is null in InOut"</span>);</span><br><span class="line">                book = <span class="keyword">new</span> Book();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尝试修改book的参数，主要是为了观察其到客户端的反馈</span></span><br><span class="line">            book.setPrice(<span class="number">2333</span>);</span><br><span class="line">            <span class="keyword">if</span> (!mBooks.contains(book))&#123;</span><br><span class="line">                mBooks.add(book);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookInOut: now the list is "</span>+ mBooks.toString());</span><br><span class="line">            <span class="keyword">return</span> book;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"onCreate: AIDLService"</span> );</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setName(<span class="string">"Android 开发艺术探索"</span>);</span><br><span class="line">        book.setPrice(<span class="number">20</span>);</span><br><span class="line">        mBooks.add(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"onBind: AIDLService"</span> );</span><br><span class="line">        <span class="keyword">return</span> mBookManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体的代码结构很清晰，大致可以分为三块：第一块是<strong>初始化</strong>。在 onCreate() 方法里面我进行了一些数据的初始化操作。第二块是<strong>重写 IBookManager.Stub 中的方法</strong>。在这里面提供AIDL里面定义的方法接口的具体实现逻辑。第三块是<strong>重写 onBind() 方法</strong>，返回 IBookManager.Stub 对象。</p>
<p>接下来在 Manefest 文件里面注册这个我们写好的 Service ，添加 action 以便客户端可以隐式启动该服务。如果在同一个项目中可通过设置<code>android:process</code> 处于不同进程。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">    android:name=<span class="string">".service.AIDLService"</span></span><br><span class="line">    android:process=<span class="string">":remote"</span></span><br><span class="line">    android:exported=<span class="string">"true"</span>&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=<span class="string">"com.prsuit.aidl.bookmanager"</span>/&gt;</span><br><span class="line">            &lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>

<p><strong>编写客户端代码</strong></p>
<p>如果是在不同项目中，则需要拷贝 AIDL 文件夹和相关 Java 文件，aidl 移植完后，客户端主要工作是连接上服务端，调用服务端的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端的AIDLActivity.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIDLActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = <span class="string">"AIDLActivity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IBookManager mBookManager = <span class="keyword">null</span>;<span class="comment">//服务端binder对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mBound = <span class="keyword">false</span>;<span class="comment">//是否连接上服务端</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; mBooks;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mServiceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            mBookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line">            mBound = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (mBookManager != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  mBooks = mBookManager.getBooks();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_a_i_d_l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用服务端的addBookIn方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBookIn</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mBound)&#123;</span><br><span class="line">            toBindService();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mBookManager == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setName(<span class="string">"App 开发In"</span>);</span><br><span class="line">        book.setPrice(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获得服务端执行方法的返回值，并打印输出</span></span><br><span class="line">            Book returnBook = mBookManager.addBookIn(book);</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookIn: Client book："</span>+book.toString() );</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookIn: server 返回book："</span>+returnBook.toString() );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用服务端的addBookOut方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBookOut</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mBound)&#123;</span><br><span class="line">            toBindService();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mBookManager == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setName(<span class="string">"App 开发Out"</span>);</span><br><span class="line">        book.setPrice(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获得服务端执行方法的返回值，并打印输出</span></span><br><span class="line">            Book returnBook = mBookManager.addBookOut(book);</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookOut: Client book："</span>+book.toString() );</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookOut: server 返回book："</span>+returnBook.toString() );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用服务端的addBookInOut方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBookInOut</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mBound)&#123;</span><br><span class="line">            toBindService();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mBookManager == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Book book = <span class="keyword">new</span> Book();</span><br><span class="line">        book.setName(<span class="string">"App 开发InOut"</span>);</span><br><span class="line">        book.setPrice(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获得服务端执行方法的返回值，并打印输出</span></span><br><span class="line">            Book returnBook = mBookManager.addBookInOut(book);</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookInOut: Client book："</span>+book.toString() );</span><br><span class="line">            Log.e(TAG, <span class="string">"addBookInOut: server 返回book："</span>+returnBook.toString() );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        <span class="keyword">if</span> (!mBound)&#123;</span><br><span class="line">            toBindService();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试与服务端建立连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toBindService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setAction(<span class="string">"com.prsuit.aidl.bookmanager"</span>);</span><br><span class="line">        <span class="comment">//5.0版本后隐式启动服务报错，必须给Intent设置包名</span></span><br><span class="line">        intent.setPackage(<span class="string">"com.prsuit.androidlearnsample"</span>);</span><br><span class="line">        bindService(intent,mServiceConnection,BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        <span class="keyword">if</span> (mBound)&#123;</span><br><span class="line">            unbindService(mServiceConnection);</span><br><span class="line">            mBound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样很清晰，首先建立连接，然后在 ServiceConnection 里面获取 IBookManager 对象，接着通过它来调用服务端的方法。</p>
<h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p>先用一张图整体描述这个AIDL从客户端(Client)发起请求至服务端(Server)相应的工作流程，我们可以看出整体的核心就是Binder。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghxfotybjhj30zs0dy75l.jpg" alt=""></p>
<p>首先看下客户端的 IBookManager 对象是怎么来的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">           mBookManager = IBookManager.Stub.asInterface(service);</span><br></pre></td></tr></table></figure>

<p><strong>asInterface()</strong>：</p>
<blockquote>
<p>用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的【如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象】</p>
</blockquote>
<p>注意到方法的传参：IBinder service ，这是个 BinderProxy 对象，接下来顺藤摸瓜去看下这个 BookManager.Stub.asInterface() 是怎么回事：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.prsuit.androidlearnsample.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">    <span class="comment">//验空</span></span><br><span class="line">     <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="comment">//DESCRIPTOR = "com.prsuit.androidlearnsample.IBookManager"，搜索本地是否有可用的对象</span></span><br><span class="line">   <span class="comment">//如果找到了就说明 Client 和 Server 在同一进程，那么这个 binder 本身就是 Binder 本地对象</span></span><br><span class="line">     android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">     <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.prsuit.androidlearnsample.IBookManager))) &#123;</span><br><span class="line">       <span class="keyword">return</span> ((com.prsuit.androidlearnsample.IBookManager)iin);</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="comment">//如果本地没有的话，说明是 binder 是个远程对象，就新建一个代理对象Proxy返回</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> com.prsuit.androidlearnsample.IBookManager.Stub.Proxy(obj);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出通过<code>DESCRIPTOR</code>标识去查找本地是否有可用对象，如果有则是同一进程，那么就返回Stub对象本身，如果没找到则是不同进程，返回Stub的代理内部类Proxy。</p>
<p><strong>Proxy</strong>：</p>
<p>看看Stub的代理内部类IBookManager.Stub.Proxy 类，客户端最终是通过这个类与服务端进行通信。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">prsuit</span>.<span class="title">androidlearnsample</span>.<span class="title">IBookManager</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">      Proxy(android.os.IBinder remote)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//此处的 remote 正是前面我们提到的 IBinder service</span></span><br><span class="line">        mRemote = remote;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DESCRIPTOR;<span class="comment">//Binder的唯一标识</span></span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">      <span class="meta">@Override</span> </span><br><span class="line">   <span class="keyword">public</span> java.util.List&lt;com.prsuit.androidlearnsample.Book&gt; getBooks() <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//_data用来存储流向服务端的数据流</span></span><br><span class="line">        android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">        <span class="comment">//_reply用来存储服务端流回客户端的数据流</span></span><br><span class="line">        android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">        java.util.List&lt;com.prsuit.androidlearnsample.Book&gt; _result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">          <span class="comment">//调用 transact() 方法将方法id和两个 Parcel 容器传过去</span></span><br><span class="line">          <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getBooks, _data, _reply, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getDefaultImpl().getBooks();</span><br><span class="line">          &#125;</span><br><span class="line">          _reply.readException();</span><br><span class="line">           <span class="comment">//从_reply中取出服务端执行方法的结果</span></span><br><span class="line">          _result = _reply.createTypedArrayList(com.prsuit.androidlearnsample.Book.CREATOR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          _reply.recycle();</span><br><span class="line">          _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将结果返回</span></span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span> </span><br><span class="line">   <span class="keyword">public</span> com.prsuit.androidlearnsample.<span class="function">Book <span class="title">addBookIn</span><span class="params">(com.prsuit.androidlearnsample.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">       <span class="comment">//省略</span></span><br><span class="line">      &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>transact()</strong> ：</p>
<blockquote>
<p><code>transact</code>方法运行在客户端，首先它创建该方法所需要的输入型Parcel对象_data、输出型Parcel对象_reply;<br>接着调用绑定服务传来的IBinder对象的transact方法来发起远程过程调用（RPC）请求，同时当前线程挂起;<br>然后服务端的<code>onTransact</code>方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，也就是返回_reply中的数据。</p>
</blockquote>
<p>这是客户端和服务端通信的核心方法。调用这个方法之后，客户端将会挂起当前线程，等候服务端执行完相关任务后通知并接收返回的 _reply 数据流。关于这个方法的传参，这里需要说明的地方：</p>
<ul>
<li><p>方法 ID ：transact() 方法的第一个参数是一个方法 ID ，这个是客户端与服务端约定好的给方法的编码，彼此一一对应。在AIDL文件转化为 .java 文件的时候，系统将会自动给AIDL文件里面的每一个方法自动分配一个方法 ID。</p>
</li>
<li><p>关于 _data 与 _reply 对象：一般来说，我们会将方法的传参的数据存入_data 中，而将方法的返回值的数据存入 _reply 中——在没涉及定向 tag 的情况下。</p>
</li>
<li><p>第四个参数：transact() 方法的第四个参数是一个 int 值，它的作用是设置进行 IPC 的模式，为 0 表示数据可以双向流通，即 _reply 流可以正常的携带数据回来，如果为 1 的话那么数据将只能单向流通，从服务端回来的 _reply 流将不携带任何数据。 </p>
</li>
<li><p>关于 Parcel ：简单的来说，Parcel 是一个用来存放和读取数据的容器。我们可以用它来进行客户端和服务端之间的数据传输，当然，它能传输的只能是可序列化的数据。</p>
<p>注：AIDL生成的 .java 文件的这个参数均为 0。</p>
</li>
</ul>
<p>客户端的一般工作流程：</p>
<ol>
<li>生成 _data 和 _reply 数据流，并向 _data 中存入客户端的数据。</li>
<li>通过 transact() 方法将它们传递给服务端，并请求服务端调用指定方法。</li>
<li>接收 _reply 数据流，并从中取出服务端传回来的数据。</li>
</ol>
<p><strong>Stub</strong>：</p>
<p>接下来看服务端Stub类，在服务端有一个方法<code>onTransact()</code>来接收客户端传过来的参数并进行处理。这个<code>onTransact</code>方法就是服务端处理的核心，接收到客户端的请求，并且通过客户端携带的参数，执行完服务端的方法，返回结果。IBookManager.Stub类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">prsuit</span>.<span class="title">androidlearnsample</span>.<span class="title">IBookManager</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.prsuit.androidlearnsample.IBookManager"</span>;</span><br><span class="line">    <span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">    &#125; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line">      <span class="keyword">switch</span> (code)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">          reply.writeString(descriptor);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_getBooks:</span><br><span class="line">        &#123;</span><br><span class="line">          data.enforceInterface(descriptor);</span><br><span class="line">          <span class="comment">//调用 this.getBooks() 方法，在这里开始执行具体的事务逻辑</span></span><br><span class="line">          <span class="comment">//result 列表为调用 getBooks() 方法的返回值</span></span><br><span class="line">          java.util.List&lt;com.prsuit.androidlearnsample.Book&gt; _result = <span class="keyword">this</span>.getBooks();</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          <span class="comment">//将方法执行的结果写入 reply </span></span><br><span class="line">          reply.writeTypedList(_result);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_addBookIn:</span><br><span class="line">        &#123;</span><br><span class="line">          data.enforceInterface(descriptor);</span><br><span class="line">          com.prsuit.androidlearnsample.Book _arg0;</span><br><span class="line">          <span class="keyword">if</span> ((<span class="number">0</span>!=data.readInt())) &#123;</span><br><span class="line">            _arg0 = com.prsuit.androidlearnsample.Book.CREATOR.createFromParcel(data);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            _arg0 = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          com.prsuit.androidlearnsample.Book _result = <span class="keyword">this</span>.addBookIn(_arg0);</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          <span class="keyword">if</span> ((_result!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">            reply.writeInt(<span class="number">1</span>);</span><br><span class="line">            _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            reply.writeInt(<span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>onTransact()</strong>：</p>
<blockquote>
<p><code>onTransact</code>方法运行在服务端中的Binder线程池中<br>客户端发起跨进程请求时，远程请求会通过系统底层封装后交给此方法来处理。<br>如果此方法返回false,那么客户端的请求就会失败。</p>
</blockquote>
<p>在 onTransact 方法中直接调用服务端的具体方法实现，如果目标方法有参数的话，就从data取出目标方法所需的参数，当目标方法执行完毕后，如果目标方法有返回值，就向reply中写入返回值。</p>
<p>服务端的一般工作流程：</p>
<ol>
<li>获取客户端传过来的数据，根据方法 ID 执行相应操作。</li>
<li>将传过来的数据取出来，调用本地写好的对应方法。</li>
<li>将需要回传的数据写入 reply 流，传回客户端。</li>
</ol>
<p><strong>Stub与Proxy区别</strong></p>
<p>Proxy与Stub不一样，虽然他们都既是Binder又是IInterface，不同的是Stub采用的是继承（is 关系），Proxy采用的是组合（has 关系）。他们均实现了所有的IInterface函数，不同的是，Stub又使用策略模式调用的是虚函数（待子类实现），而Proxy则使用组合模式。为什么Stub采用继承而Proxy采用组合？事实上，Stub本身is一个IBinder（Binder），它本身就是一个能跨越进程边界传输的对象，所以它得继承IBinder实现transact这个函数从而得到跨越进程的能力（这个能力由驱动赋予）。Proxy类使用组合，是因为他不关心自己是什么，它也不需要跨越进程传输，它只需要拥有这个能力即可，要拥有这个能力，只需要保留一个对IBinder的引用。在Stub类里面，asBinder返回this，在Proxy里面返回的是持有的组合类IBinder的引用。</p>
<p>一个需要跨进程传递的对象一定继承自 IBinder，如果是 Binder 本地对象，那么一定继承 Binder 实现IInterface，如果是代理对象，那么就实现了 IInterface 并持有了 IBinder 引用。</p>
<p><strong>Binder传输数据的大小限制</strong></p>
<p>普通的由Zygote孵化而来的用户进程，所映射的<strong>Binder内存大小是不到1M的</strong>，准确说是 1x1024x1024) - (4096 x2)，这个限制定义在ProcessState类中，如果传输说句超过这个大小，系统就会报错，而在内核中，其实也有个限制，是4M，不过由于APP中已经限制了不到1M。</p>
<p>有个特殊的进程ServiceManager进程，它为自己申请的Binder内核空间是128K，这个同ServiceManager的用途是分不开的，ServcieManager主要面向系统Service，只是简单的提供一些addServcie，getService的功能，不涉及多大的数据传输，因此不需要申请多大的内存。</p>
<p><strong>ServiceManager addService的限制</strong></p>
<p>ServiceManager 其实主要的面向对象是<strong>系统服务</strong>，比如AMS、WMS、PKMS服务等，并非所有服务都能通过addService 添加到 ServiceManager，在通过ServiceManager添加服务的时候，是有些权限校验的，大部分系统服务都是由 SystemServer 进程中添加到ServiceManager中去的。而APP通过的 bindService 启动的 Binder 服务其实是*<em>由 SystemServer 的 ActivityManagerService *</em>负责管理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Binder通信的实质是利用内存映射，将用户进程的内存地址和内核的内存地址映射为同一块物理地址，也就是说他们使用的同一块物理空间。 </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghyk9gwafcj30qo0t5qc1.jpg" alt=""></p>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://juejin.im/post/6844903589635162126" target="_blank" rel="noopener">写给 Android 应用工程师的 Binder 原理剖析</a></p>
<p><a href="https://www.jianshu.com/p/4ee3fd07da14" target="_blank" rel="noopener">图文详解 Android Binder跨进程通信的原理</a></p>
<p><a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列—开篇</a></p>
<p><a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android Bander设计与实现 - 设计篇</a></p>
<p><a href="https://www.jianshu.com/p/485233919c15" target="_blank" rel="noopener">Android跨进程通信IPC之13——Binder总结</a></p>
<p><a href="https://blog.csdn.net/qian520ao/article/details/78072250" target="_blank" rel="noopener">Android 深入浅出AIDL（一）</a></p>
<p><a href="https://blog.csdn.net/qian520ao/article/details/78074983" target="_blank" rel="noopener">Android 深入浅出AIDL（二）</a></p>
<p><a href="https://blog.csdn.net/luoyanglizi/article/details/51958091" target="_blank" rel="noopener">你真的理解AIDL中的in，out，inout么？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity启动过程</title>
    <url>/2020/08/14/Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统启动过程分析</title>
    <url>/2020/08/16/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android系统启动流程。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h4><p>Android系统架构分为五层，从下往上依次分为Linux内核、HAL硬件抽象层、系统Native库和Android运行时环境、Java Framework框架层、应用层。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi54x0tvekj30u018640z.jpg" alt=""></p>
<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p>Android系统的启动，主要是指Android手机长按电源键后，Android手机开机的过程。</p>
<blockquote>
<p>1、Bootloader引导</p>
<p>2、装载与启动Linux内核</p>
<p>3、启动Android系统</p>
<ul>
<li>3.1、启动Init进程—— 1 号进程(init进程是所有用户进程的鼻祖)</li>
<li>3.2、启动ServiceManager—— Binder 服务的总管</li>
<li>3.3、启动Zygote——Android系统的第一个Java进程(即虚拟机进程)</li>
<li>3.4、启动SystemServer——承载 framework 层核心业务</li>
<li>3.5、启动Launcher——Android 系统的“桌面”</li>
</ul>
</blockquote>
<p><strong>系统启动架构图</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi386fq0hoj30y80u079p.jpg" alt=""></p>
<p><strong>图解：</strong> Android系统启动过程由上图从下往上的一个过程是由BootLoader引导开机，然后依次进入 -&gt; <code>Kernel</code> -&gt; <code>Native</code> -&gt; <code>Framework</code> -&gt; <code>App</code>。</p>
<p>Android系统启动过程可分为四步：启动电源-&gt;执行引导程序BootLoader-&gt;启动内核-&gt;启动init进程。下面分别介绍每个过程：</p>
<h4 id="启动电源"><a href="#启动电源" class="headerlink" title="启动电源"></a>启动电源</h4><p>当电源按下，引导芯片从 ROM（一般指 Flash ROM，即闪存）中预定义的位置开始执行，加载引导程序 BootLoader 到 RAM。</p>
<h4 id="执行引导程序BootLoader"><a href="#执行引导程序BootLoader" class="headerlink" title="执行引导程序BootLoader"></a>执行引导程序BootLoader</h4><p>Boot Loader是在系统内核运行之前运行的引导程序，也是系统运行的第一个程序。</p>
<p>主要作用是：初始化 RAM、初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。</p>
<h4 id="启动内核Kernel"><a href="#启动内核Kernel" class="headerlink" title="启动内核Kernel"></a>启动内核Kernel</h4><p> Linux系统启动主要分为三个阶段：第一个阶段是自解压过程，第二个是设置ARM处理器的工作模式、设置一级页表等，第三个阶段主要是C代码，包括Android的初始化的全部工作。</p>
<p>内核解压缩完成后，通过执行文件<code>head.S</code>、<code>head-common.S</code> 的汇编代码，查找处理器类型和机器码类型来调用相应的初始化函数，然后进入内核入口函数 <code>start_kernel()</code> 开始之后的内核初始化工作，主要是与硬件平台的相关初始化工作。在完成一系列的与内核相关的初始后，调用 <code>rest_init()</code> 函数来进行最后的初始化并创建第一个用户进程 init 进程，由此进入用户态进程。Linux内核启动的最后一个阶段就是挂载根文件系统，因为启动第一个init进程，必须以根文件系统为载体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kernel的入口函数</span></span><br><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __init <span class="title">start_kernel</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  rest_init();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启init进程</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> noinline <span class="keyword">void</span> __init_refok <span class="title">rest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//kernel_init函数在kernel线程中运行</span></span><br><span class="line">  kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内核初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __ref <span class="title">kernel_init</span><span class="params">(<span class="keyword">void</span> *unused)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//从下面的路径中找到init进程的可执行文件，</span></span><br><span class="line">  <span class="comment">//并开启用户态的init进程，由内核态进程跳转到用户态进程</span></span><br><span class="line">  <span class="keyword">if</span> (!try_to_run_init_process(<span class="string">"/sbin/init"</span>) || </span><br><span class="line">      !try_to_run_init_process(<span class="string">"/etc/init"</span>) ||</span><br><span class="line">      !try_to_run_init_process(<span class="string">"/bin/init"</span>) ||</span><br><span class="line">      !try_to_run_init_process(<span class="string">"/bin/sh"</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">"No working init found.  Try passing init= option to kernel. "</span></span><br><span class="line">      <span class="string">"See Linux Documentation/init.txt for guidance."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核启动时，会设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动第一个用户空间进程init进程。</p>
<ul>
<li>启动 Kernel 的 swapper 进程(pid=0)：该进程又称为 idle 进程，系统初始化过程 Kernel 由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作；</li>
<li>启动 kthreadd 进程（pid=2）：是 Linux 系统的内核进程，会创建内核工作线程 kworkder，软中断线程ksoftirqd，thermal 等内核守护进程。kthreadd 进程是所有内核进程的鼻祖。</li>
</ul>
<h4 id="启动init进程"><a href="#启动init进程" class="headerlink" title="启动init进程"></a>启动init进程</h4><p>Kernel 启动过程会创建 init 进程(pid=1)，是用户空间的第一个进程，是所有用户空间进程的鼻祖。init 进程会启动servicemanager(binder服务管家)，Zygote 进程(Android中Java进程的鼻祖)。Zygote 进程会创建  system_server 进程以及各种app进程，下图是这几个系统重量级进程之间的层级关系：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi4jgw3dqqj30u00i2aau.jpg" alt=""></p>
<p>Kernel 启动后会调用init进程的main()方法，init的源码位于<code>system/core/init</code>包下，init 进程入口函数在<code>system/core/init/main.cpp</code>。(注：基于Android 10.0的源码)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android::init;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(address_sanitizer)</span></span><br><span class="line">    __asan_set_error_report_callback(AsanReportCallback);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"ueventd"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"subcontext"</span>)) &#123;</span><br><span class="line">            android::base::InitLogging(argv, &amp;android::base::KernelLogger);</span><br><span class="line">            <span class="keyword">const</span> BuiltinFunctionMap function_map;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> SubcontextMain(argc, argv, &amp;function_map);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"selinux_setup"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SetupSelinux(argv);<span class="comment">//对SELinux进行初始化</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"second_stage"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SecondStageMain(argc, argv);<span class="comment">//第二阶段</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FirstStageMain(argc, argv); <span class="comment">//第一阶段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FirstStageMain方法主要工作：</p>
<ol>
<li>处理init进程挂掉的情况</li>
<li>设置用户组，挂载相关系统文件</li>
<li>根据<code>/force_debuggable</code>文件来判断是否允许adb root指令</li>
<li>执行init进程main方法，通过<code>execv(path,{path,“selinux_setup”,nullptr})</code>进入SetupSelinux</li>
</ol>
<p>SetupSelinux方法主要工作：</p>
<ol>
<li>初始化SELinux，然后以在init SELinux上下文中运行。</li>
<li>执行init进程main方法，通过<code>execv(path,{path,“second_stage”,nullptr})</code> 进入SecondStageMain</li>
</ol>
<p>SecondStageMain方法主要工作：</p>
<ol>
<li>使用epoll对init子进程的信号进行监听</li>
<li>初始化系统属性，使用mmap共享内存，”/dev/<strong>properties</strong>/property_info” （重要）</li>
<li>开启属性服务，并注册到epoll中（重要）</li>
<li>加载系统启动脚本”/init.rc”</li>
<li>解析启动脚本，启动相关服务</li>
</ol>
<p>init的主要工作：</p>
<blockquote>
<ul>
<li>first stage 初始化环境变量和各种文件系统目录，klog初始化等</li>
<li>selinux相关初始化完成，然后切换second stage 重启init进程</li>
<li>属性服务初始化，将各种系统属性默认值填充到属性Map中</li>
<li>创建epoll描述符结合注册socket监听，处理显示启动进程和挂掉的子进程重启</li>
<li>解析init.rc。把各种action、service等解析出来的填充到相应链表容器管理</li>
<li>有序将early-init、init等各种cmd加入到执行队列action_queue链表中</li>
<li>进入while()循环依次取出执行队列action_queue中的command执行，fork包括app_process在内的各种进程，epoll阻塞监听处理来自挂掉的子进程的消息，根据设定策略restart子进程。</li>
</ul>
</blockquote>
<p>注：rc文件内部由Android初始化语言编写（Android Init Language）编写的脚本，它主要包含五种类型语句：Action、Commands、Services、Options和Import。</p>
<h4 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h4><p>servicemanager 进程是由 init 进程通过解析 init.rc 文件(位于<code>system/core/rootdir/</code>)来启动的。从Android 5.0开始中对 init.rc 文件进行了拆分，每个服务一个rc文件。ServiceManager的启动脚本文件<code>frameworks/native/cmds/servicemanager/servicemanager.rc</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">core</span> <span class="title">animation</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span> //1</span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">system</span> <span class="title">readproc</span></span></span><br><span class="line"><span class="class">    <span class="title">critical</span> //2</span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">healthd</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">zygote</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">audioserver</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">media</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">surfaceflinger</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">inputflinger</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">drm</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">cameraserver</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">keystore</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">gatekeeperd</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">thermalservice</span></span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">system</span>-<span class="title">background</span>/<span class="title">tasks</span></span></span><br><span class="line"><span class="class">    <span class="title">shutdown</span> <span class="title">critical</span></span></span><br></pre></td></tr></table></figure>

<p>service用于通知init进程创建名为servicemanager的进程，这个servicemanager进程执行程序的路径为/system/bin/servicemanager。</p>
<p>注释1的关键字user说明servicemanager是以用户system的身份运行的，注释2处的critical说明servicemanager是系统中的关键服务，关键服务是不会退出的，如果退出了，系统就会重启，当系统重启时就会启动用onrestart关键字修饰的进程，比如zygote、media、surfaceflinger等。</p>
<p>servicemanager 入口函数在 <code>framework/native/cmds/servicemanager/service_manager.c</code>，简化后的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="comment">// 打开binder驱动，申请 128k 字节大小的内存空间</span></span><br><span class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成为上下文管理者</span></span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证 selinux 权限，判断进程是否有权注册或查看指定服务</span></span><br><span class="line">    selinux_enabled = is_selinux_enabled();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 进入无限循环，处理 client 端发来的请求 </span></span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重点关注两点，首先，在申请了一块大小为 128k 的内存空间并验证 selinux 权限后，接着调用 <code>framework/native/cmds/servicemanager/binder.c</code> 中的 binder_become_context_manager 方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_become_context_manager</span><span class="params">(struct binder_state *bs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过ioctl，发送 BINDER_SET_CONTEXT_MGR 指令</span></span><br><span class="line">    <span class="keyword">return</span> ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，调用 binder_loop 方法进入循环来处理 client 发来的请求，注意第二个参数是一个方法体，用于处理各种状态回调：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svcmgr_handler</span><span class="params">(...)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(txn-&gt;code) &#123;</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_GET_SERVICE:</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_CHECK_SERVICE: </span><br><span class="line">        <span class="comment">// 获取服务名</span></span><br><span class="line">        s = bio_get_string16(msg, &amp;len); </span><br><span class="line">        <span class="comment">// 根据名称查找相应服务</span></span><br><span class="line">        handle = do_find_service(bs, s, len, txn-&gt;sender_euid, txn-&gt;sender_pid);</span><br><span class="line">        bio_put_ref(reply, handle);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_ADD_SERVICE: </span><br><span class="line">        <span class="comment">// 获取服务名</span></span><br><span class="line">        s = bio_get_string16(msg, &amp;len);</span><br><span class="line">        handle = bio_get_ref(msg);</span><br><span class="line">        allow_isolated = bio_get_uint32(msg) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">         <span class="comment">// 注册指定服务</span></span><br><span class="line">        <span class="keyword">if</span> (do_add_service(bs, s, len, handle, txn-&gt;sender_euid,</span><br><span class="line">            allow_isolated, txn-&gt;sender_pid))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>servicemanager 进程在启动过程的工作内容如下：</p>
<ol>
<li>调用 binder_open 方法打开 Binder 驱动，并申请分配一块 128k 的内存空间</li>
<li>调用 binder_become_context_manager 方法发送 BINDER_SET_CONTEXT_MGR 给 Binder 驱动，使自己成为上下文管理者</li>
<li>验证 selinux 权限，判断进程是否有注册或查看指定服务的权限</li>
<li>调用 binder_loop 方法进入循环状态，等待 Client 请求</li>
<li>根据服务名称注册服务·</li>
<li>接收 Binder 死亡通知</li>
</ol>
<h4 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h4><p>由 init 进程通过解析 init.rc 文件来启动的，init.rc 并不是直接引入某个固定的文件，而是根据属性ro.zygote的内容来引入不同的文件。这是因为从Android 5.0开始，Android系统开始支持64位的编译，Zygote进程本身也会有32位和64位版本的区别。所以在init.rc的同级目录<code>system/core/rootdir/</code>下一共有4个和zygote相关的rc文件：</p>
<blockquote>
<ul>
<li>init.zygote32</li>
<li>init.zygote64</li>
<li>init.zygote32_64</li>
<li>init.zygote64_32</li>
</ul>
</blockquote>
<p>init.zygote32.rc：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">priority</span> -20</span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">root</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">root</span> <span class="title">readproc</span> <span class="title">reserved_disk</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">zygote</span> <span class="title">stream</span> 660 <span class="title">root</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">socket</span> <span class="title">usap_pool_primary</span> <span class="title">stream</span> 660 <span class="title">root</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">write</span> /<span class="title">sys</span>/<span class="title">android_power</span>/<span class="title">request_state</span> <span class="title">wake</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">write</span> /<span class="title">sys</span>/<span class="title">power</span>/<span class="title">state</span> <span class="title">on</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">audioserver</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">cameraserver</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">media</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">netd</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">wificond</span></span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">foreground</span>/<span class="title">tasks</span></span></span><br></pre></td></tr></table></figure>

<p>init.zygote32_64.rc：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">service zygote /system/bin/app_process32 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br><span class="line">    class main</span><br><span class="line">    priority <span class="number">-20</span></span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote stream <span class="number">660</span> root system</span><br><span class="line">    socket usap_pool_primary stream <span class="number">660</span> root system</span><br><span class="line">    onrestart <span class="built_in">write</span> /sys/android_power/request_state wake</span><br><span class="line">    onrestart <span class="built_in">write</span> /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br><span class="line"></span><br><span class="line">service zygote_secondary /system/bin/app_process64 -Xzygote /system/bin --zygote --socket-name=zygote_secondary</span><br><span class="line">    class main</span><br><span class="line">    priority <span class="number">-20</span></span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote_secondary stream <span class="number">660</span> root system</span><br><span class="line">    socket usap_pool_secondary stream <span class="number">660</span> root system</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure>

<p>从init.zygote32_64.rc 文件可以看到，这种情况下系统定义了两个zygote 服务：<strong>zygote</strong>和<strong>zygote_secodary</strong>。这两个服务最大的区别是启动的可执行文件不同，一个是app_process32，一个是app_process64。所以从这里我们可以知道，Andorid系统支持4种运行模式：</p>
<blockquote>
<p>纯32位模式：属性ro.zygote的值为zygote32</p>
<p>混32位模式(即32位为主，64位为辅)模式：属性ro.zygote的值为zygote32_64</p>
<p>纯64位模式：属性ro.zygote的值为zygote64</p>
<p>混64位模式(即 64位为主，32位为辅)模式：属性ro.zygote值为zygote64_32</p>
</blockquote>
<h5 id="app-main-cpp-main"><a href="#app-main-cpp-main" class="headerlink" title="app_main.cpp::main"></a>app_main.cpp::main</h5><p>zygote 入口函数在<code>frameworks/base/cmds/app_process/app_main.cpp</code>，它的 main 方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	...</span><br><span class="line">    <span class="comment">//创建了AppRuntime对象，AppRuntime类继承自AndroidRuntime</span></span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line">    <span class="comment">// Process command line arguments</span></span><br><span class="line">    <span class="comment">// ignore argv[0]</span></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line">    <span class="comment">//从命令行参数中找到虚拟机相关的参数，添加到runtime对象</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* spaced_commands[] = &#123; <span class="string">"-cp"</span>, <span class="string">"-classpath"</span> &#125;;</span><br><span class="line">    <span class="comment">// Allow "spaced commands" to be succeeded by exactly 1 argument (regardless of -s).</span></span><br><span class="line">    <span class="keyword">bool</span> known_command = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (known_command == <span class="literal">true</span>) &#123;</span><br><span class="line">          runtime.addOption(strdup(argv[i]));</span><br><span class="line">          <span class="comment">// The static analyzer gets upset that we don't ever free the above</span></span><br><span class="line">          <span class="comment">// string. Since the allocation is from main, leaking it doesn't seem</span></span><br><span class="line">          <span class="comment">// problematic. NOLINTNEXTLINE</span></span><br><span class="line">          ALOGV(<span class="string">"app_process main add known option '%s'"</span>, argv[i]);</span><br><span class="line">          known_command = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">             j &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">sizeof</span>(spaced_commands) / <span class="keyword">sizeof</span>(spaced_commands[<span class="number">0</span>]));</span><br><span class="line">             ++j) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[i], spaced_commands[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">            known_command = <span class="literal">true</span>;</span><br><span class="line">            ALOGV(<span class="string">"app_process main found known command '%s'"</span>, argv[i]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; argv[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++i; <span class="comment">// Skip --.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        runtime.addOption(strdup(argv[i]));</span><br><span class="line">        <span class="comment">// The static analyzer gets upset that we don't ever free the above</span></span><br><span class="line">        <span class="comment">// string. Since the allocation is from main, leaking it doesn't seem</span></span><br><span class="line">        <span class="comment">// problematic. NOLINTNEXTLINE</span></span><br><span class="line">        ALOGV(<span class="string">"app_process main add option '%s'"</span>, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Parse runtime arguments.  Stop at first unrecognized option.</span></span><br><span class="line">    <span class="comment">// 解析runtime参数</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    ++i;  <span class="comment">// Skip unused "parent dir" argument.</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//准备启动ZygoteInit类或者RuntimeInit类，根据类名是否存在为空，来区别是非zyoget模式和zyoget模式.</span></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We're not in zygote mode, the only argument we need to pass</span></span><br><span class="line">        <span class="comment">// to RuntimeInit is the application argument.</span></span><br><span class="line">        <span class="comment">// The Remainder of args get passed to startup class main(). Make</span></span><br><span class="line">        <span class="comment">// copies of them before we overwrite them with the process name.</span></span><br><span class="line">        args.add(application ? String8(<span class="string">"application"</span>) : String8(<span class="string">"tool"</span>));</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!LOG_NDEBUG) &#123;</span><br><span class="line">          String8 restOfArgs;</span><br><span class="line">          <span class="keyword">char</span>* <span class="keyword">const</span>* argv_new = argv + i;</span><br><span class="line">          <span class="keyword">int</span> argc_new = argc - i;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; argc_new; ++k) &#123;</span><br><span class="line">            restOfArgs.append(<span class="string">"\""</span>);</span><br><span class="line">            restOfArgs.append(argv_new[k]);</span><br><span class="line">            restOfArgs.append(<span class="string">"\" "</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          ALOGV(<span class="string">"Class name = %s, args = %s"</span>, className.<span class="built_in">string</span>(), restOfArgs.<span class="built_in">string</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We're in zygote mode.</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">"start-system-server"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"app_process: Unable to determine ABI list from property %s."</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">"--abi-list="</span>)</span></span>;</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In zygote mode, pass all remaining arguments to the zygote</span></span><br><span class="line">        <span class="comment">// main() method.</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果niceName不为空，则将本进程的名称修改为参数** --nice-name** 指定的字符串。缺省的情况下，niceName 的值为"zygote"或者"zygote64"</span></span><br><span class="line">  	<span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">    	runtime.setArgv0(niceName.<span class="built_in">string</span>(), <span class="literal">true</span> <span class="comment">/* setProcName */</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 调用 AppRuntime 父类 AndroidRuntime 的 start 方法创建 zygote 进程</span></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        <span class="comment">//zygote 模式，即启动ZygoteInit.java </span></span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">       <span class="comment">//非zygote 模式，即启动RuntimeInit.java</span></span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AppRuntime继承自AndroidRuntime类，并且重载了onVmCreated 、onStarted、onZygoteInit和onExit函数。我们发现并没有重载start函数，而在app_main.cpp的main()函数的最后runtime.start函数，所以具体执行在AndroidRuntime类的start函数。</p>
<blockquote>
<p>AndroidRuntime类是安卓底层系统超级重要的一个类，它负责启动虚拟机以及Java线程。AndroidRuntime类是在一个进程中只有一个实例对象，并将其保存在全局变量gCurRuntime中。</p>
</blockquote>
<h5 id="AndroidRuntime-cpp-start"><a href="#AndroidRuntime-cpp-start" class="headerlink" title="AndroidRuntime.cpp::start"></a>AndroidRuntime.cpp::start</h5><p>AndroidRuntime 类<code>frameworks/base/core/jni/AndroidRuntime.cpp</code> 的 start 方法：</p>
<p>该方法注释说明：</p>
<blockquote>
<p>启动Android运行时，包括启动虚拟机并调用以”className”命名的类的静态main()方法。<br>这个mian方法的两个入参一个是类名，一个是特定选项的字符串</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Start the Android runtime.  This involves starting the virtual machine</span></span><br><span class="line"><span class="comment"> * and calling the "static void main(String[] args)" method in the class</span></span><br><span class="line"><span class="comment"> * named by "className".</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Passes the main function two arguments, the class name and the specified</span></span><br><span class="line"><span class="comment"> * options string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	...</span><br><span class="line">      </span><br><span class="line">   <span class="comment">//获取系统目录</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* rootDir = getenv(<span class="string">"ANDROID_ROOT"</span>);</span><br><span class="line">    <span class="keyword">if</span> (rootDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rootDir = <span class="string">"/system"</span>;</span><br><span class="line">        <span class="keyword">if</span> (!hasDir(<span class="string">"/system"</span>)) &#123;</span><br><span class="line">            LOG_FATAL(<span class="string">"No root directory specified, and /system does not exist."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        setenv(<span class="string">"ANDROID_ROOT"</span>, rootDir, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* runtimeRootDir = getenv(<span class="string">"ANDROID_RUNTIME_ROOT"</span>);</span><br><span class="line">    <span class="keyword">if</span> (runtimeRootDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOG_FATAL(<span class="string">"No runtime directory specified with ANDROID_RUNTIME_ROOT environment variable."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* tzdataRootDir = getenv(<span class="string">"ANDROID_TZDATA_ROOT"</span>);</span><br><span class="line">    <span class="keyword">if</span> (tzdataRootDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOG_FATAL(<span class="string">"No tz data directory specified with ANDROID_TZDATA_ROOT environment variable."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//const char* kernelHack = getenv("LD_ASSUME_KERNEL");</span></span><br><span class="line">    <span class="comment">//ALOGD("Found LD_ASSUME_KERNEL='%s'\n", kernelHack);</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    <span class="comment">//完成jni接口的初始化</span></span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="comment">//启动虚拟机</span></span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//调用继承类的AppRuntime中的重载函数</span></span><br><span class="line">   <span class="comment">//如果是Zygote的启动，则onVmCreated实际上什么也不做，如果是非Zygote模式，则根据类名获取类，并释放了类名</span></span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register android functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="comment">//注册系统的JNI函数</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We want to call main() with a String array with arguments in it.</span></span><br><span class="line"><span class="comment">     * At present we have two arguments, the class name and an option string.</span></span><br><span class="line"><span class="comment">     * Create an array to hold them.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="comment">//为启动Java类的main函数做准备</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">    assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.<span class="built_in">size</span>() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//调用Zygoteinit类或RuntimeInit类的main()函数</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">""</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到 ZygoteInit/RuntimeInit 的 main 函数</span></span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 通过 JNI 调用 ZygoteInit/RuntimeInit 的 main 函数</span></span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">            <span class="keyword">if</span> (env-&gt;ExceptionCheck())</span><br><span class="line">                threadExitUncaughtException(env);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(slashClassName);</span><br><span class="line"></span><br><span class="line">    ALOGD(<span class="string">"Shutting down VM\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</span><br><span class="line">        ALOGW(<span class="string">"Warning: unable to detach main thread\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</span><br><span class="line">        ALOGW(<span class="string">"Warning: VM did not shut down cleanly\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AndroidRuntime 类的 start 方法：</p>
<ol>
<li><code>startVm()</code>，创建虚拟机</li>
<li><code>startReg()</code>，注册JNI方法</li>
<li><code>env-&gt;CallStaticVoidMethod()</code>，调用 Java 层指定的 class 的 main 方法，启动 Zyogte 调用 ZygoteInit 类的 main 方法。</li>
</ol>
<h5 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main"></a>ZygoteInit.main</h5><p>通过 JNI 的方式进入<code>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</code> 的main方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">        ZygoteServer zygoteServer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mark zygote start. This ensures that thread creation will throw</span></span><br><span class="line">        <span class="comment">// an error.</span></span><br><span class="line">        <span class="comment">//这里其实只是设置一个标志位，为创建Java线程时做判断处理，如果是zygote进程，则不需要开启线程</span></span><br><span class="line">        ZygoteHooks.startZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Zygote goes into its own process group.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//设置进程组ID</span></span><br><span class="line">            Os.setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to setpgid(0,0)"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Runnable caller;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Report Zygote start time to tron unless it is a runtime restart</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"sys.boot_completed"</span>))) &#123;</span><br><span class="line">                MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">"boot_zygote_init"</span>,</span><br><span class="line">                        (<span class="keyword">int</span>) SystemClock.elapsedRealtime());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断当前进程是64位程序还是32位程序，并设置标记</span></span><br><span class="line">            String bootTimeTag = Process.is64Bit() ? <span class="string">"Zygote64Timing"</span> : <span class="string">"Zygote32Timing"</span>;</span><br><span class="line">            TimingsTraceLog bootTimingsTraceLog = <span class="keyword">new</span> TimingsTraceLog(bootTimeTag,</span><br><span class="line">                    Trace.TRACE_TAG_DALVIK);</span><br><span class="line">            bootTimingsTraceLog.traceBegin(<span class="string">"ZygoteInit"</span>);</span><br><span class="line">            RuntimeInit.enableDdms();<span class="comment">// 启用 DDMS</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">            String zygoteSocketName = <span class="string">"zygote"</span>;</span><br><span class="line">            String abiList = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> enableLazyPreload = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">                    startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"--enable-lazy-preload"</span>.equals(argv[i])) &#123;</span><br><span class="line">                    enableLazyPreload = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                    abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                    zygoteSocketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> isPrimaryZygote = zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (abiList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No ABI list supplied."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// In some configurations, we avoid preloading resources and classes eagerly.</span></span><br><span class="line">            <span class="comment">// In such cases, we will preload things prior to our first fork.</span></span><br><span class="line">            <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">                bootTimingsTraceLog.traceBegin(<span class="string">"ZygotePreload"</span>);</span><br><span class="line">                EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</span><br><span class="line">                        SystemClock.uptimeMillis());</span><br><span class="line">                preload(bootTimingsTraceLog);</span><br><span class="line">                EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</span><br><span class="line">                        SystemClock.uptimeMillis());</span><br><span class="line">                bootTimingsTraceLog.traceEnd(); <span class="comment">// ZygotePreload</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Zygote.resetNicePriority();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Do an initial gc to clean up after startup</span></span><br><span class="line">            bootTimingsTraceLog.traceBegin(<span class="string">"PostZygoteInitGC"</span>);</span><br><span class="line">            gcAndFinalize();<span class="comment">//调用ZygoteHooks.gcAndFinalize()进行垃圾回收</span></span><br><span class="line">            bootTimingsTraceLog.traceEnd(); <span class="comment">// PostZygoteInitGC</span></span><br><span class="line"></span><br><span class="line">            bootTimingsTraceLog.traceEnd(); <span class="comment">// ZygoteInit</span></span><br><span class="line">            <span class="comment">// Disable tracing so that forked processes do not inherit stale tracing tags from</span></span><br><span class="line">            <span class="comment">// Zygote.</span></span><br><span class="line">            Trace.setTracingEnabled(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Zygote.initNativeState(isPrimaryZygote);</span><br><span class="line"></span><br><span class="line">            ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class="line">            <span class="comment">//创建zygoteServer，为其他进程初始化创建时与mZygoteSocket通信做准备</span></span><br><span class="line">            zygoteServer = <span class="keyword">new</span> ZygoteServer(isPrimaryZygote);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">              <span class="comment">//启动SystemServer进程，通过fork的方式开启zygote的子进程systemServer，并返回一个Runnale对象</span></span><br><span class="line">                Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the child (system_server) process.</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The select loop returns early in the child process after a fork and</span></span><br><span class="line">            <span class="comment">// loops forever in the zygote.</span></span><br><span class="line">           <span class="comment">//循环等待处理客户端请求，来获取子进程发送的消息</span></span><br><span class="line">            caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"System zygote died with exception"</span>, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (zygoteServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                zygoteServer.closeServerSocket();<span class="comment">// 关闭并释放 socket 连接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We're in the child process and have exited the select loop. Proceed to execute the</span></span><br><span class="line">        <span class="comment">// command.</span></span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            caller.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ZygoteInit.main()方法：</p>
<ol>
<li>解析调用参数argv，初始化startSystemServer、zygoteSocketName等变量</li>
<li><code>preload()</code>，进行一些系统类、资源、共享库的预加载工作，以提升运行时效率</li>
<li><code>gcAndFinalize()</code>，在 forkSystemServer 之前主动进行一次GC操作</li>
<li><code>new ZygoteServer(isPrimaryZygote)</code> 创建 ZygoteServer对象，用来管理和子进程通信的socket服务端，内部会创建和子进程通信的mZygoteSocket对象</li>
<li><code>forkSystemServer()</code>，创建 SystemServer 系统服务进程</li>
<li><code>runSelectLoop()</code>，循环等待处理客户端发送的socket消息创建子进程</li>
</ol>
<p>至此，总结一下 Zygote 进程的任务是：</p>
<ol>
<li>创建 AppRuntime（继承自 AndroidRuntime）， 并调用它的 <strong>start()</strong> 方法</li>
<li>调用 AndroidRuntime 的 <strong>startVM()</strong> 方法创建 DVM（Dalvik Virtual Machine），并调用 <strong>startReg()</strong> 方法为 DVM 注册 JNI</li>
<li>通过 JNI 调用 <strong>ZygoteInit.main()</strong> 方法，第一次进入 Java 的世界</li>
<li>创建 <strong>ZygoteServer</strong> 对象建立 Socket 通道，使 zygote 进程成为和子进程通信的Socket服务端</li>
<li>调用 <strong>forkSystemServer()</strong> 函数 fork 出 SystemServer 系统服务进程</li>
<li>调用 <strong>runSelectLoop()</strong> 函数循环等待处理客户端发送的创建新的应用程序进程请求</li>
</ol>
<h4 id="SystemServer"><a href="#SystemServer" class="headerlink" title="SystemServer"></a>SystemServer</h4><p>Zygote通过fork后创建system_server进程，在小节[3.5]执行完startSystemServer()方法后，进入到了handleSystemServerProcess()方法</p>
<h5 id="ZygoteInit-forkSystemServer"><a href="#ZygoteInit-forkSystemServer" class="headerlink" title="ZygoteInit.forkSystemServer"></a>ZygoteInit.forkSystemServer</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//准备参数并 fork 系统进程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">forkSystemServer</span><span class="params">(String abiList, String socketName,</span></span></span><br><span class="line"><span class="function"><span class="params">            ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> capabilities = posixCapabilitiesAsBits(</span><br><span class="line">                OsConstants.CAP_IPC_LOCK,</span><br><span class="line">                OsConstants.CAP_KILL,</span><br><span class="line">                OsConstants.CAP_NET_ADMIN,</span><br><span class="line">                OsConstants.CAP_NET_BIND_SERVICE,</span><br><span class="line">                OsConstants.CAP_NET_BROADCAST,</span><br><span class="line">                OsConstants.CAP_NET_RAW,</span><br><span class="line">                OsConstants.CAP_SYS_MODULE,</span><br><span class="line">                OsConstants.CAP_SYS_NICE,</span><br><span class="line">                OsConstants.CAP_SYS_PTRACE,</span><br><span class="line">                OsConstants.CAP_SYS_TIME,</span><br><span class="line">                OsConstants.CAP_SYS_TTY_CONFIG,</span><br><span class="line">                OsConstants.CAP_WAKE_ALARM,</span><br><span class="line">                OsConstants.CAP_BLOCK_SUSPEND</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">/* Containers run without some capabilities, so drop any caps that are not available. */</span></span><br><span class="line">        StructCapUserHeader header = <span class="keyword">new</span> StructCapUserHeader(</span><br><span class="line">                OsConstants._LINUX_CAPABILITY_VERSION_3, <span class="number">0</span>);</span><br><span class="line">        StructCapUserData[] data;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = Os.capget(header);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to capget()"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        capabilities &amp;= ((<span class="keyword">long</span>) data[<span class="number">0</span>].effective) | (((<span class="keyword">long</span>) data[<span class="number">1</span>].effective) &lt;&lt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Hardcoded command line to start the system server */</span></span><br><span class="line">        <span class="comment">// 启动参数</span></span><br><span class="line">        String args[] = &#123;</span><br><span class="line">                <span class="string">"--setuid=1000"</span>,</span><br><span class="line">                <span class="string">"--setgid=1000"</span>,</span><br><span class="line">                <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,"</span></span><br><span class="line">                        + <span class="string">"1024,1032,1065,3001,3002,3003,3006,3007,3009,3010"</span>,</span><br><span class="line">                <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">                <span class="string">"--nice-name=system_server"</span>,<span class="comment">// 进程名</span></span><br><span class="line">                <span class="string">"--runtime-args"</span>,</span><br><span class="line">                <span class="string">"--target-sdk-version="</span> + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,</span><br><span class="line">                <span class="string">"com.android.server.SystemServer"</span>,<span class="comment">// 加载类名</span></span><br><span class="line">        &#125;;</span><br><span class="line">        ZygoteArguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            parsedArgs = <span class="keyword">new</span> ZygoteArguments(args);</span><br><span class="line">            Zygote.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">            Zygote.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> profileSystemServer = SystemProperties.getBoolean(</span><br><span class="line">                    <span class="string">"dalvik.vm.profilesystemserver"</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (profileSystemServer) &#123;</span><br><span class="line">                parsedArgs.mRuntimeFlags |= Zygote.PROFILE_SYSTEM_SERVER;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Request to fork the system server process */</span></span><br><span class="line">            <span class="comment">//fork system_server 进程</span></span><br><span class="line">            pid = Zygote.forkSystemServer(</span><br><span class="line">                    parsedArgs.mUid, parsedArgs.mGid,</span><br><span class="line">                    parsedArgs.mGids,</span><br><span class="line">                    parsedArgs.mRuntimeFlags,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    parsedArgs.mPermittedCapabilities,</span><br><span class="line">                    parsedArgs.mEffectiveCapabilities);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* For child process */</span></span><br><span class="line">        <span class="comment">//pid == 0 表示子进程即system_server进程，继续剩余工作</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">               <span class="comment">// 如果有第二个 Zygote，需要等待2个zygote创建完成</span></span><br><span class="line">                waitForSecondaryZygote(socketName);</span><br><span class="line">            &#125;</span><br><span class="line">            zygoteServer.closeServerSocket(); <span class="comment">// 关闭并释放从 Zygote 复制过来的 socket</span></span><br><span class="line">            <span class="keyword">return</span> handleSystemServerProcess(parsedArgs);<span class="comment">//完成新创建的 system_server 进程的剩余工作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//如果是父进程就返回null</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的启动参数可以看到，<code>SystemServer</code> 进程的 <code>uid</code> 和 <code>gid</code> 都是 1000，进程名是 <strong><code>system_server</code></strong> ，其最后要加载的类名是 <strong><code>com.android.server.SystemServer</code></strong> 。准备好一系列参数之后通过 <code>ZygoteConnection.Arguments()</code>拼接，接着调用 <code>Zygote.forkSystemServer()</code> 方法，然后如果是子进程执行剩余工作，如果是父进程返回null。</p>
<p>ZygoteInit.forkSystemServer方法：</p>
<ol>
<li>为fork准备参数parsedArgs</li>
<li>调用Zygote.forkSystemServer()方法来创建system_server</li>
<li>fork之后，是子进程调用handleSystemServerProcess()方法执行system_server的剩余工作，父进程返回null</li>
</ol>
<h5 id="Zygote-forkSystemServer"><a href="#Zygote-forkSystemServer" class="headerlink" title="Zygote.forkSystemServer"></a>Zygote.forkSystemServer</h5><p>真正的 fork 出子进程 system_server。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkSystemServer</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span>[][] rlimits, <span class="keyword">long</span> permittedCapabilities, <span class="keyword">long</span> effectiveCapabilities)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//在fork新进程之前，停止Zygote的4个Daemon子线程的运行，等待并确保Zygote的单线程(用于fork效率)</span></span><br><span class="line">  			<span class="comment">//并等待这些线程的停止，初始化gc堆的工作</span></span><br><span class="line">  			ZygoteHooks.preFork();</span><br><span class="line">       <span class="comment">// Resets nice priority for zygote process.</span></span><br><span class="line">       resetNicePriority();</span><br><span class="line">       <span class="keyword">int</span> pid = nativeForkSystemServer(</span><br><span class="line">               uid, gid, gids, runtimeFlags, rlimits,</span><br><span class="line">               permittedCapabilities, effectiveCapabilities);</span><br><span class="line">       <span class="comment">// Enable tracing as soon as we enter the system_server.</span></span><br><span class="line">       <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">           Trace.setTracingEnabled(<span class="keyword">true</span>, runtimeFlags);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//在fork新进程之后，启动Zygote的4个Deamon线程，Java堆整理，引用队列，以及析构线程。</span></span><br><span class="line">       ZygoteHooks.postForkCommon();</span><br><span class="line">       <span class="keyword">return</span> pid;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">nativeForkSystemServer</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span>[][] rlimits, <span class="keyword">long</span> permittedCapabilities, <span class="keyword">long</span> effectiveCapabilities)</span></span>;</span><br></pre></td></tr></table></figure>

<p>最后的 <code>fork()</code> 操作是通过 JNI 调用 native 层方法 <code>nativeForkSystemServer()</code> 完成的。</p>
<blockquote>
<p>Zygote进程的4个Daemon子线程分别是<strong>ReferenceQueueDaemon</strong>、<strong>FinalizerDaemon</strong>、<strong>FinalizerWatchdogDaemon</strong>、<strong>HeapTaskDaemon</strong>，此处称为Zygote的4个Daemon子线程。</p>
</blockquote>
<h5 id="Zygote-nativeForkSystemServer"><a href="#Zygote-nativeForkSystemServer" class="headerlink" title="Zygote.nativeForkSystemServer"></a>Zygote.nativeForkSystemServer</h5><p>文件位于 <code>frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkSystemServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong effective_capabilities)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;int&gt; fds_to_close(MakeUsapPipeReadFDVector()),</span><br><span class="line">                   fds_to_ignore(fds_to_close);</span><br><span class="line"></span><br><span class="line">  fds_to_close.push_back(gUsapPoolSocketFD);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (gUsapPoolEventFD != <span class="number">-1</span>) &#123;</span><br><span class="line">    fds_to_close.push_back(gUsapPoolEventFD);</span><br><span class="line">    fds_to_ignore.push_back(gUsapPoolEventFD);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//fork 子进程</span></span><br><span class="line">  <span class="keyword">pid_t</span> pid = ForkCommon(env, <span class="literal">true</span>,</span><br><span class="line">                         fds_to_close,</span><br><span class="line">                         fds_to_ignore);</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">      SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits,</span><br><span class="line">                       permitted_capabilities, effective_capabilities,</span><br><span class="line">                       MOUNT_EXTERNAL_DEFAULT, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">true</span>,</span><br><span class="line">                       <span class="literal">false</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// The zygote process checks whether the child process has died or not.</span></span><br><span class="line">      ALOGI(<span class="string">"System server process %d has been created"</span>, pid);</span><br><span class="line">      gSystemServerPid = pid;</span><br><span class="line">      <span class="comment">// There is a slight window that the system server process has crashed</span></span><br><span class="line">      <span class="comment">// but it went unnoticed because we haven't published its pid yet. So</span></span><br><span class="line">      <span class="comment">// we recheck here just to make sure that all is well.</span></span><br><span class="line">      <span class="keyword">int</span> status;</span><br><span class="line">      <span class="keyword">if</span> (waitpid(pid, &amp;status, WNOHANG) == pid) &#123;</span><br><span class="line">          ALOGE(<span class="string">"System server process %d has died. Restarting Zygote!"</span>, pid);</span><br><span class="line">          RuntimeAbort(env, __LINE__, <span class="string">"System server process has died. Restarting Zygote!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (UsePerAppMemcg()) &#123;</span><br><span class="line">          <span class="comment">// Assign system_server to the correct memory cgroup.</span></span><br><span class="line">          <span class="comment">// Not all devices mount memcg so check if it is mounted first</span></span><br><span class="line">          <span class="comment">// to avoid unnecessarily printing errors and denials in the logs.</span></span><br><span class="line">          <span class="keyword">if</span> (!SetTaskProfiles(pid, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&#123;<span class="string">"SystemMemoryProcess"</span>&#125;)) &#123;</span><br><span class="line">              ALOGE(<span class="string">"couldn't add process %d into system memcg group"</span>, pid);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zygote.forkSystemServer方法：</p>
<ol>
<li><code>ZygoteHooks.preFork()</code>，fork 之前停止Zyote的4个Daemon子线程的运行，初始化gc堆</li>
<li>调用native层方法<code>nativeForkSystemServer()</code> 内部会调用<code>fork()</code>方法 fork 子进程，设置新进程的主线程id，重置gc堆性能数据，设置信号处理函数等功能</li>
<li><code>ZygoteHooks.postForkCommon()</code>，fork 之后启动4个Deamon子线程</li>
</ol>
<p><code>fork()</code> 函数是一次执行，两次返回。说的更严谨一点是 <strong>两个进程对一个程序的两次执行</strong>。当 <code>pid == 0</code> 时，说明现在处于子进程，当 <code>pid &gt; 0</code> 时，说明处于父进程。子进程 (system_server) 中会返回执行 <code>handleSystemServerProcess(parsedArgs)</code> 的结果，父进程 (zygote) 会返回 null。</p>
<p>回到 <code>ZygoteInit.forkSystemServer()</code> 中执行完 <code>Zygote.forkSystemServer</code> 之后的逻辑处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* For child process */</span></span><br><span class="line"><span class="comment">//pid == 0 表示子进程即system_server进程，继续剩余工作</span></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">    waitForSecondaryZygote(socketName);</span><br><span class="line">  &#125;</span><br><span class="line">    zygoteServer.closeServerSocket();</span><br><span class="line">   <span class="keyword">return</span> handleSystemServerProcess(parsedArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父进程 (zygote) 会返回 null</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>回到 <code>ZygoteInit.main()</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">        <span class="comment">// child (system_server) process.</span></span><br><span class="line">        <span class="comment">// r == null 说明是在 zygote 进程</span></span><br><span class="line">        <span class="comment">// r != null 说明是在 system_server 进程</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.run(); </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环等待处理客户端请求</span></span><br><span class="line">    caller = zygoteServer.runSelectLoop(abiList);</span><br></pre></td></tr></table></figure>

<p>子进程 system_server 返回的是一个 Runnable，执行 <code>r.run()</code>，然后就直接 return 了。而父进程 zygote 返回的是 null，所以不满足 if 的判断条件，继续往下执行 <code>runSelectLoop()</code>。 </p>
<h5 id="ZygoteInit-handleSystemServerProcess"><a href="#ZygoteInit-handleSystemServerProcess" class="headerlink" title="ZygoteInit.handleSystemServerProcess"></a>ZygoteInit.handleSystemServerProcess</h5><p>子进程 (system_server) 继续完成系统服务进程的剩余工作，调用 handleSystemServerProcess 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteArguments parsedArgs)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// set umask to 0077 so new files and directories will default to owner-only permissions.</span></span><br><span class="line">      <span class="comment">// 通过umask设置创建文件的默认权限</span></span><br><span class="line">       Os.umask(S_IRWXG | S_IRWXO);</span><br><span class="line">       <span class="comment">// 设置当前进程名为 "system_server"</span></span><br><span class="line">       <span class="keyword">if</span> (parsedArgs.mNiceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Process.setArgV0(parsedArgs.mNiceName);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 获取环境变量SYSTEMSERVERCLASSPATH，环境变量位于init.environ.rc中</span></span><br><span class="line">       <span class="keyword">final</span> String systemServerClasspath = Os.getenv(<span class="string">"SYSTEMSERVERCLASSPATH"</span>);</span><br><span class="line">       <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 对环境变量SYSTEMSERVERCLASSPATH中的jar包进行dex优化</span></span><br><span class="line">           <span class="keyword">if</span> (performSystemServerDexOpt(systemServerClasspath)) &#123;</span><br><span class="line">               sCachedSystemServerClassLoader = <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// prevents it.</span></span><br><span class="line">           <span class="keyword">boolean</span> profileSystemServer = SystemProperties.getBoolean(</span><br><span class="line">                   <span class="string">"dalvik.vm.profilesystemserver"</span>, <span class="keyword">false</span>);</span><br><span class="line">           <span class="keyword">if</span> (profileSystemServer &amp;&amp; (Build.IS_USERDEBUG || Build.IS_ENG)) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   prepareSystemServerProfile(systemServerClasspath);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   Log.wtf(TAG, <span class="string">"Failed to set up system server profile"</span>, e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//启动参数未包含"--invoke-with"，invokeWith 一般为空，直接走else</span></span><br><span class="line">       <span class="keyword">if</span> (parsedArgs.mInvokeWith != <span class="keyword">null</span>) &#123; </span><br><span class="line">           String[] args = parsedArgs.mRemainingArgs;</span><br><span class="line">           <span class="comment">// If we have a non-null system server class path, we'll have to duplicate the</span></span><br><span class="line">           <span class="comment">// existing arguments and append the classpath to it. ART will handle the classpath</span></span><br><span class="line">           <span class="comment">// correctly when we exec a new process.</span></span><br><span class="line">           <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">               String[] amendedArgs = <span class="keyword">new</span> String[args.length + <span class="number">2</span>];</span><br><span class="line">               amendedArgs[<span class="number">0</span>] = <span class="string">"-cp"</span>;</span><br><span class="line">               amendedArgs[<span class="number">1</span>] = systemServerClasspath;</span><br><span class="line">               System.arraycopy(args, <span class="number">0</span>, amendedArgs, <span class="number">2</span>, args.length);</span><br><span class="line">               args = amendedArgs;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           WrapperInit.execApplication(parsedArgs.mInvokeWith,</span><br><span class="line">                   parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,</span><br><span class="line">                   VMRuntime.getCurrentInstructionSet(), <span class="keyword">null</span>, args);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected return from WrapperInit.execApplication"</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 创建类加载器，并赋给当前线程</span></span><br><span class="line">           createSystemServerClassLoader();</span><br><span class="line">           ClassLoader cl = sCachedSystemServerClassLoader;</span><br><span class="line">           <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">               Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Pass the remaining arguments to SystemServer.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                   parsedArgs.mRemainingArgs, cl);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>ZygoteInit.handleSystemServerProcess方法：</p>
<ol>
<li>设置进程名为 <code>system_server</code>，获取环境变量值，进行 dex 优化</li>
<li>创建类加载器，并设置给当前线程</li>
<li>调用 <code>ZygoteInit.zygoteInit()</code> 继续处理剩余参数</li>
</ol>
<h5 id="ZygoteInit-zygoteInit"><a href="#ZygoteInit-zygoteInit" class="headerlink" title="ZygoteInit.zygoteInit"></a>ZygoteInit.zygoteInit</h5><p><code>ZygoteInit.zygoteInit()</code> 继续处理剩余参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过zygote方法，在开启的时候，来调用main方法。</span></span><br><span class="line"><span class="comment">//如果native代码的nativeFinishInit()中通过Zygote合理的启动，将会与main()统一。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (RuntimeInit.DEBUG) &#123;</span><br><span class="line">            Slog.d(RuntimeInit.TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ZygoteInit"</span>);</span><br><span class="line">        <span class="comment">//日志重定向 System.out 和 System.err 到 Android log</span></span><br><span class="line">        RuntimeInit.redirectLogStreams();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一些通用初始化工作</span></span><br><span class="line">        RuntimeInit.commonInit();</span><br><span class="line">        <span class="comment">// JNI方法，native 层zygote初始化</span></span><br><span class="line">        ZygoteInit.nativeZygoteInit();</span><br><span class="line">        <span class="comment">// 调用入口函数</span></span><br><span class="line">        <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ZygoteInit.zygoteInit 方法：</p>
<ol>
<li><code>RuntimeInit.redirectLogStreams()</code>日志重定向</li>
<li><code>RuntimeInit.commonInit()</code>进行一些通用的初始化</li>
<li><code>ZygoteInit.nativeZygoteInit()</code> 进行 native 层 zygote 初始化</li>
<li>调用<code>RuntimeInit.applicationInit()</code>进行应用的初始化</li>
</ol>
<h5 id="ZygoteInit-nativeZygoteInit"><a href="#ZygoteInit-nativeZygoteInit" class="headerlink" title="ZygoteInit.nativeZygoteInit"></a>ZygoteInit.nativeZygoteInit</h5><p>文件位于 <code>frameworks/base/core/jni/AndroidRuntime.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_ZygoteInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了onZygoteInit()函数，具体实现是在AppRuntime里面，位于<code>frameworks/base/cmds/app_process/app_main.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="comment">//单例模式创建ProcessState全局变量</span></span><br><span class="line">  sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">  ALOGV(<span class="string">"App process: starting thread pool.\n"</span>);</span><br><span class="line">  proc-&gt;startThreadPool();<span class="comment">//启动新Binder线程池</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>AppRuntime.onZygoteInit方法：</p>
<ol>
<li>构造了进程的ProcessState全局变量，主要作用就是调用open()打开<strong>/dev/binder</strong>驱动设备，再利用mmap()映射内核的地址空间，将Binder驱动的fd赋值ProcessState对象中的变量mDriverFD，用于交互操作</li>
<li>启动 Binder 线程池，创建一个新的binder，使 system_server 进程和其他进程进行Binder通信</li>
</ol>
<h5 id="RuntimeInit-applicationInit"><a href="#RuntimeInit-applicationInit" class="headerlink" title="RuntimeInit.applicationInit"></a>RuntimeInit.applicationInit</h5><p>调用<code>RuntimeInit.applicationInit</code>方法进行应用的初始化，位于<code>frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">         ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// If the application calls System.exit(), terminate the process</span></span><br><span class="line">     <span class="comment">// immediately without running any shutdown hooks.  It is not possible to</span></span><br><span class="line">     <span class="comment">// shutdown an Android application gracefully.  Among other things, the</span></span><br><span class="line">     <span class="comment">// Android runtime shutdown hooks close the Binder driver, which can cause</span></span><br><span class="line">     <span class="comment">// leftover running threads to crash before the process actually exits.</span></span><br><span class="line">     <span class="comment">//true 代表应用程序退出时，不调用AppRuntime.onExit()，否则会在退出前调用</span></span><br><span class="line">     nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// We want to be fairly aggressive about heap utilization, to avoid</span></span><br><span class="line">     <span class="comment">// holding on to a lot of memory that isn't needed.</span></span><br><span class="line">     <span class="comment">// 设置虚拟机的内存利用率数值为0.75</span></span><br><span class="line">     VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75f</span>);</span><br><span class="line">     VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line">     <span class="comment">// 解析参数</span></span><br><span class="line">     <span class="keyword">final</span> Arguments args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// The end of of the RuntimeInit event (see #zygoteInit).</span></span><br><span class="line">     Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Remaining arguments are passed to the start class's static main</span></span><br><span class="line">    <span class="comment">//寻找 startClass 的静态main() 方法。这里的 startClass 是 com.android.server.SystemServer</span></span><br><span class="line">     <span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>RuntimeInit 的 applicationInit 方法：</p>
<ol>
<li>解析调用参数</li>
<li>调用<code>findStaticMain()</code>寻找startClass类的静态main()方法</li>
</ol>
<h5 id="RuntimeInit-findStaticMain"><a href="#RuntimeInit-findStaticMain" class="headerlink" title="RuntimeInit.findStaticMain"></a>RuntimeInit.findStaticMain</h5><p>调用 <code>findStaticMain</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用目标类className类的静态main(argv []) 方法。</span></span><br><span class="line"><span class="comment">//将各种失败异常转化为RuntimeExceptions，并且这些异常将会导致VM实例退出。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">findStaticMain</span><span class="params">(String className, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//找到指定的className类</span></span><br><span class="line">            cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Missing class when invoking static main "</span> + className,</span><br><span class="line">                    ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method m;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//找到className类的main()方法</span></span><br><span class="line">            m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[]<span class="class">.<span class="keyword">class</span> &#125;)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Missing static main on "</span> + className, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Problem getting static main on "</span> + className, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Main method is not public and static on "</span> + className);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">         * by invoking the exception's run() method. This arrangement</span></span><br><span class="line"><span class="comment">         * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">         * up the process.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      <span class="comment">//返回一个 Runnable，在 Zygote 的 main() 方法中执行 run() 方法</span></span><br><span class="line">     <span class="comment">//之前的版本是抛出一个异常，在 main() 方法中捕获，这样做的好处是清空栈帧，提高栈帧利用率</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>RuntimeInit.findStaticMain方法：</p>
<ol>
<li>找到指定的className类</li>
<li>找到className类的main()方法</li>
<li>返回一个 Runnable，在 ZygoteInit 的 main() 方法中执行 run() 方法</li>
</ol>
<h5 id="MethodAndArgsCaller"><a href="#MethodAndArgsCaller" class="headerlink" title="MethodAndArgsCaller"></a>MethodAndArgsCaller</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Helper class which holds a method and arguments and can call them. This is used as part of</span></span><br><span class="line"><span class="comment">     * a trampoline to get rid of the initial process setup stack frames.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** method to call */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** argument array */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">            mMethod = method;</span><br><span class="line">            mArgs = args;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 根据传递过来的参数，可知此处通过反射机制调用的是SystemServer.main()方法</span></span><br><span class="line">                mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">                Throwable cause = ex.getCause();</span><br><span class="line">                <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>zygote启动system_server进程的流程已经一步步的简要分析完了，通过反射机制进入到SystemServer.main中，进行类似与初始化的工作内容了。</p>
<p>system_server 进程在启动过程中完成的工作分别是:</p>
<ol>
<li>启动 Binder 线程池，使进程可以通过 Binder 与其他进程进程通信</li>
<li>创建 SystemServiceManager</li>
<li>使用 SystemServiceManager 对各种系统服务进行创建、启动和生命周期管理</li>
</ol>
<h4 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h4><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，从整体上来看 Android 系统的启动流程：</p>
<ol>
<li>按下电源，固化在 ROM 中预定位置的 Bootloader 将会被加载到内存中</li>
<li>Bootloader 初始化完软硬件环境后将 Linux 内核启动起来</li>
<li>Linux 内核启动时会做设置缓存、被保护存储器、计划列表和加载驱动等一些列操作，内核启动完成后会启动 init 进程</li>
<li>init 进程会初始化并启动属性服务，并且解析并执行所有 init.rc 文件</li>
<li>init 通过执行特定的 init.rc 文件启动 servermanager 进程，servermanager 被启动后会向 Binder 驱动发送命令让自己成为守护进程并管理所有上下文</li>
<li>init 通过解析 init.rc 文件启动 zygote 进程</li>
<li>zygote 进程启动的过程会创建 DVM 并为其注册 JNI 函数，然后创建服务端 Socket、启动 system_server 进程</li>
<li>启动 system_server 进程的过程会创建 Binder 线程池使其具有 IPC 能力，然后启动 AMS 等各种系统服务</li>
<li>AMS 启动 Launcher，Launcher 被启动后会将已安装应用的图标显示在界面上</li>
</ol>
]]></content>
      <categories>
        <category>Android进阶</category>
      </categories>
      <tags>
        <tag>Android进阶</tag>
      </tags>
  </entry>
</search>
