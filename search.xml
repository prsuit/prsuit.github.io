<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Activity必备基础</title>
    <url>/2020/07/23/Activity%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android的四大组件之一的Activity。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、Activity是什么"><a href="#一、Activity是什么" class="headerlink" title="一、Activity是什么"></a>一、Activity是什么</h4><p>我们都知道android中有四大组件（Activity 活动，Service 服务，BroadcastReceiver 广播接收器，Content Provider 内容提供者），Activity是用的最多也是最基本的组件，Activity 提供窗口来和用户进行交互的组件。官方是这么介绍的：</p>
<a id="more"></a>

<blockquote>
<p>An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View).</p>
<p>一个activity是一个单独的，用来处理用户操作的窗口。几乎所有的activity都是用来和用户交互的，所以activity类会创建了一个窗口，你可以通过setContentView(View)显示你的UI在窗口上。</p>
</blockquote>
<ul>
<li>Activity是一个应用程序组件，提供一个屏幕，用户可以用来交互为了完成某项任务。</li>
<li>Activity中所有操作都与用户密切相关，是一个负责与用户交互的组件，可以通过setContentView(View)来显示指定控件。</li>
</ul>
<h4 id="二、Activity状态及转换"><a href="#二、Activity状态及转换" class="headerlink" title="二、Activity状态及转换"></a>二、Activity状态及转换</h4><p>在android 中，Activity 拥有四种基本状态：</p>
<p>1.<strong>Active/Running</strong></p>
<p>​    一个新 Activity 启动入栈后，它显示在屏幕最前端，处理是处于栈的最顶端（Activity栈顶），此时它处于可见并可和用户交互的激活状态，叫做活动状态或者运行状态（active or running）。</p>
<p>2.<strong>Paused</strong></p>
<p>​    当 Activity 失去焦点，被另一个透明或者 Dialog 样式非全屏的 Activity 覆盖时的状态，叫做暂停状态（Paused）。此时它依然与窗口管理器保持连接，系统继续维护其内部状态，所以它仍然可见，但它已经失去了焦点故不可与用户交互。</p>
<p>3.<strong>Stopped</strong></p>
<p>​    当 Activity 被另外一个 Activity 完全覆盖掉，不可再见时的状态叫做停止状态（Stopped）。</p>
<p>4.<strong>Killed</strong></p>
<p>​    Activity 被系统杀死回收或者没有被启动时的状态，叫做被杀死的状态（Killed）。</p>
<p>下图说明了 Activity 在不同状态间转换的时机和条件：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5lxx3ssej308n081dfu.jpg" alt=""></p>
<h4 id="三、Activity栈"><a href="#三、Activity栈" class="headerlink" title="三、Activity栈"></a>三、Activity栈</h4><p>Android 是通过一种 Activity 栈的方式来管理 Activity 的，一个 Activity 的实例的状态决定它在栈中的位置。处于前台的 Activity 总是在栈的顶端，当前台的 Activity 因为异常或其它原因被销毁时，处于栈第二层的 Activity 将被激活，上浮到栈顶。当新的 Activity 启动入栈时，原 Activity 会被压入到栈的第二层。一个 Activity 在栈中的位置变化反映了它在不同状态间的转换。Activity 的状态与它在栈中的位置关系如下图所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5m9bc21zj308w05r748.jpg" alt=""></p>
<p>如上所示，除了最顶层即处在 Active 状态的 Activity 外，其它的 Activity 都有可能在系统内存不足时被回收，一个 Activity 的实例越是处在栈的底层，它被系统回收的可能性越大。系统负责管理栈中 Activity 的实例，它根据 Activity 所处的状态来改变其在栈中的位置。</p>
<h4 id="四、Activity生命周期"><a href="#四、Activity生命周期" class="headerlink" title="四、Activity生命周期"></a>四、Activity生命周期</h4><p>生命周期函数，常用的7个如下：</p>
<p><strong>onCreate()</strong>：表示 Activity <strong>正在被创建</strong>，常用来<strong>初始化工作</strong>，比如调用 setContentView 加载界面布局资源，初始化 Activity 所需数据等；</p>
<p><strong>onReStart()</strong>：表示 Activity <strong>正在重新启动</strong>，当前 Acitivty 从不可见重新变为可见时，onRestart 就会被调用；</p>
<p><strong>onStart()</strong>：表示 Activity <strong>正在被启动</strong>，此时 Activity <strong>可见但不在前台</strong>，还处于后台，无法与用户交互；</p>
<p><strong>onResume()</strong>：表示 Activity <strong>获得焦点</strong>，此时 Activity <strong>可见且在前台</strong>并开始活动，位于活动堆栈的顶部，这是与onStart的区别所在；</p>
<p><strong>onPause()</strong>：表示 Activity <strong>正在停止</strong>，<strong>可见但不在前台</strong>，此时可做一些<strong>存储数据、停止动画</strong>等工作，但是不能太耗时，因为这会影响到新 Activity 的显示，onPause 必须先执行完，新 Activity 的 onResume 才会执行；</p>
<p><strong>onStop()</strong>：表示 Activity <strong>即将停止</strong>，被新 activity 覆盖了，对用户<strong>不可见</strong>，可以做一些稍微重量级的回收工作，比如注销广播接收器、关闭网络连接等，同样不能太耗时；</p>
<p><strong>onDestroy()</strong>：表示 Activity <strong>即将被销毁</strong>，这是 Activity 生命周期中的最后一个回调，常做<strong>回收工作、资源释放</strong>；</p>
<ul>
<li>延伸：从<strong>整个生命周期</strong>来看，<strong>onCreate</strong> 和 <strong>onDestroy</strong> 是配对的，分别标识着 Activity 的创建和销毁，并且只可能有<strong>一次调用</strong>； 从 Activity <strong>是否可见</strong>来说，<strong>onStart</strong> 和 <strong>onStop</strong> 是配对的，这两个方法可能被<strong>调用多次</strong>； 从 Activity <strong>是否在前台</strong>来说，<strong>onResume</strong> 和 <strong>onPause</strong> 是配对的，这两个方法可能被<strong>调用多次</strong>； 除了这种区别，在实际使用中没有其他明显区别。</li>
</ul>
<p>Activity 生命周期循环图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5o2g5wxnj30e90if75q.jpg" alt=""></p>
<p><strong>onSaveInstanceState()</strong>：发生条件在系统配置发生改变（例如屏幕方向）导致 Activity 被杀死并重新创建、资源内存不足导致低优先级的 Activity 被杀死，系统会调用 <strong>onSaveInstanceState</strong> 来保存当前 Activity 的状态，此方法调用在 onStop 之后 和 onDestory 之前；</p>
<p><strong>onRestoreInstanceState()</strong>： 当 Activity 被重建后，系统会调用 <strong>onRestoreInstanceState</strong>，并且把onSaveInstanceState 方法所保存的 Bundle 对象<strong>同时传参</strong>给 onRestoreInstanceState() 和 onCreate() ，因此可以通过这两个方法判断 Activity <strong>是否被重建</strong>，调用在 onStart 之后，可使用 onSaveInstanceState() 和onRestoreInstanceState()（或onCreate()）来保存和恢复 Activity 活动状态。</p>
<h4 id="五、Activity启动和通信"><a href="#五、Activity启动和通信" class="headerlink" title="五、Activity启动和通信"></a>五、Activity启动和通信</h4><p><strong>Intent</strong>是一种消息传递的机制，它负责对操作的动作、动作涉及数据、附加数据进行描述。Android 则根据此Intent的描述，负责找到对应的组件，将 Intent 传递给调用的组件，并完成组件的调用。</p>
<h5 id="显式Intent"><a href="#显式Intent" class="headerlink" title="显式Intent"></a>显式Intent</h5><p>通过指定具体的组件类，通知应用启动对应的组件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClass(MainActivity.<span class="keyword">this</span>,SecondAcvivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">intent.putExtra(<span class="string">"values"</span>,<span class="string">"传个值"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<h5 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h5><p>通过指定了一系列更为抽象的 action 和 category 等信息，然后交由系统去分析这个 Intent，并帮我们找出合适的活动去启动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.administrator.ACTION_START"</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>要在清单文件中<code>&lt;activity&gt;</code>标签下配置<code>&lt;intent-filter&gt;</code>的内容，可以指定当前活动能够响应的 action<br>和 category，如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".SecondActivity"</span> &gt;</span><br><span class="line">	&lt;intent-filter&gt;</span><br><span class="line">		&lt;action android:name=<span class="string">"com.example.administrator.ACTION_START"</span> /&gt;</span><br><span class="line">		&lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">	&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Intent-Filter"><a href="#Intent-Filter" class="headerlink" title="Intent Filter"></a>Intent Filter</h5><p>描述了一个组件愿意接收什么样的 Intent 对象，Android 将其抽象为 android.content.IntentFilter 类。 Activity 通过指定其 Intent Filter告诉系统该 Activity 可以响应什么类型的 Intent，有三大属性Action、URL、Category可以配置。</p>
<p>Activity 中 Intent Filter 匹配的过程：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh6iwqed6kj30890bvmxc.jpg" alt=""></p>
<p><strong>Action 匹配</strong></p>
<p>是一个用户定义的字符串，一个 Intent Filter 可以包含多个 Action，用于标示 Activity 所能接受的”动作”。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter &gt;</span><br><span class="line"> 	&lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line"> 	&lt;action android:name=<span class="string">"com.xx.myaction"</span> /&gt;</span><br><span class="line">	......</span><br><span class="line"> &lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<p><strong>URI 数据匹配</strong></p>
<p>通过 URI 携带外部数据给目标组件，在<code>&lt;intent-filter&gt;</code>标签中配置一个<code>&lt;data&gt;</code>标签。</p>
<p>mimeType 属性指定携带外部数据的数据类型，scheme 指定协议，host、port、path 指定数据的位置、端口、和路径。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">	&lt;data android:mimeType=<span class="string">"mimeType"</span> android:scheme=<span class="string">"scheme"</span></span><br><span class="line"> 				android:host=<span class="string">"host"</span> android:port=<span class="string">"port"</span> android:path=<span class="string">"path"</span>/&gt;</span><br><span class="line">&lt;/intent-filter</span><br></pre></td></tr></table></figure>

<p>只有<code>&lt;data&gt;</code>标签中指定的内容和 Intent 中携带的 Data 完全一致时，当前活动才能够响应该 Intent。不过一般在<code>&lt;data&gt;</code>标签中都不会指定过多的内容。</p>
<p><strong>Category 类别匹配</strong></p>
<p>为组件定义一个 Category 类别列表，当 Intent 中包含这个列表的所有项目时 Category 类别匹配才会成功。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;intent-filter&gt;</span><br><span class="line">	&lt;category android:name=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span><br><span class="line">&lt;/intent-filter&gt;</span><br></pre></td></tr></table></figure>

<p>android.intent.category.DEFAULT 是一种默认的 category，在调用startActivity()方法的时候会自动将这个 category 添加到 Intent 中。</p>
<p><strong>接收上一个Activity返回数据</strong></p>
<p><strong>startActivityForResult()</strong>方法也是用于启动 Activity 的，这个方法可以 Activity 销毁的时候能够返回一个结果给上一个活动。该方法接收两个参数，第一个参数还是 Intent，第二个参数是请求码，用于在之后的回调中判断数据的来源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">startActivityForResult(intent, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>返回代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"data_return"</span>, <span class="string">"Hello MainActivity"</span>);</span><br><span class="line">setResult(RESULT_OK, intent);</span><br><span class="line">finish();</span><br></pre></td></tr></table></figure>

<p><strong>setResult()</strong>方法接收两个参数，第一个参数用于向上一个活动返回处理结果，一般只使用<strong>RESULT_OK</strong>或<strong>RESULT_CANCELED</strong>，第二个参数则是把带有数据的 Intent 传递回去，然后调用了 finish()方法来销毁当前活动。</p>
<p>在需要接收返回数据的 Activity 中重写<strong>onActivityResult()</strong>方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	<span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">		String returnedData = data.getStringExtra(<span class="string">"data_return"</span>);</span><br><span class="line">		Log.d(<span class="string">"FirstActivity"</span>, returnedData);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onActivityResult()方法带有三个参数：</p>
<p>第一个参数 requestCode，即我们在启动活动时传入的请求码。</p>
<p>第二个参数 resultCode，即我们在返回数据时传入的处理结果。</p>
<p>第三个参数 data，即携带着返回数据的 Intent。</p>
<h4 id="六、Activity启动模式"><a href="#六、Activity启动模式" class="headerlink" title="六、Activity启动模式"></a>六、Activity启动模式</h4><h5 id="使用-manifest-文件"><a href="#使用-manifest-文件" class="headerlink" title="使用 manifest 文件"></a>使用 manifest 文件</h5><p>在 manifest 文件中通过给<code>&lt;activity&gt;</code>标签的<strong>android:launchMode</strong>属性来指定恰当的启动模式。</p>
<p>1.<strong>standard标准模式</strong></p>
<p>​        每次启动一个 Activity 都会重新创建一个新的实例，不管这个实例是否已经存在，此模式的 Activity 默认会进入启动它的 Activity 所属的任务栈中；</p>
<p>2.<strong>singleTop栈顶复用模式</strong></p>
<p>​        如果新 Activity 已经位于任务栈的栈顶，那么此 Activity 不会被重新创建，同时会回调 <strong>onNewIntent</strong> 方法，如果已经存在但不在栈顶，那么 Activity 依然会被重新创建；一般用于推送消息跳转界面。</p>
<p>3.<strong>singleTask栈内复用模式</strong></p>
<p>​        Activity 在同一个Task内只有一个实例。每次启动该 Activity 时系统首先会在返回栈中检查是否存在该Activity 的实例，如果发现已经存在则直接使用该实例，回调其<strong>onNewIntent</strong>方法，并把在这个 Activity 之上的所有 Activity 统统出栈；如果没有发现就会创建一个新的 Activity 实例，并将其加入Task栈顶，一般项目的主页面用该启动模式。</p>
<p>4.<strong>singleInstance单实例模式</strong></p>
<p>整个系统里只有一个实例，Activity只能单独地位于一个任务栈中，且此任务栈中只有唯一一个实例，在不同app之间的共享活动实例，一般用于系统功能界面。</p>
<h5 id="使用-Intent-标志"><a href="#使用-Intent-标志" class="headerlink" title="使用 Intent 标志"></a>使用 Intent 标志</h5><p>Activity常用的标记位Flags</p>
<ul>
<li><p><strong>FLAG_ACTIVITY_NEW_TASK</strong>：<del>对应 singleTask 启动模式</del>。</p>
<p>1.单独的<code>FLAG_ACTIVITY_NEW_TASK</code> 并不等价于启动模式 <code>singleTask</code>，它仅表示寻找activity所需的任务栈压入，（即<code>TaskAffinity</code>指定的任务栈，<code>TaskAffinity</code> 默认为应用包名）</p>
<p>2.<code>FLAG_ACTIVITY_NEW_TASK</code>+<code>FLAG_ACTIVITY_CLEAR_TOP</code>也不等价于启动模式<code>singleTask</code></p>
<p>3.在<code>FLAG_ACTIVITY_NEW_TASK</code>+<code>FLAG_ACTIVITY_CLEAR_TOP</code>的情况下，AndroidManifest.xml中设置activity的启动模式为<code>standard</code>或<code>singleTask</code>时activity入栈方式是不一样的。分为如下3个情况：</p>
<p>​    <strong>3.1</strong>当启动模式为<code>standard</code>时，如果activity所需的栈中已经存在该activity的实例了，那么这个实例连同它之上的activity都要出栈，然后再新建一个activity实例入栈。</p>
<p>​    <strong>3.2</strong>当启动模式为<code>singleTask</code>时，如果activity所需的栈中已经存在该activity的实例了，那么系统会调用该实例的<code>onNewIntent()</code>方法，且只将该实例之上的activity出栈。</p>
<p>​    <strong>3.3</strong>如果activity所需的栈中<strong>不存在</strong>该activity的实例，则不论启动模式为<code>standard</code>还是<code>singleTask</code>，都是新建activity实例直接入栈。</p>
<p>4.AndroidManifest.xml中设置activity的启动模式为<code>singleTask</code>时，则不论是<code>FLAG_ACTIVITY_NEW_TASK</code>+<code>FLAG_ACTIVITY_CLEAR_TOP</code>还是只有<code>FLAG_ACTIVITY_NEW_TASK</code>效果一样，因为singleTask模式中默认就带有<code>FLAG_ACTIVITY_CLEAR_TOP</code>标识。</p>
</li>
<li><p><strong>FLAG_ACTIVITY_SINGLE_TOP</strong>：对应 singleTop 启动模式。</p>
</li>
<li><p><strong>FLAG_ACTIVITY_CLEAR_TOP</strong>：在同一个任务栈中所有位于它上面的 Activity 都要出栈。这个标记位一般会和 singleTask 模式一起出现，在这种情况下，被启动Activity的实例如果已经存在，那么系统就会回调onNewIntent。如果被启动的 Activity 采用 standard 模式启动，那么它以及连同它之上的 Activity 都要出栈，系统会创建新的 Activity 实例并放入栈中。</p>
</li>
<li><p><strong>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS :</strong> 具有这个标记的 Activity 不会出现在历史 Activity 列表中。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以此文记录 Android 中 Activity 的基础知识，便于对 Activity 的理解和学习。</p>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ContentProvider必备基础</title>
    <url>/2020/07/29/ContentProvider%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android的四大组件之一的ContentProvider。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是ContentProvider"><a href="#一、什么是ContentProvider" class="headerlink" title="一、什么是ContentProvider"></a>一、什么是ContentProvider</h4><p>ContentProvider 是 Android 中提供的专门用于不同应用间数据交互和共享的组件。它实际上是对SQLiteOpenHelper 的进一步封装，以一个或多个表的形式将数据呈现给外部应用，通过 Uri 映射来选择需要操作数据库中的哪个表，并对表中的数据进行增删改查处理。ContentProvider 其底层使用了 Binder 来完成APP 进程之间的通信，同时使用匿名共享内存来作为共享数据的载体。ContentProvider 支持访问权限管理机制，以控制数据的访问者及访问方式，保证数据访问的安全性。</p>
<a id="more"></a>

<h4 id="二、相关知识"><a href="#二、相关知识" class="headerlink" title="二、相关知识"></a>二、相关知识</h4><h5 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h5><p><strong>Uniform Resource Identifier</strong> 即统一资源标识符，外界进程通过 <code>URI</code> 找到对应的 ContentProvider 和其中的数据，再进行数据操作。以联系人Contacts 的 Uri 为例，其结构如下所示：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghdopxmxsmj30ig04kdfp.jpg" alt=""></p>
<p><strong>schema:</strong>  Android 中固定为 <code>content://</code>。</p>
<p><strong>authority:</strong>  用于唯一标识一个 ContentProvider。</p>
<p><strong>path:</strong>  ContentProvider 中数据表的表名。</p>
<p><strong>id:</strong>  数据表中数据的标识，可选字段。</p>
<h5 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h5><p>指定某种扩展名的文件用什么应用程序来打开的方式类型。ContentProvider 会根据 URI 来返回一个包含两部分 MIME 类型的字符串，每种 <code>MIME</code> 类型一般由2部分组成 = 类型 + 子类型，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">text/html <span class="comment">// 类型 = text、子类型 = html</span></span><br><span class="line">text/css </span><br><span class="line">text/xml </span><br><span class="line">application/pdf</span><br></pre></td></tr></table></figure>

<h5 id="UriMatcher类"><a href="#UriMatcher类" class="headerlink" title="UriMatcher类"></a>UriMatcher类</h5><p>是一个工具类，帮助匹配 ContentProvider 中的 Uri。提供了两个方法 <strong>addURI()</strong> 和 <strong>match()</strong> 方法。</p>
<ul>
<li><strong>addURI(String authority,String path, int code)：</strong>是在 ContentProvider 添加一个用于匹配的 Uri，当匹配成功时返回 code 。在 ContentProvider 中注册 URI ，把 Uri 和 code 相关联，Uri可以是精确的字符串，Uri 中带有*表示可匹配任意text，#表示只能匹配数字</li>
<li><strong>match(Uri uri) ：</strong>根据 URI 匹配 ContentProvider 中对应的数据表，对 Uri 进行验证。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：初始化UriMatcher对象</span></span><br><span class="line">    UriMatcher matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH); </span><br><span class="line">    <span class="comment">//常量UriMatcher.NO_MATCH  = 不匹配任何路径的返回码</span></span><br><span class="line">    <span class="comment">// 即初始化时不匹配任何东西</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：在ContentProvider 中注册URI（addURI（））</span></span><br><span class="line">    <span class="keyword">int</span> URI_CODE_a = <span class="number">1</span>；</span><br><span class="line">    <span class="keyword">int</span> URI_CODE_b = <span class="number">2</span>；</span><br><span class="line">    matcher.addURI(<span class="string">"com.prsuit.myprovider"</span>, <span class="string">"user"</span>, URI_CODE_a); </span><br><span class="line">    matcher.addURI(<span class="string">"com.prsuit.myprovider"</span>, <span class="string">"book"</span>, URI_CODE_b); </span><br><span class="line">    <span class="comment">// 若URI资源路径 = content://com.prsuit.myprovider/user ，则返回注册码URI_CODE_a</span></span><br><span class="line">    <span class="comment">// 若URI资源路径 = content://com.prsuit.myprovider/book ，则返回注册码URI_CODE_b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源（match（））</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMatchTableName</span><span class="params">(Uri uri)</span> </span>&#123;   </span><br><span class="line">      Uri uri = Uri.parse(<span class="string">" content://com.prsuit.myprovider/user"</span>);   </span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span>(matcher.match(uri))&#123;   </span><br><span class="line">     <span class="comment">// 根据URI匹配的返回码是URI_CODE_a</span></span><br><span class="line">     <span class="comment">// 即matcher.match(uri) == URI_CODE_a</span></span><br><span class="line">      <span class="keyword">case</span> URI_CODE_a:   </span><br><span class="line">        <span class="keyword">return</span> tableNameUser;   </span><br><span class="line">        <span class="comment">// 如果根据URI匹配的返回码是URI_CODE_a，则返回ContentProvider中的名为tableNameUser的表</span></span><br><span class="line">      <span class="keyword">case</span> URI_CODE_b:   </span><br><span class="line">        <span class="keyword">return</span> tableNameBook;</span><br><span class="line">        <span class="comment">// 如果根据URI匹配的返回码是URI_CODE_b，则返回ContentProvider中的名为tableNameBook的表</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ContentUris类"><a href="#ContentUris类" class="headerlink" title="ContentUris类"></a>ContentUris类</h5><p>用来操作 <code>URI</code>，核心方法有两个：<strong>withAppendedId()</strong> 和 <strong>parseId()</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// withAppendedId（）作用：向URI追加一个id</span></span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://com.prsuit.myprovider/user"</span>) </span><br><span class="line">Uri resultUri = ContentUris.withAppendedId(uri, <span class="number">7</span>);  </span><br><span class="line"><span class="comment">// 最终生成后的Uri为：content://com.prsuit.myprovider/user/7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parseId（）作用：从URL中获取ID</span></span><br><span class="line">Uri uri = Uri.parse(<span class="string">"content://com.prsuit.myprovider/user/7"</span>) </span><br><span class="line"><span class="keyword">long</span> personid = ContentUris.parseId(uri); </span><br><span class="line"><span class="comment">//获取的结果为:7</span></span><br></pre></td></tr></table></figure>

<h5 id="ContentProvider类"><a href="#ContentProvider类" class="headerlink" title="ContentProvider类"></a>ContentProvider类</h5><p>组织数据方式，ContentProvider 主要以 <strong>表格的形式</strong> 组织数据。进程间共享数据的本质是：添加、删除、获取和修改（更新）数据，所以其核心方法也主要是上述4个作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;-- <span class="number">4</span>个核心方法 --&gt;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span></span><br><span class="line"><span class="function">  <span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span></span><br><span class="line"><span class="function">  <span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function">  <span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs,  String sortOrder)</span>　 </span></span><br><span class="line"><span class="function">  <span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 注：</span></span></span><br><span class="line"><span class="function">  <span class="comment">// 1. 上述4个方法由外部进程回调，并运行在ContentProvider进程的Binder线程池中（不是主线程）</span></span></span><br><span class="line"><span class="function"> <span class="comment">// 2. 存在多线程并发访问，需要实现线程同步</span></span></span><br><span class="line"><span class="function">   <span class="comment">// a. 若ContentProvider的数据存储方式是使用SQLite &amp; 一个，则不需要，因为SQLite内部实现好了线程同步，若是多个SQLite则需要，因为SQL对象之间无法进行线程同步</span></span></span><br><span class="line"><span class="function">  <span class="comment">// b. 若ContentProvider的数据存储方式是内存，则需要自己实现线程同步</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&lt;-- 2个其他方法 --&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// ContentProvider创建后 或 打开系统后其它进程第一次访问该ContentProvider时 由系统进行调用</span></span></span><br><span class="line"><span class="function"><span class="comment">// 注：运行在ContentProvider进程的主线程，故不能做耗时操作</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 得到数据类型，即返回当前 Url 所代表数据的MIME类型</span></span></span><br></pre></td></tr></table></figure>

<h5 id="ContentResolver类"><a href="#ContentResolver类" class="headerlink" title="ContentResolver类"></a>ContentResolver类</h5><p>统一管理不同 ContentProvider 间的操作，ContentProvider 类并不会直接与外部进程交互，而是通过ContentResolver 类。它提供了与 ContentProvider 类相同名字和作用的4个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部进程向 ContentProvider 中添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span>　 </span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程 删除 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 外部进程更新 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>　 </span></span><br><span class="line"><span class="function"><span class="comment">// 外部应用 获取 ContentProvider 中的数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="ContentObserver类"><a href="#ContentObserver类" class="headerlink" title="ContentObserver类"></a>ContentObserver类</h5><p>内容观察者，观察 Uri 引起 ContentProvider 中的数据变化并通知数据访问者。当 ContentProvider 中的数据发生变化（增、删 、改）时，就会触发该 ContentObserver 类，可以通过 ContentResolver 的registerContentObserver 和 unregisterContentObserver 方法来注册和注销 ContentObserver 监听器。当被监听的ContentProvider发生变化时，就会回调对应的 ContentObserver 的 onChange 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：注册内容观察者ContentObserver</span></span><br><span class="line">    getContentResolver().registerContentObserver（uri）；</span><br><span class="line">    <span class="comment">// 通过ContentResolver类进行注册，并指定需要观察的URI</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：当该URI的ContentProvider数据发生变化时，通知外界（即访问该ContentProvider数据的访问者）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123; </span><br><span class="line">      <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123; </span><br><span class="line">      db.insert(<span class="string">"user"</span>, <span class="string">"userid"</span>, values);</span><br><span class="line">      <span class="comment">// 通知访问者</span></span><br><span class="line">      getContext().getContentResolver().notifyChange(uri, <span class="keyword">null</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：解除观察者</span></span><br><span class="line"> getContentResolver().unregisterContentObserver（uri）；</span><br><span class="line">    <span class="comment">// 同样需要通过ContentResolver类进行解除</span></span><br></pre></td></tr></table></figure>

<h4 id="三、具体使用"><a href="#三、具体使用" class="headerlink" title="三、具体使用"></a>三、具体使用</h4><h5 id="创建数据库类"><a href="#创建数据库类" class="headerlink" title="创建数据库类"></a>创建数据库类</h5><p>创建类 DBHelper 继承 SQLiteOpenHelper 并实现构造方法以及重载 onCreate 和 onUpgrade 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATABASE_NAME = <span class="string">"com_sample_provider.db"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">"user"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOK_TABLE_NAME = <span class="string">"book"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATABASE_VERSION = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CREATE_USER_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span></span><br><span class="line">            + USER_TABLE_NAME</span><br><span class="line">            + <span class="string">"(id INTEGER PRIMARY KEY AUTOINCREMENT,name VARCHAR(64))"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CREATE_BOOK_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span></span><br><span class="line">            + BOOK_TABLE_NAME</span><br><span class="line">            + <span class="string">"(id INTEGER PRIMARY KEY AUTOINCREMENT,name VARCHAR(64))"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context,DATABASE_NAME,<span class="keyword">null</span>,DATABASE_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, <span class="keyword">int</span> version)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, name, factory, version);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, <span class="keyword">int</span> version, @Nullable DatabaseErrorHandler errorHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, name, factory, version, errorHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi</span>(api = Build.VERSION_CODES.P)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(@Nullable Context context, @Nullable String name, <span class="keyword">int</span> version, @NonNull SQLiteDatabase.OpenParams openParams)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, name, version, openParams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建数据表格:用户表和图书表</span></span><br><span class="line">        db.execSQL(CREATE_USER_TABLE);</span><br><span class="line">        db.execSQL(CREATE_BOOK_TABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空user表数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearTable</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        SQLiteDatabase database = <span class="keyword">new</span> DBHelper(context).getWritableDatabase();</span><br><span class="line">        database.execSQL(<span class="string">"delete from user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自定义-ContentProvider-类，实现相关的抽象方法"><a href="#自定义-ContentProvider-类，实现相关的抽象方法" class="headerlink" title="自定义 ContentProvider 类，实现相关的抽象方法"></a>自定义 ContentProvider 类，<strong>实现相关的抽象方法</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyContentProvider"</span>;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> DBHelper dbHelper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase mDatabase = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String matchTableName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ContentProvider的唯一标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">"com.prsuit.myprovider"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_PATH = <span class="string">"user"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOK_PATH = <span class="string">"book"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USER_CODE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOOK_CODE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> UriMatcher matcher;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在ContentProvider 中注册URI</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://com.prsuit.myprovider/user ，则返回注册码USER_CODE</span></span><br><span class="line">        <span class="comment">// 若URI资源路径 = content://com.prsuit.myprovider/book ，则返回注册码BOOK_CODE</span></span><br><span class="line">        matcher.addURI(AUTHORITY,USER_PATH,USER_CODE);</span><br><span class="line">        matcher.addURI(AUTHORITY,BOOK_PATH,BOOK_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mContext = getContext();</span><br><span class="line">        dbHelper = <span class="keyword">new</span> DBHelper(getContext());</span><br><span class="line">        mDatabase = dbHelper.getWritableDatabase();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(@NonNull Uri uri, @Nullable ContentValues values)</span> </span>&#123;</span><br><span class="line">        matchTableName = getMatchTableName(uri);</span><br><span class="line">        <span class="keyword">long</span> row = -<span class="number">1</span>;<span class="comment">//返回值是插入数据所在的行号</span></span><br><span class="line">        row = mDatabase.insert(matchTableName,<span class="keyword">null</span>,values);</span><br><span class="line">        <span class="keyword">if</span> (row &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">            mContext.getContentResolver().notifyChange(uri,<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> ContentUris.withAppendedId(uri,row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder)</span> </span>&#123;</span><br><span class="line">        matchTableName = getMatchTableName(uri);</span><br><span class="line">        Cursor cursor = mDatabase.query(matchTableName,projection,selection,selectionArgs,<span class="keyword">null</span>,<span class="keyword">null</span>,sortOrder);</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(@NonNull Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        matchTableName = getMatchTableName(uri);</span><br><span class="line">        <span class="comment">//返回值代表此次操作影响到的行数</span></span><br><span class="line">        <span class="keyword">int</span> deleteRow = mDatabase.delete(matchTableName, selection, selectionArgs);</span><br><span class="line">        <span class="keyword">if</span> (deleteRow &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            mContext.getContentResolver().notifyChange(uri,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deleteRow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        matchTableName = getMatchTableName(uri);</span><br><span class="line">        <span class="comment">//返回值代表此次操作影响到的行数</span></span><br><span class="line">        <span class="keyword">int</span> updateRow = mDatabase.update(matchTableName, values, selection, selectionArgs);</span><br><span class="line">        <span class="keyword">if</span> (updateRow &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            mContext.getContentResolver().notifyChange(uri,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> updateRow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMatchTableName</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">        String tableName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> uriCode = matcher.match(uri);</span><br><span class="line">        <span class="keyword">switch</span> (uriCode)&#123;</span><br><span class="line">            <span class="keyword">case</span> USER_CODE:</span><br><span class="line">                tableName = DBHelper.USER_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BOOK_CODE:</span><br><span class="line">                tableName = DBHelper.BOOK_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在-AndroidManifest-中声明-provider-以及定义相关访问权限"><a href="#在-AndroidManifest-中声明-provider-以及定义相关访问权限" class="headerlink" title="在 AndroidManifest 中声明 provider 以及定义相关访问权限"></a>在 AndroidManifest 中声明 provider 以及定义相关访问权限</h5><p>在注册ContentProvider的时候通过 android:process 属性设置 provider 运行在单独的进程里，模拟进程间通信。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- MyProvider 访问权限声明 --&gt;</span><br><span class="line">  <span class="comment">// 细分读 &amp; 写权限如下，也可直接采用全权限</span></span><br><span class="line">&lt;permission android:name=<span class="string">"com.prsuit.myprovider.READ"</span> </span><br><span class="line">  android:protectionLevel=<span class="string">"normal"</span> /&gt;</span><br><span class="line">&lt;permission android:name=<span class="string">"com.prsuit.myprovider.WRITE"</span></span><br><span class="line">        android:protectionLevel=<span class="string">"normal"</span> /&gt;</span><br><span class="line"> &lt;!-- &lt;permission android:name=<span class="string">"com.prsuit.myprovider.PROVIDER"</span></span><br><span class="line">        android:protectionLevel=<span class="string">"normal"</span> /&gt; --&gt;</span><br><span class="line">          </span><br><span class="line"> &lt;!-- 声明ContentProvider --&gt;</span><br><span class="line"> &lt;application&gt;</span><br><span class="line">    &lt;provider</span><br><span class="line">            android:name=<span class="string">".contentprovider.MyContentProvider"</span></span><br><span class="line">            android:authorities=<span class="string">"com.prsuit.myprovider"</span></span><br><span class="line">            android:process=<span class="string">":provider"</span></span><br><span class="line">            <span class="comment">// 声明外界进程可访问该Provider的全权限（读 &amp; 写）</span></span><br><span class="line">            <span class="comment">//android:permission="com.prsuit.myprovider.PROVIDER"</span></span><br><span class="line">            <span class="comment">// 权限可细分为读 &amp; 写的权限</span></span><br><span class="line">            android:readPermission=<span class="string">"com.prsuit.myprovider.READ"</span></span><br><span class="line">            android:writePermission=<span class="string">"com.prsuit.myprovider.WRITE"</span></span><br><span class="line">            android:exported=<span class="string">"true"</span> <span class="comment">//表明是否允许其他应用调用ContentProvider，true表示支持，false表示不支持</span></span><br><span class="line">            /&gt;</span><br><span class="line"> &lt;/application</span><br></pre></td></tr></table></figure>

<p>在其他应用要访问 MyContentProvider，需要在AndroidManifest中声明相应权限才可进行相应操作，否则会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 其他应用声明ContentProvider所需权限 --&gt; </span><br><span class="line">&lt;uses-permission android:name=<span class="string">"com.prsuit.myprovider.READ"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"com.prsuit.myprovider.WRITE"</span> /&gt;</span><br><span class="line">  <span class="comment">//采用全权限</span></span><br><span class="line">&lt;!--&lt;uses-permission android:name=<span class="string">"com.prsuit.myprovider.PROVIDER"</span> /&gt; --&gt;</span><br></pre></td></tr></table></figure>

<h5 id="通过ContentResolver根据URI进行增删改查"><a href="#通过ContentResolver根据URI进行增删改查" class="headerlink" title="通过ContentResolver根据URI进行增删改查"></a>通过ContentResolver根据URI进行增删改查</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentProviderActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">"com.prsuit.myprovider"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri USER_URI = Uri.parse(<span class="string">"content://"</span> + AUTHORITY + <span class="string">"/user"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startAct</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        context.startActivity(<span class="keyword">new</span> Intent(context, ContentProviderActivity<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_content_provider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertValue</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        ContentValues contentValues1 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        contentValues1.put(<span class="string">"id"</span>,<span class="number">0</span>);</span><br><span class="line">        contentValues1.put(<span class="string">"name"</span>,<span class="string">"kobe"</span>);</span><br><span class="line">        Uri insert1 = getContentResolver().insert(USER_URI, contentValues1);</span><br><span class="line">        System.out.println(<span class="string">"--insertValue1--&gt;"</span>+insert1.toString());</span><br><span class="line"></span><br><span class="line">        ContentValues contentValues2 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        contentValues2.put(<span class="string">"id"</span>,<span class="number">1</span>);</span><br><span class="line">        contentValues2.put(<span class="string">"name"</span>,<span class="string">"sh"</span>);</span><br><span class="line">        Uri insert2 = getContentResolver().insert(USER_URI,contentValues2);</span><br><span class="line">        System.out.println(<span class="string">"--insertValue2--&gt;"</span>+insert2.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateValue</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        ContentValues contentValues = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        contentValues.put(<span class="string">"id"</span>,<span class="number">1</span>);</span><br><span class="line">        contentValues.put(<span class="string">"name"</span>,<span class="string">"sh2"</span>);</span><br><span class="line">        <span class="keyword">int</span> row = getContentResolver().update(USER_URI,contentValues,<span class="string">"id = ?"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>&#125;);</span><br><span class="line">        System.out.println(<span class="string">"--updateValue--&gt;"</span>+row);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteValue</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = getContentResolver().delete(USER_URI,<span class="string">"name = ?"</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"sh2"</span>&#125;);</span><br><span class="line">        System.out.println(<span class="string">"--deleteValue--&gt;"</span>+row);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryValue</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        Cursor cursor = getContentResolver().query(USER_URI, <span class="keyword">new</span> String[]&#123;<span class="string">"id"</span>, <span class="string">"name"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext())&#123;</span><br><span class="line">            System.out.println(<span class="string">"query user："</span>+cursor.getInt(<span class="number">0</span>)+<span class="string">" "</span>+cursor.getString(cursor.getColumnIndex(<span class="string">"name"</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文基于 ContentProvider 的使用过程涉及到的相关知识点进行简单地介绍和整理，归纳总结了ContentProvider 使用步骤。</p>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/94b8582d089a" target="_blank" rel="noopener">Android四大组件——ContentProvider（基础篇）</a></p>
<p><a href="https://www.jianshu.com/p/ea8bc4aaf057" target="_blank" rel="noopener">Android：关于ContentProvider的知识都在这里了！</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 搭建博客教程</title>
    <url>/2020/07/20/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要是介绍在Mac上如何使用Hexo+GitHub搭建个人博客。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是-Hexo"><a href="#一、什么是-Hexo" class="headerlink" title="一、什么是 Hexo"></a>一、什么是 Hexo</h4><blockquote>
<p><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<a id="more"></a>

<h4 id="二、配置环境"><a href="#二、配置环境" class="headerlink" title="二、配置环境"></a>二、配置环境</h4><h5 id="申请GitHub"><a href="#申请GitHub" class="headerlink" title="申请GitHub"></a>申请GitHub</h5><p><a href="https://github.com/" target="_blank" rel="noopener">Github</a>注册账号，用作博客的远程仓库和部署服务器。</p>
<h5 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h5><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网下载</a>并安装，安装完成后可用<code>node -v</code>查看版本号。</p>
<h5 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h5><p>Mac 安装 Xcode 自带有 Git，也可去<a href="https://git-scm.com/" target="_blank" rel="noopener">官网下载</a>，安装完成后可用<code>git --version</code>查看版本号。</p>
<p>需要设置你 Github 的用户名密码和email，在命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure>

<h5 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h5><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h5 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h5><p>安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml  &#x2F;&#x2F; 配置信息，你可以在此配置大部分的参数</span><br><span class="line">├── package.json &#x2F;&#x2F; 应用程序的信息</span><br><span class="line">├── public       &#x2F;&#x2F; 执行 hexo generate 命令，输出的静态网页内容目录</span><br><span class="line">├── scaffolds    &#x2F;&#x2F; 模板文件夹。当你新建文章时，Hexo会根据scaffold来建立文件 </span><br><span class="line">├── scripts      &#x2F;&#x2F; 存放自定义 javascript 脚本</span><br><span class="line">├── source       &#x2F;&#x2F; 存放用户资源的地方</span><br><span class="line">|   ├── _drafts  &#x2F;&#x2F; 草稿文章</span><br><span class="line">|   └── _posts   &#x2F;&#x2F; 发布文章</span><br><span class="line">└── themes       &#x2F;&#x2F; 存放博客的主题，Hexo会根据主题来生成静态页面</span><br></pre></td></tr></table></figure>

<p>执行下列命令，会生成静态页面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate  <span class="comment"># 或者 hexo g</span></span><br></pre></td></tr></table></figure>

<p>启动本地服务，打开浏览器输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 即可访问。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server <span class="comment"># 或者 hexo s</span></span><br></pre></td></tr></table></figure>

<h4 id="三、部署到Github"><a href="#三、部署到Github" class="headerlink" title="三、部署到Github"></a>三、部署到Github</h4><h5 id="配置-SSH-Key，将本地目录与-Github-关联"><a href="#配置-SSH-Key，将本地目录与-Github-关联" class="headerlink" title="配置 SSH Key，将本地目录与 Github 关联"></a>配置 SSH Key，将本地目录与 Github 关联</h5><p>配置SSH Key是让本地 git 项目与远程仓库建立联系。SSH Keys不配置的话每次项目有改动提交的时候就要手动输入账号密码，配置了就不需要了。</p>
<p>首先检查是否已经有SSH Key，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure>

<p>如果没有目录.ssh，则要生成一个新的SSH Key，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your e-mail"</span></span><br></pre></td></tr></table></figure>

<p>接下来几步都直接按回车键，然后系统会要你输入密码。这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。</p>
<p>成功后进入到.shh文件夹中再输入ls，查看是否有id_rsa.pub文件，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>打开id_rsa.pub文件，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>复制SSH Key后，登录GitHub账号，在Setting-&gt;SSH keys-&gt;add SSH key，将其添加到Add SSH Key里。</p>
<h5 id="测试-SSH-Key-是否配置成功"><a href="#测试-SSH-Key-是否配置成功" class="headerlink" title="测试 SSH Key 是否配置成功"></a>测试 SSH Key 是否配置成功</h5><p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>如配置了密码则要输入密码，输完按回车。如果显示以下内容，则说明Github中的 ssh 配置成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hi username! You have successfully authenticated, but GitHub does not</span><br><span class="line">provide shell access.</span><br></pre></td></tr></table></figure>

<h5 id="创建仓库-Github-Pages"><a href="#创建仓库-Github-Pages" class="headerlink" title="创建仓库 Github Pages"></a>创建仓库 Github Pages</h5><p>登录GitHub账号后，新建 New repository，建立与你github用户名对应的仓库，名称必须为username.github.io，如prsuit.github.io。</p>
<h5 id="修改Hexo的-config-yml文件"><a href="#修改Hexo的-config-yml文件" class="headerlink" title="修改Hexo的_config.yml文件"></a>修改Hexo的<code>_config.yml</code>文件</h5><p>根目录<code>_config.yml</code>是博客的配置文件，用文本编辑器打开此文件，在文件最后部分，修改deploy配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/yourname/yourname.github.io.git <span class="comment">#yourname替换成你的Github账户名</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p><strong>注意：在<code>.yml</code>文件中，冒号后面都是要带空格的。</strong></p>
<h5 id="将博客项目上传到仓库"><a href="#将博客项目上传到仓库" class="headerlink" title="将博客项目上传到仓库"></a>将博客项目上传到仓库</h5><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">$ hexo d <span class="comment">#部署到远程仓库</span></span><br><span class="line"><span class="comment"># 或者 $ hexo g -d</span></span><br></pre></td></tr></table></figure>

<p>此时，通过访问 <a href="https://yourname.github.io/" target="_blank" rel="noopener">https://yourname.github.io</a> 可以看到默认的 Hexo 首页。</p>
<p>一些常用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">"postName"</span> <span class="comment"># 新建文章</span></span><br><span class="line"></span><br><span class="line">hexo new page <span class="string">"pageName"</span> <span class="comment"># 新建页面</span></span><br><span class="line"></span><br><span class="line">hexo generate <span class="comment"># 生成静态页面至public目录，markdown转html</span></span><br><span class="line"></span><br><span class="line">hexo server <span class="comment"># 开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line"></span><br><span class="line">hexo deploy <span class="comment"># 将.deploy目录部署到GitHub</span></span><br><span class="line"></span><br><span class="line">hexo clean <span class="comment"># 清除public文件夹和db.json，清除缓存数据</span></span><br><span class="line"></span><br><span class="line">hexo <span class="built_in">help</span> <span class="comment"># 查看帮助</span></span><br><span class="line"></span><br><span class="line">hexo version <span class="comment"># 查看Hexo的版本</span></span><br><span class="line"></span><br><span class="line">hexo n == hexo new</span><br><span class="line"></span><br><span class="line">hexo g == hexo generate</span><br><span class="line"></span><br><span class="line">hexo s == hexo server</span><br><span class="line"></span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>

<h4 id="四、更换Hexo主题"><a href="#四、更换Hexo主题" class="headerlink" title="四、更换Hexo主题"></a>四、更换Hexo主题</h4><p>Hexo 中有很多主题，可以在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网</a>查看。 推荐使用<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">hexo-theme-next</a>，更换主题步骤：</p>
<h5 id="下载主题资源"><a href="#下载主题资源" class="headerlink" title="下载主题资源"></a>下载主题资源</h5><p>终端cd到初始化博客文件夹目录下，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h5 id="配置使用下载的主题"><a href="#配置使用下载的主题" class="headerlink" title="配置使用下载的主题"></a>配置使用下载的主题</h5><p>修改博客目录下<code>_config.yml</code>里的theme的名称<code>landscape</code>更改为<code>next</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<h5 id="主题的其他配置"><a href="#主题的其他配置" class="headerlink" title="主题的其他配置"></a>主题的其他配置</h5><p>可在<code>/theme/{theme}/_config.yml</code> 主题的配置文件下进行主题的配置。</p>
<h5 id="添加分类"><a href="#添加分类" class="headerlink" title="添加分类"></a>添加分类</h5><p>新建一个页面，命名为 categories，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>

<p>在 source 目录下会生成 categories 目录，修改 source/categories 目录的 index.md 如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-07-19 20:24:49</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"categories"</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>在主题<code>/theme/{theme}/_config.yml</code> 中将<code>menu</code>的<code>catagories</code>取消注释，把前面的<code>#</code>去掉即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br></pre></td></tr></table></figure>

<p>给模板添加分类属性，打开scarffolds文件夹里的post.md文件，给它的头部加上categories:，这样我们创建的所有新的文章都会自带这个属性，我们只需要往里填分类，就可以自动在网站上形成分类了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories: 分类名 <span class="comment"># 多个分类，数组形式[分类名1，分类名2]</span></span><br><span class="line"><span class="comment"># 短横线形式</span></span><br><span class="line"><span class="comment"># - 分类名1</span></span><br><span class="line"><span class="comment"># - 分类名2</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h5 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h5><p>新建一个页面，命名为 tags，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>

<p>在 source 目录下会生成 tags 目录，修改 source/tags 目录的 index.md如下 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-07-19 20:28:30</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>同样，在主题<code>/theme/{theme}/_config.yml</code> 中将<code>menu</code>的<code>tags</code>取消注释，同上。</p>
<p>以后写文章时，在要分类的文章顶部加入 tags 属性，值为标签名:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories: 分类名</span><br><span class="line">tags: [标签a,标签b] <span class="comment"># 数组形式，添加a和b两个标签</span></span><br><span class="line"><span class="comment"># 短横线形式</span></span><br><span class="line"><span class="comment"># - 标签a</span></span><br><span class="line"><span class="comment"># - 标签b</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>至此，完成以上配置，可以执行调试命令查看效果。以后就可以使用Hexo发布文章了，当然还可以添加其他配置如文章阅读统计、评论等，可自行探索。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>万事开头难，但总算开头了💔，从此开启自己的博客生涯。第一次写Blog，写作思路不是很清晰流畅，花费了比较多的时间，希望以后会越来越好，Fighting！！！</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Git入门指南</title>
    <url>/2020/07/21/Git%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要是学习和记录在工作中经常用到的一些Git命令。这里推荐几个练习和学习Git命令的网站：</p>
<blockquote>
<p><strong><a href="https://learngitbranching.js.org/?locale=zh_CN" target="_blank" rel="noopener">Learn Git Branching</a></strong>、<strong><a href="https://git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository" target="_blank" rel="noopener">《Git文档》</a></strong>、<strong><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">《廖雪峰的Git教程》</a></strong></p>
</blockquote>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、基础必读"><a href="#一、基础必读" class="headerlink" title="一、基础必读"></a>一、基础必读</h4><h5 id="Git是什么"><a href="#Git是什么" class="headerlink" title="Git是什么"></a>Git是什么</h5><blockquote>
<p>Git is a <a href="https://git-scm.com/about/free-and-open-source" target="_blank" rel="noopener">free and open source</a> distributed version control system designed to handle everything from small to very large projects with speed and efficiency. </p>
<p>Git是一个免费和开源的分布式版本控制系统，致力于高效和快速的处理任何小或者大的项目。</p>
</blockquote>
<a id="more"></a>

<h5 id="Git中的几个概念"><a href="#Git中的几个概念" class="headerlink" title="Git中的几个概念"></a>Git中的几个概念</h5><p><strong>工作区、暂存区、版本库</strong></p>
<ul>
<li>工作区：就是在电脑里能够看到的目录，存放项目的文件夹。</li>
<li>暂存区：是在版本库<code>.git</code>目录下的<code>index</code>文件，称为stage（或者叫index）的暂存区。</li>
<li>版本库：工作区有一个隐藏目录<code>.git</code>，就是Git的版本库，主要存放暂存区和分支，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</li>
</ul>
<p>三者的关系如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3mg3awoxj30cq06iaa8.jpg" alt=""></p>
<p><code>git add</code> 命令把文件修改从工作目录添加到暂存区，<code>git commit</code> 命令把暂存区的所有内容提交到版本库当前分支。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh3mizv2xbj30yg0ktgn7.jpg" alt=""><center>Git的过程</center></p>
<h5 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h5><p>如果我们想看一下工作区和暂存区文件的状态，可以使用命令 <code>git status</code>，</p>
<ul>
<li><code>Changes to be committed</code>：暂存区的文件。</li>
<li><code>Changes not staged for commit</code>：工作区的文件，还未保存到暂存区。</li>
<li><code>Untracked files</code>：指那些第一次创建，还没有加入版本更新的文件。</li>
</ul>
<p>对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。</p>
<h5 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h5><p>分支是多人协作开发中必不可少的角色，因为在我们的开发过程中，至少会有两个分支：</p>
<ul>
<li>正式版本的分支：线上代码版本保存的分支，需要稳定的运行。</li>
<li>开发主线的分支：下个版本需求的开发分支。</li>
<li>Bug分支：修复Bug的分支。</li>
</ul>
<h4 id="二、基础命令"><a href="#二、基础命令" class="headerlink" title="二、基础命令"></a>二、基础命令</h4><h5 id="暂存区相关"><a href="#暂存区相关" class="headerlink" title="暂存区相关"></a>暂存区相关</h5><h6 id="添加进暂存区"><a href="#添加进暂存区" class="headerlink" title="添加进暂存区"></a>添加进暂存区</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add .       <span class="comment"># 添加全部文件</span></span><br><span class="line">$ git add &lt;file&gt;  <span class="comment"># 添加某个文件</span></span><br></pre></td></tr></table></figure>

<h6 id="撤销工作区的修改"><a href="#撤销工作区的修改" class="headerlink" title="撤销工作区的修改"></a>撤销工作区的修改</h6><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -- &lt;file&gt;  <span class="comment"># 把工作区指定文件的修改全部撤销</span></span><br></pre></td></tr></table></figure>

<p>这里有两种情况：</p>
<p>一种是<code>file</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>file</code>已经添加到暂存区后，又作了修改，现在撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<h6 id="撤销暂存区的修改"><a href="#撤销暂存区的修改" class="headerlink" title="撤销暂存区的修改"></a>撤销暂存区的修改</h6><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD &lt;file&gt;  <span class="comment"># 把暂存区的修改撤销掉（unstage），重新放回工作区</span></span><br></pre></td></tr></table></figure>

<h5 id="版本库相关"><a href="#版本库相关" class="headerlink" title="版本库相关"></a>版本库相关</h5><h6 id="提交到版本库"><a href="#提交到版本库" class="headerlink" title="提交到版本库"></a>提交到版本库</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m &lt;message&gt;  <span class="comment"># message描述提交信息</span></span><br></pre></td></tr></table></figure>

<h6 id="撤销提交"><a href="#撤销提交" class="headerlink" title="撤销提交"></a>撤销提交</h6><p>在没有上传到远程分支时，进行版本库的撤销。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD~1  <span class="comment"># HEAD 代表当前的头结点，HEAD~n 代表当前节点的前n个节点</span></span><br></pre></td></tr></table></figure>

<h6 id="查看改动"><a href="#查看改动" class="headerlink" title="查看改动"></a>查看改动</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff HEAD -- &lt;file&gt;  <span class="comment"># 比较当前工作区和上一个版本的差异</span></span><br></pre></td></tr></table></figure>

<h6 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h6><p>直接在文件管理器中把文件删了，或者执行<code>rm</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm file  <span class="comment"># 仅从工作区删除文件</span></span><br></pre></td></tr></table></figure>

<p>在Git中删除也是一个修改操作，要想从版本库中删除文件，需执行两步。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm &lt;file&gt;  <span class="comment"># 从工作区删除文件并add到了暂存区</span></span><br><span class="line">$ git commit -m <span class="string">'remove file'</span>  <span class="comment"># 提交到版本库中</span></span><br></pre></td></tr></table></figure>

<h5 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h5><h6 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch  <span class="comment"># 查看本地所有分支，*是当前分支</span></span><br></pre></td></tr></table></figure>

<h6 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch &lt;name&gt;  <span class="comment"># name 分支名</span></span><br></pre></td></tr></table></figure>

<p>在本地创建和远程分支对应的分支，本地和远程分支的名称最好一致，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b branch-name origin/branch-name</span><br></pre></td></tr></table></figure>

<h6 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout &lt;name&gt;  <span class="comment"># 切换到name分支 或者 git switch &lt;name&gt;</span></span><br><span class="line">$ git checkout -b &lt;name&gt; <span class="comment"># 创建并切换name分支 或者 git switch -c &lt;name&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h6><p>合并保留之前的提交顺序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge &lt;name&gt;  <span class="comment"># 合并分支name到当前分支</span></span><br></pre></td></tr></table></figure>

<p>得到的提交历史更加线性，看着更加简洁。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rebase &lt;name&gt;  <span class="comment"># 合并分支name到当前分支</span></span><br></pre></td></tr></table></figure>

<h6 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d &lt;name&gt; <span class="comment"># 删除name分支</span></span><br></pre></td></tr></table></figure>

<h4 id="三、远程命令"><a href="#三、远程命令" class="headerlink" title="三、远程命令"></a>三、远程命令</h4><h5 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h5><p>远程仓库的默认名称是<code>origin</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote -v  <span class="comment"># -v 查看详细信息</span></span><br></pre></td></tr></table></figure>

<h5 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h5><h6 id="拉取最新代码"><a href="#拉取最新代码" class="headerlink" title="拉取最新代码"></a>拉取最新代码</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull &lt;origin&gt; &lt;branch-name&gt;  <span class="comment"># origin是我们远程分支的别名</span></span><br></pre></td></tr></table></figure>

<h6 id="上传代码"><a href="#上传代码" class="headerlink" title="上传代码"></a>上传代码</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push &lt;origin&gt; &lt;branch-name&gt; <span class="comment"># 推送到指定分支</span></span><br></pre></td></tr></table></figure>

<p>在上面的更新/推送命令中，默认了远程仓库的分支和当前的分支名一致，比如 <code>git push origin master</code>，本地分支名和远程分支的名称都为 <code>master</code>，如果不一致，则需要给定名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push/pull &lt;origin&gt; &lt;本地分支:远程分支&gt;</span><br></pre></td></tr></table></figure>

<h5 id="进阶命令"><a href="#进阶命令" class="headerlink" title="进阶命令"></a>进阶命令</h5><h6 id="追加更新"><a href="#追加更新" class="headerlink" title="追加更新"></a>追加更新</h6><p>更新上次 commit 的代码，避免再次生成一个 commit 记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<h6 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h6><p>建立本地分支和远程分支的关联。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream branch-name origin/branch-name</span><br></pre></td></tr></table></figure>

<h6 id="上一个版本"><a href="#上一个版本" class="headerlink" title="上一个版本"></a>上一个版本</h6><p>指定当前版本的上一个版本，比如想在 <code>master</code> 分支上一个版本的基础上对代码进行修改，我可以输入 <code>git checkout -b bugfix master^</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HEAD^</span><br><span class="line">分支^</span><br><span class="line">Hash值^</span><br></pre></td></tr></table></figure>

<h6 id="工作现场暂存和恢复"><a href="#工作现场暂存和恢复" class="headerlink" title="工作现场暂存和恢复"></a>工作现场暂存和恢复</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash  <span class="comment"># 把当前工作现场“储藏”起来，等以后恢复现场后继续工作</span></span><br><span class="line">$ git stash pop  <span class="comment"># 恢复工作现场，同时把stash内容也删了</span></span><br></pre></td></tr></table></figure>

<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场。</p>
<h6 id="复制一个特定的提交到当前分支"><a href="#复制一个特定的提交到当前分支" class="headerlink" title="复制一个特定的提交到当前分支"></a>复制一个特定的提交到当前分支</h6><p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;commit&gt;  <span class="comment"># commit 某次提交</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Git命令暂时先学习这些，掌握了这些可以胜任平时的开发，对于一些复杂的命令，使用的时候再查。</p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://juejin.im/post/5a2cdfe26fb9a0452936b07f" target="_blank" rel="noopener">《🛠Git 常用操作总结》</a><br><a href="https://juejin.im/post/5ba3aad7f265da0a8e6d801c" target="_blank" rel="noopener">《关于Android Studio使用Git的总结》</a><br><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">《廖雪峰的Git教程》</a></p>
<p><a href="https://juejin.im/post/5f0281aaf265da230f2838ba#heading-30" target="_blank" rel="noopener">《团队协作Git入门指南》</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>BroadcastReceiver必备基础</title>
    <url>/2020/07/27/BroadcastReceiver%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android的四大组件之一的BroadcastReceiver。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是BroadcastReceiver"><a href="#一、什么是BroadcastReceiver" class="headerlink" title="一、什么是BroadcastReceiver"></a>一、什么是BroadcastReceiver</h4><p>广播是一种广泛运用的在应用程序之间传输信息的机制，<strong>BroadcastReceiver</strong> 主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。广播机制是一个典型的发布-订阅模式，就是观察者模式。</p>
<a id="more"></a>

<h4 id="二、广播的种类"><a href="#二、广播的种类" class="headerlink" title="二、广播的种类"></a>二、广播的种类</h4><h5 id="普通广播-Normal-Broadcast"><a href="#普通广播-Normal-Broadcast" class="headerlink" title="普通广播(Normal Broadcast)"></a>普通广播(Normal Broadcast)</h5><p>普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。同级别接收是先后是随机的；级别低的收到广播；消息传递的效率比较高，并且无法中断广播的传播。</p>
<h5 id="有序广播-Ordered-Broadcast"><a href="#有序广播-Ordered-Broadcast" class="headerlink" title="有序广播(Ordered Broadcast)"></a>有序广播(Ordered Broadcast)</h5><p>有序广播是一种同步执行的广播。在有序广播发出之后同一时刻只会有一个广播接收器能收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传播。</p>
<p>所有的广播接收器按照优先级顺序依次执行，优先级高的先执行，低的后执行。广播接收器的优先级通过清单文件中 receiver 标签下 <code>intent-filter</code> 中的 <code>android:priority</code> 属性来设置，数值越大优先级越高，数值越小优先级越低。</p>
<p>在广播传递的过程中可对广播进行中断操作，通过在 onReceiver() 方法中调用 abortBroadcast() 方法实现，这样后面的广播接收器就无法收到广播消息了。</p>
<h5 id="本地广播-Local-Broadcast"><a href="#本地广播-Local-Broadcast" class="headerlink" title="本地广播(Local Broadcast)"></a>本地广播(Local Broadcast)</h5><p>为了解决广播的安全性问题，Android引入了本地广播机制，该机制能够在应用内部进行传递，并且广播接收器也只能接收来自本应用发出的广播，安全性高和效率高。本地广播主要是一个 LocalBroadcastManager 对广播进行管理，并提供发送跟注册广播接收器的方法。</p>
<h5 id="粘性广播-Sticky-Broadcast"><a href="#粘性广播-Sticky-Broadcast" class="headerlink" title="粘性广播(Sticky Broadcast)"></a>粘性广播(Sticky Broadcast)</h5><p>指广播在发出后，还会保存在 AMS 中，在广播发出之后注册的广播接收器也能收到之前发送的该广播，该广播在 Android 5.0 被废弃。</p>
<h4 id="三、广播的使用"><a href="#三、广播的使用" class="headerlink" title="三、广播的使用"></a>三、广播的使用</h4><h5 id="创建BroadcastReceiver"><a href="#创建BroadcastReceiver" class="headerlink" title="创建BroadcastReceiver"></a>创建BroadcastReceiver</h5><p>需要继承 BroadcastReceiver 基类，并重写 onReceive() 方法来接收消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承BroadcastReceivre基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 复写onReceive()方法</span></span><br><span class="line">  <span class="comment">// 接收到广播后，则自动调用该方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//写入接收广播后的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注册BroadcastReceiver"><a href="#注册BroadcastReceiver" class="headerlink" title="注册BroadcastReceiver"></a>注册BroadcastReceiver</h5><ul>
<li><p><strong>静态注册</strong></p>
<p>在 AndroidManifest.xml 里通过 <code>&lt;receiver&gt;</code> 标签声明，并在标签内用 <code>&lt;intent-filter&gt;</code> 标签设置过滤器。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;application&gt;</span><br><span class="line"> &lt;receiver </span><br><span class="line">    <span class="comment">//是否可以被系统实例化</span></span><br><span class="line">    android:enabled=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">   <span class="comment">//此broadcastReceiver能否接收其他App的发出的广播</span></span><br><span class="line">   <span class="comment">//默认值是由receiver中有无intent-filter决定的：如果有intent-filter，默认值为true，否则为false</span></span><br><span class="line">    android:exported=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:icon=<span class="string">"drawable resource"</span></span><br><span class="line">    android:label=<span class="string">"string resource"</span></span><br><span class="line">   <span class="comment">//继承BroadcastReceiver子类的类名</span></span><br><span class="line">    android:name=<span class="string">".CustomBroadcastReceiver"</span></span><br><span class="line"> <span class="comment">//具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收；</span></span><br><span class="line">    android:permission=<span class="string">"string"</span></span><br><span class="line"><span class="comment">//BroadcastReceiver运行所处的进程</span></span><br><span class="line"><span class="comment">//默认为app的进程，可以指定独立的进程</span></span><br><span class="line"><span class="comment">//注：Android四大基本组件都可以通过此属性指定自己的独立进程</span></span><br><span class="line">    android:process=<span class="string">"string"</span> &gt;</span><br><span class="line"><span class="comment">//用于指定此广播接收器将接收的广播类型</span></span><br><span class="line">  &lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=<span class="string">"com.sample.custom.actionName"</span> /&gt;</span><br><span class="line">  &lt;/intent-filter&gt;</span><br><span class="line"> &lt;/receiver&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态注册</strong></p>
<p>在代码中调用<code>Context.registerReceiver()</code>方法注册，<code>unregisterReceiver()</code> 方法取消注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择在Activity生命周期方法中的onResume()中注册</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onResume();</span><br><span class="line">    <span class="comment">// 1. 实例化BroadcastReceiver子类 &amp;  IntentFilter</span></span><br><span class="line">     mBroadcastReceiver mBroadcastReceiver = <span class="keyword">new</span> CustomBroadcastReceiver();</span><br><span class="line">     IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    <span class="comment">// 2. 设置接收广播的类型</span></span><br><span class="line">    intentFilter.addAction(<span class="string">"CustomActionName"</span>);</span><br><span class="line">    <span class="comment">// 3. 动态注册：调用Context的registerReceiver（）方法</span></span><br><span class="line">     registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册广播后，要在相应位置记得销毁广播</span></span><br><span class="line"><span class="comment">// 即在onPause() 中unregisterReceiver(mBroadcastReceiver)</span></span><br><span class="line"><span class="comment">// 当此Activity销毁前，onPause方法一定会执行，所以在此方法中取消注册。</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onPause();</span><br><span class="line">      <span class="comment">//销毁在onResume()方法中的广播</span></span><br><span class="line">     unregisterReceiver(mBroadcastReceiver);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:red">两者区别：</span></p>
<p><strong>静态注册</strong>：常驻型，不受组件生命周期影响。静态注册是在应用安装的时候由系统 PMS（PackageManagerService）完成整个注册过程。</p>
<p><strong>动态注册</strong>：非常驻型，广播接收器跟随组件的生命周期变化，有注册就必然得有注销，否则会导致<strong>内存泄露</strong>。对 Activity 最好在 <code>onResume()</code> 注册，在 <code>onPause()</code> 注销。如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。动态注册由 ContextImpl 来实现的，会调到 AMS.registerReceiver() 注册。</p>
<p>当广播接收者通过 intent 启动一个 activity 或者 service 时，如果 intent 中无法匹配到相应的组件，动态注册的广播接收者将会导致应用报错，而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。</p>
</li>
</ul>
<h5 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h5><p><strong>发送普通广播</strong>：定义广播所具备的“意图 (<code>Intent</code>) ”，使用 <strong>Context.sendBroadcast()</strong> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line"><span class="comment">//对应BroadcastReceiver中intentFilter的action</span></span><br><span class="line">intent.setAction(BROADCAST_ACTION);</span><br><span class="line"><span class="comment">//适配7.0及以上静态注册的广播收不到，静态注册需发送显式广播，即给intent指定包名。若是动态注册的则不需要</span></span><br><span class="line"><span class="comment">//intent.setComponent(new ComponentName(getPackageName(),getPackageName()+".CustomBroadcastReceiver"));</span></span><br><span class="line"><span class="comment">//发送广播</span></span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<p><strong>发送有序广播</strong>：<strong>Context.sendOrderedBroadcast()</strong>，该方法接收两个参数，Intent &amp; 权限相关的字符串，无特殊要求可置为null。</p>
<p><strong>发送本地广播</strong>：使用 <strong>LocalBroadcastManager</strong> 类的 sendBroadcast()、registerReceiver()、unregisterReceiver()等方法，用于应用内部传递消息。对于LocalBroadcastManager方式发送的应用内广播，只能通过LocalBroadcastManager动态注册，不能静态注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册应用内广播接收器</span></span><br><span class="line"><span class="comment">//步骤1：实例化BroadcastReceiver子类 &amp; IntentFilter mBroadcastReceiver </span></span><br><span class="line">mBroadcastReceiver = <span class="keyword">new</span> CustomBroadcastReceiver(); </span><br><span class="line">IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter(); </span><br><span class="line"><span class="comment">//步骤2：实例化LocalBroadcastManager的实例</span></span><br><span class="line">localBroadcastManager = LocalBroadcastManager.getInstance(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//步骤3：设置接收广播的类型 </span></span><br><span class="line">intentFilter.addAction(BROADCAST_ACTION);</span><br><span class="line"><span class="comment">//步骤4：调用LocalBroadcastManager单一实例的registerReceiver（）方法进行动态注册 </span></span><br><span class="line">localBroadcastManager.registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line"><span class="comment">//取消注册应用内广播接收器</span></span><br><span class="line">localBroadcastManager.unregisterReceiver(mBroadcastReceiver);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送应用内广播</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(BROADCAST_ACTION);</span><br><span class="line"><span class="comment">//适配7.0及以上静态注册的广播收不到，静态注册需发送显式广播，即给intent指定包名。若是动态注册的则不需要</span></span><br><span class="line"><span class="comment">//intent.setComponent(new ComponentName(getPackageName(),getPackageName()+".CustomBroadcastReceiver"));</span></span><br><span class="line">localBroadcastManager.sendBroadcast(intent);</span><br></pre></td></tr></table></figure>

<h4 id="四、广播发送和接收原理"><a href="#四、广播发送和接收原理" class="headerlink" title="四、广播发送和接收原理"></a>四、广播发送和接收原理</h4><p>广播队列传送广播给 Receiver 的原理其实就是将 BroadcastReceiver 和消息都放到 BroadcastRecord 里面,然后通过 Handler 机制遍历 BroadcastQueue 里面的 BroadcastRecord，将消息发送给 BroadcastReceiver。详细细节可参考：<a href="https://www.jianshu.com/p/02085150339c" target="_blank" rel="noopener">广播的底层实现原理</a></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghb614kgilj30ng07edg2.jpg" alt=""></p>
<p>整个广播的机制可以总结成下面这张图:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghb5zyxep8j30g00aqaa4.jpg" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>使用注意</strong>：</p>
<p> 当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过 action 匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，运行在 <code>UI</code> 线程，执行其中的 onReceiver() 方法，这个实例的生命周期只有10秒，10秒内没有执行结束 onReceiver() 系统将会导致 ANR ；<br>    在 onReceiver() 执行完毕之后，该实例将会被销毁，所以不要在 onReceiver() 中执行耗时操作，也不要在里面创建子线程处理业务（可能子线程没处理完，接收者就被回收了，子线程也会跟着被回收掉）；正确的处理方法就是通过 intent 调用 Activity 或者 Service 处理业务。</p>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://blog.csdn.net/xubinjie517/article/details/90239812#Sticky_Broadcast_38" target="_blank" rel="noopener">Android开发之BroadcastReceiver</a></p>
<p><a href="https://www.jianshu.com/p/ca3d87a4cdf3" target="_blank" rel="noopener">BroadcastReceiver史上最全面解析</a></p>
<p><a href="https://www.jianshu.com/p/02085150339c" target="_blank" rel="noopener">广播的底层实现原理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Fragment必备基础</title>
    <url>/2020/07/31/Fragment%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android常用的组件之一的Fragment。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是Fragment"><a href="#一、什么是Fragment" class="headerlink" title="一、什么是Fragment"></a>一、什么是Fragment</h4><p>Fragment，简称碎片，是 Android最基本，最重要的基础概念之一。Fragment 官方的定义是：</p>
<blockquote>
<p>A Fragment represents a behavior or a portion of user interface in an Activity. You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activities. You can think of a fragment as a modular section of an activity, which has its own lifecycle, receives its own input events, and which you can add or remove while the activity is running.</p>
</blockquote>
<a id="more"></a>

<ul>
<li>Fragment 是依赖于 Activity 的，不能独立存在的。</li>
<li>一个 Activity 里可以有多个 Fragment 。</li>
<li>一个 Fragment 可以被多个 Activity 重用。</li>
<li>Fragment 有自己的生命周期，并能接收输入事件。</li>
<li>我们能在 Activity 运行时动态地添加或删除 Fragment 。</li>
</ul>
<p><strong>Fragment 的优势有以下几点：</strong></p>
<ul>
<li><strong>模块化(Modularity)</strong>：我们不必把所有代码全部写在Activity中，而是把代码写在各自的Fragment中。</li>
<li><strong>可重用(Reusability)</strong>：多个Activity可以重用一个Fragment。</li>
<li><strong>可适配(Adaptability)</strong>：根据硬件的屏幕尺寸、屏幕方向，能够方便地实现不同的布局，这样用户体验更好。</li>
</ul>
<p><strong>Fragment核心的类有：</strong></p>
<ul>
<li><strong>Fragment</strong>：Fragment 的基类，任何创建的 Fragment 都需要继承该类。</li>
<li><strong>FragmentManager</strong>：管理和维护 Fragment。它是抽象类，具体的实现类是 <strong>FragmentManagerImpl</strong>。</li>
<li><strong>FragmentTransaction</strong>：对 Fragment 的添加、删除等操作都需要通过事务方式进行。它是抽象类，具体的实现类是 <strong>BackStackRecord</strong>。</li>
</ul>
<h4 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h4><p>Fragment的生命周期和Activity类似，但比Activity的生命周期复杂一些，基本的生命周期方法如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghguz2jnu5j30b409uq34.jpg" alt=""></p>
<ul>
<li><strong>onAttach</strong>：Fragment 和 Activity 相关联时调用。可以通过该方法获取 Activity 引用，还可以通过getArguments() 获取参数。</li>
<li><strong>onCreate</strong>：Fragment 被创建时调用。</li>
<li><strong>onCreateView</strong>：创建 Fragment 的布局。</li>
<li><strong>onActivityCreated</strong>：当 Activity 完成 onCreate() 时调用，在 onCreateView() 方法之后调用该方法。</li>
<li><strong>onStart</strong>：当 Fragment 开始可见时调用，此时还不可交互。</li>
<li><strong>onResume</strong>：当 Fragment 可见且可交互时调用。</li>
<li><strong>onPause</strong>：当 Fragment 不可交互但可见时调用，表明用户将要离开当前 Fragment 。</li>
<li><strong>onStop</strong>：当 Fragment 不可见时调用，Fragment 被停止。</li>
<li><strong>onDestroyView</strong>：当 Fragment 的 UI 从视图结构中移除时调用，销毁与 Fragment 有关的视图。</li>
<li><strong>onDestroy</strong>：销毁 Fragment 时调用。</li>
<li><strong>onDetach</strong>：当 Fragment 和 Activity 解除关联时调用。</li>
</ul>
<p>当一个 fragment 被创建的时候，需调用以下生命周期方法：onAttach(), onCreate(), onCreateView(), onActivityCreated()；</p>
<p>当这个 fragment 对用户可见可交互的时候，需调用：onStart() ,onResume()；</p>
<p>当这个 fragment 对用户不可交互不可见，进入后台模式需调用：onPause(),onStop()；</p>
<p>当这个 fragment 被销毁或者是持有它的 Activity 被销毁了，调用：onPause() ,onStop(), onDestroyView(), onDestroy(),onDetach()。</p>
<p>因为 Fragment 是依赖 Activity 的，Fragment 和 Activity 的生命周期方法有密切的关系和顺序，如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghgwq0ptw2j30hs0l4jsp.jpg" alt=""></p>
<p>举例来理解Fragment生命周期方法，共有两个Fragment：F1和F2，F1在初始化时就加入Activity，点击F1中的按钮调用replace替换为F2。</p>
<p>当F1在Activity的<code>onCreate()</code>中被添加时，日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BasicActivity: [onCreate] BEGIN</span><br><span class="line">BasicActivity: [onCreate] END</span><br><span class="line">BasicActivity: [onStart] BEGIN</span><br><span class="line">Fragment1: [onAttach] BEGIN </span><br><span class="line">Fragment1: [onAttach] END</span><br><span class="line">BasicActivity: [onAttachFragment] BEGIN</span><br><span class="line">BasicActivity: [onAttachFragment] END</span><br><span class="line">Fragment1: [onCreate] BEGIN</span><br><span class="line">Fragment1: [onCreate] END</span><br><span class="line">Fragment1: [onCreateView]</span><br><span class="line">Fragment1: [onViewCreated] BEGIN</span><br><span class="line">Fragment1: [onViewCreated] END</span><br><span class="line">Fragment1: [onActivityCreated] BEGIN</span><br><span class="line">Fragment1: [onActivityCreated] END</span><br><span class="line">Fragment1: [onStart] BEGIN</span><br><span class="line">Fragment1: [onStart] END</span><br><span class="line">BasicActivity: [onStart] END</span><br><span class="line">BasicActivity: [onPostCreate] BEGIN</span><br><span class="line">BasicActivity: [onPostCreate] END</span><br><span class="line">BasicActivity: [onResume] BEGIN</span><br><span class="line">BasicActivity: [onResume] END</span><br><span class="line">BasicActivity: [onPostResume] BEGIN</span><br><span class="line">Fragment1: [onResume] BEGIN</span><br><span class="line">Fragment1: [onResume] END</span><br><span class="line">BasicActivity: [onPostResume] END</span><br><span class="line">BasicActivity: [onAttachedToWindow] BEGIN</span><br><span class="line">BasicActivity: [onAttachedToWindow] END</span><br></pre></td></tr></table></figure>

<p>从上图可以看出：</p>
<ul>
<li><p>Fragment 的 onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()都是在 Activity 的 onStart() 中调用的。</p>
</li>
<li><p>Fragment 的 onResume() 在 Activity 的 onResume() 之后调用。</p>
</li>
</ul>
<p>当点击F1的按钮，调用<code>replace()</code>替换为F2，且不加<code>addToBackStack()</code>时，日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Fragment2: [onAttach] BEGIN</span><br><span class="line">Fragment2: [onAttach] END</span><br><span class="line">BasicActivity: [onAttachFragment] BEGIN</span><br><span class="line">BasicActivity: [onAttachFragment] END</span><br><span class="line">Fragment2: [onCreate] BEGIN</span><br><span class="line">Fragment2: [onCreate] END</span><br><span class="line">Fragment1: [onPause] BEGIN</span><br><span class="line">Fragment1: [onPause] END</span><br><span class="line">Fragment1: [onStop] BEGIN</span><br><span class="line">Fragment1: [onStop] END</span><br><span class="line">Fragment1: [onDestroyView] BEGIN</span><br><span class="line">Fragment1: [onDestroyView] END</span><br><span class="line">Fragment1: [onDestroy] BEGIN</span><br><span class="line">Fragment1: [onDestroy] END</span><br><span class="line">Fragment1: [onDetach] BEGIN</span><br><span class="line">Fragment1: [onDetach] END</span><br><span class="line">Fragment2: [onCreateView]</span><br><span class="line">Fragment2: [onViewCreated] BEGIN</span><br><span class="line">Fragment2: [onViewCreated] END</span><br><span class="line">Fragment2: [onActivityCreated] BEGIN</span><br><span class="line">Fragment2: [onActivityCreated] END</span><br><span class="line">Fragment2: [onStart] BEGIN</span><br><span class="line">Fragment2: [onStart] END</span><br><span class="line">Fragment2: [onResume] BEGIN</span><br><span class="line">Fragment2: [onResume] END</span><br></pre></td></tr></table></figure>

<p>可以看到，F1最后调用了<code>onDestroy()</code>和<code>onDetach()</code>。</p>
<p>当点击F1的按钮，调用<code>replace()</code>替换为F2，且加<code>addToBackStack()</code>时，日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Fragment2: [onAttach] BEGIN</span><br><span class="line">Fragment2: [onAttach] END</span><br><span class="line">BasicActivity: [onAttachFragment] BEGIN</span><br><span class="line">BasicActivity: [onAttachFragment] END</span><br><span class="line">Fragment2: [onCreate] BEGIN</span><br><span class="line">Fragment2: [onCreate] END</span><br><span class="line">Fragment1: [onPause] BEGIN</span><br><span class="line">Fragment1: [onPause] END</span><br><span class="line">Fragment1: [onStop] BEGIN</span><br><span class="line">Fragment1: [onStop] END</span><br><span class="line">Fragment1: [onDestroyView] BEGIN</span><br><span class="line">Fragment1: [onDestroyView] END</span><br><span class="line">Fragment2: [onCreateView]</span><br><span class="line">Fragment2: [onViewCreated] BEGIN</span><br><span class="line">Fragment2: [onViewCreated] END</span><br><span class="line">Fragment2: [onActivityCreated] BEGIN</span><br><span class="line">Fragment2: [onActivityCreated] END</span><br><span class="line">Fragment2: [onStart] BEGIN</span><br><span class="line">Fragment2: [onStart] END</span><br><span class="line">Fragment2: [onResume] BEGIN</span><br><span class="line">Fragment2: [onResume] END</span><br></pre></td></tr></table></figure>

<p>可以看到，F1被替换时，最后只调到了<code>onDestroyView()</code>，并没有调用<code>onDestroy()</code>和<code>onDetach()</code>。当用户点返回按钮回退事务时，F1会调 onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume()，因此在 Fragment 事务中加不加<code>addToBackStack()</code>会影响 Fragment 的生命周期。</p>
<p>FragmentTransaction 有一些基本方法，下面给出调用这些方法时，Fragment 生命周期的变化：</p>
<ul>
<li>add(): onAttach()-&gt;…-&gt;onResume()。</li>
<li>remove(): onPause()-&gt;…-&gt;onDetach()。</li>
<li>replace(): 相当于旧 Fragment 调用remove()，新 Fragment 调用add()。</li>
<li>show(): 不调用任何生命周期方法，调用该方法的前提是要显示的 Fragment 已经被添加到容器，只是纯粹把 Fragment UI 的 setVisibility 为 true。</li>
<li>hide(): 不调用任何生命周期方法，调用该方法的前提是要显示的 Fragment 已经被添加到容器，只是纯粹把Fragment UI的setVisibility为false。</li>
<li>detach(): onPause()-&gt;onStop()-&gt;onDestroyView()。UI从布局中移除，但是仍然被 FragmentManager 管理。</li>
<li>attach(): onCreateView()-&gt;onStart()-&gt;onResume()。</li>
</ul>
<h4 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h4><h5 id="创建-Fragment"><a href="#创建-Fragment" class="headerlink" title="创建 Fragment"></a>创建 Fragment</h5><p>首先创建继承 Fragment 的类，名为Fragment1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment1</span> <span class="keyword">extends</span> <span class="title">Fragment</span></span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String ARG_PARAM = <span class="string">"param_key"</span>; </span><br><span class="line">     <span class="keyword">private</span> String mParam; </span><br><span class="line">     <span class="keyword">private</span> Activity mActivity; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mActivity = (Activity) context;</span><br><span class="line">        mParam = getArguments().getString(ARG_PARAM);  <span class="comment">//获取参数</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View root = inflater.inflate(R.layout.fragment_1, container, <span class="keyword">false</span>);</span><br><span class="line">        TextView view = root.findViewById(R.id.text);</span><br><span class="line">        view.setText(mParam);</span><br><span class="line">             <span class="keyword">return</span> root;</span><br><span class="line">    &#125;    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fragment1 <span class="title">newInstance</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Fragment1 frag = <span class="keyword">new</span> Fragment1();</span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.putString(ARG_PARAM, str);</span><br><span class="line">        fragment.setArguments(bundle);   <span class="comment">//设置参数</span></span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fragment 有很多可以复写的方法，其中最常用的就是<code>onCreateView()</code>，该方法返回 Fragment 的UI布局，需要注意的是<code>inflate()</code>的第三个参数是 <strong>false</strong> ，因为在 Fragment 内部实现中，会把该布局添加到 container 中，如果设为 true，那么就会重复做两次添加，则会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: The specified child already has a parent. <span class="function">You must call <span class="title">removeView</span><span class="params">()</span> on the child's parent first.</span></span><br></pre></td></tr></table></figure>

<p>如果在创建Fragment时要传入参数，必须要通过<code>setArguments(Bundle bundle)</code>方式添加，而不建议通过为Fragment 添加带参数的构造函数，因为通过<code>setArguments()</code>方式添加，在由于内存紧张导致Fragment被系统杀掉并恢复（re-instantiate）时能保留这些数据。官方建议如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">It is strongly recommended that subclasses <span class="keyword">do</span> not have other constructors with parameters, since these constructors will not be called when the fragment is re-instantiated.</span><br></pre></td></tr></table></figure>

<p>我们可以在 Fragment 的<code>onAttach()</code>中通过<code>getArguments()</code>获得传进来的参数，并在之后使用这些参数。如果要获取 Activity 对象，不建议调用<code>getActivity()</code>，而是在<code>onAttach()</code>中将 Context 对象强转为 Activity 对象。</p>
<h5 id="添加Fragment到Activity"><a href="#添加Fragment到Activity" class="headerlink" title="添加Fragment到Activity"></a>添加Fragment到Activity</h5><ul>
<li><p><strong>静态添加</strong>：通过 <code>&lt;fragment&gt;</code> 标签的形式添加到 Activity 的布局 xml 当中，缺点是一旦添加就不能在运行时删除。</p>
</li>
<li><p><strong>动态添加</strong>：通过 java 代码将 fragment 添加到宿主 Activity 中，这种方式比较灵活，常用这种方式。</p>
</li>
</ul>
<p>这里只给出动态添加的方式。首先Activity需要有一个容器存放 Fragment ，一般是 FrameLayout，因此在Activity 的布局文件中加入 FrameLayout：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;FrameLayout</span><br><span class="line">    android:id=<span class="string">"@+id/container"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>然后在<code>onCreate()</code>中，通过以下代码将 Fragment 添加进 Activity 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bundle == <span class="keyword">null</span>) &#123;</span><br><span class="line">    getSupportFragmentManager().beginTransaction()</span><br><span class="line">        .add(R.id.container, Fragment1.newInstance(<span class="string">"hello world"</span>),<span class="string">"f1"</span>)</span><br><span class="line">      <span class="comment">//.addToBackStack("fname")</span></span><br><span class="line">        .commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意几点：</p>
<ul>
<li>使用<code>getSupportFragmentManager()</code>获取 FragmentManager。</li>
<li><code>add()</code>是对 Fragment 众多操作中的一种，还有<code>remove()</code>, <code>replace()</code>等，第一个参数是根容器的id（FrameLayout的id，即”@id/container”），第二个参数是 Fragment 对象，第三个参数是 fragment 的 tag 名，指定 tag 的好处是后续我们可以通过<code>Fragment1 frag = getSupportFragmentManager().findFragmentByTag(&quot;f1&quot;)</code>从 FragmentManager 中查找 Fragment 对象。</li>
<li>在一次事务中，可以做多个操作，比如同时做<code>add().remove().replace()</code>。</li>
<li><code>commit()</code>操作是异步的，内部通过<code>mManager.enqueueAction()</code>加入处理队列。对应的同步方法为<code>commitNow()</code>，<code>commit()</code>内部会有<code>checkStateLoss()</code>操作，如果开发人员使用不当（比如<code>commit()</code>操作在<code>onSaveInstanceState()</code>之后），可能会抛出异常，而<code>commitAllowingStateLoss()</code>方法则是不会抛出异常版本的<code>commit()</code>方法，但是尽量使用<code>commit()</code>，而不要使用<code>commitAllowingStateLoss()</code>。</li>
<li><code>addToBackStack(&quot;fname&quot;)</code>是可选的。FragmentManager 拥有回退栈（BackStack），类似于 Activity 的任务栈，如果添加了该语句，就把该事务加入回退栈，当用户点击返回按钮，会回退该事务（回退指的是如果事务是<code>add(frag1)</code>，那么回退操作就是<code>remove(frag1)</code>）；如果没添加该语句，用户点击返回按钮会直接销毁Activity。</li>
<li>Fragment 有一个常见的问题，即 Fragment 重叠问题，这是由于 Fragment 被系统杀掉，并重新初始化时再次将 fragment 加入 activity，因此通过在外围加 if 语句能判断此时是否是被系统杀掉并重新初始化的情况。</li>
</ul>
<p><strong>Fragment有个常见的异常：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalStateException: Can not perform <span class="keyword">this</span> action after onSaveInstanceState</span><br><span class="line">    at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:<span class="number">1341</span>)</span><br><span class="line">    at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:<span class="number">1352</span>)</span><br><span class="line">    at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:<span class="number">595</span>)</span><br><span class="line">    at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:<span class="number">574</span>)</span><br></pre></td></tr></table></figure>

<p>该异常出现的原因是：commit() 在 onSaveInstanceState() 后调用。首先，onSaveInstanceState() 是在 Activity 有可能被系统回收的异常终止情况下，而且是在 onPause() 之后，onStop() 之前调用。onRestoreInstanceState() 在onStart() 之后，onResume() 之前。</p>
<p><strong>因此避免出现该异常的方案有：</strong></p>
<ul>
<li>不要把 Fragment 事务放在异步线程的回调中，比如不要把 Fragment 事务放在 AsyncTask 的onPostExecute()，因此 onPostExecute() 可能会在 onSaveInstanceState() 之后执行。</li>
<li>逼不得已时使用 commitAllowingStateLoss()。</li>
</ul>
<h4 id="四、Fragment实现原理和Back-Stack"><a href="#四、Fragment实现原理和Back-Stack" class="headerlink" title="四、Fragment实现原理和Back Stack"></a>四、Fragment实现原理和Back Stack</h4><p>我们知道 Activity 有任务栈，用户通过 startActivity 将 Activity 加入栈，点击返回按钮将 Activity 出栈。Fragment 也有类似的栈，称为回退栈（Back Stack），回退栈是由 FragmentManager 管理的。默认情况下，Fragment 事务是不会加入回退栈的，如果想将 Fragment 事务加入回退栈，则可以加入<code>addToBackStack(&quot;&quot;)</code>。如果没有加入回退栈，则用户点击返回按钮会直接将 Activity 出栈；如果加入了回退栈，则用户点击返回按钮会回滚 Fragment 事务。</p>
<p>我们将通过最常见的 Fragment 用法，讲解 Back Stack 的实现原理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getSupportFragmentManager().beginTransaction()</span><br><span class="line">    .add(R.id.container, f1, <span class="string">"f1"</span>)</span><br><span class="line">    .addToBackStack(<span class="string">""</span>)</span><br><span class="line">    .commit();</span><br></pre></td></tr></table></figure>

<p>上面这个代码的功能就是将 Fragment 加入 Activity 中，内部实现为：创建一个 BackStackRecord 对象，该对象记录了这个事务的全部操作轨迹（这里只做了一次 add 操作，并且加入回退栈），随后将该对象提交到 FragmentManager 的执行队列中，等待执行。</p>
<p>BackStackRecord 类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//androidx之前</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BackStackRecord</span> <span class="keyword">extends</span> <span class="title">FragmentTransaction</span> <span class="keyword">implements</span> <span class="title">FragmentManager</span>.<span class="title">BackStackEntry</span>, <span class="title">Runnable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// androidx之后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BackStackRecord</span> <span class="keyword">extends</span> <span class="title">FragmentTransaction</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">FragmentManager</span>.<span class="title">BackStackEntry</span>, <span class="title">FragmentManagerImpl</span>.<span class="title">OpGenerator</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>从定义可以看出，BackStackRecord 有三重含义：</p>
<ul>
<li>继承了 FragmentTransaction，即是事务，保存了整个事务的全部操作轨迹。</li>
<li>实现了 BackStackEntry，作为回退栈的元素，正是因为该类拥有事务全部的操作轨迹，因此在popBackStack() 时能回退整个事务。</li>
<li>继承了 Runnable，即被放入 FragmentManager 执行队列，等待被执行。</li>
</ul>
<p>先看第一层含义，<code>getSupportFragmentManager.beginTransaction()</code>返回的就是 BackStackRecord 对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">beginTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BackStackRecord(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>BackStackRecord 类包含了一次事务的整个操作轨迹，是以链表形式存在的，链表的元素是 Op 类，androidx 之后是保存在一个<code>ArrayList&lt;Op&gt; mOps = new ArrayList&lt;&gt;()</code>中，表示其中某个操作，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//androidx之前</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Op</span> </span>&#123;</span><br><span class="line">    Op next; <span class="comment">//链表后一个节点</span></span><br><span class="line">    Op prev; <span class="comment">//链表前一个节点</span></span><br><span class="line">    <span class="keyword">int</span> cmd;  <span class="comment">//操作是add或remove或replace或hide或show等</span></span><br><span class="line">    Fragment fragment; <span class="comment">//对哪个Fragment对象做操作</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// androidx之后</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Op</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mCmd;</span><br><span class="line">        Fragment mFragment;</span><br><span class="line">        <span class="keyword">int</span> mEnterAnim;</span><br><span class="line">        <span class="keyword">int</span> mExitAnim;</span><br><span class="line">        <span class="keyword">int</span> mPopEnterAnim;</span><br><span class="line">        <span class="keyword">int</span> mPopExitAnim;</span><br><span class="line">        Lifecycle.State mOldMaxState;</span><br><span class="line">        Lifecycle.State mCurrentMaxState;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下具体场景下这些类是怎么被使用的，比如我们的事务做add操作。add 函数的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">add</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag)</span> </span>&#123;</span><br><span class="line">   doAddOp(containerViewId, fragment, tag, OP_ADD);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>doAddOp()</code>方法就是创建 Op 对象，并加入链表，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAddOp</span><span class="params">(<span class="keyword">int</span> containerViewId, Fragment fragment, String tag, <span class="keyword">int</span> opcmd)</span> </span>&#123;</span><br><span class="line">    fragment.mTag = tag;  <span class="comment">//设置fragment的tag</span></span><br><span class="line">    fragment.mContainerId = fragment.mFragmentId = containerViewId;  <span class="comment">//设置fragment的容器id</span></span><br><span class="line">    Op op = <span class="keyword">new</span> Op();</span><br><span class="line">    op.cmd = opcmd;</span><br><span class="line">    op.fragment = fragment;</span><br><span class="line">    addOp(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addOp() 是将创建好的 Op 对象加入链表，androidx 则加到列表，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOp</span><span class="params">(Op op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mHead = mTail = op;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        op.prev = mTail;</span><br><span class="line">        mTail.next = op;</span><br><span class="line">        mTail = op;</span><br><span class="line">    &#125;</span><br><span class="line">    mNumOp++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//androidx</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">addOp</span><span class="params">(Op op)</span> </span>&#123;</span><br><span class="line">        mOps.add(op);</span><br><span class="line">        op.mEnterAnim = mEnterAnim;</span><br><span class="line">        op.mExitAnim = mExitAnim;</span><br><span class="line">        op.mPopEnterAnim = mPopEnterAnim;</span><br><span class="line">        op.mPopExitAnim = mPopExitAnim;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>addToBackStack(“”)</code>是将 mAddToBackStack 变量记为 true，在 <code>commit()</code> 中会用到该变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">addToBackStack</span><span class="params">(@Nullable String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!mAllowAddToBackStack) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                   <span class="string">"This FragmentTransaction is not allowed to be added to the back stack."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       mAddToBackStack = <span class="keyword">true</span>;</span><br><span class="line">       mName = name;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>commit()</code>是异步的，即不是立即生效的，但是后面会看到整个过程还是在主线程完成，只是把事务的执行扔给主线程的 Handler，<code>commit()</code>内部是<code>commitInternal()</code>，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">commitInternal</span><span class="params">(<span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">    mCommitted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">        mIndex = mManager.allocBackStackIndex(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mIndex = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mManager.enqueueAction(<span class="keyword">this</span>, allowStateLoss); <span class="comment">//将事务添加进待执行队列中</span></span><br><span class="line">    <span class="keyword">return</span> mIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 mAddToBackStack 为 true，则调用<code>allocBackStackIndex(this)</code>将事务添加进回退栈，FragmentManager 类的变量 mBackStackIndices 就是回退栈。实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">allocBackStackIndex</span><span class="params">(BackStackRecord bse)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBackStackIndices == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mBackStackIndices = <span class="keyword">new</span> ArrayList&lt;BackStackRecord&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = mBackStackIndices.size();</span><br><span class="line">    mBackStackIndices.add(bse);</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>commitInternal()</code>中，<code>mManager.enqueueAction(this, allowStateLoss);</code>是将 BackStackRecord 加入待执行队列中，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueAction</span><span class="params">(Runnable action, <span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPendingActions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPendingActions = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingActions.add(action);</span><br><span class="line">    <span class="keyword">if</span> (mPendingActions.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        mHost.getHandler().removeCallbacks(mExecCommit);</span><br><span class="line">        mHost.getHandler().post(mExecCommit); <span class="comment">//调用execPendingActions()执行待执行队列的事务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mPendingActions 就是前面说的待执行队列，<code>mHost.getHandler()</code>就是主线程的Handler，因此 Runnable 是在主线程执行的，mExecCommit 的内部就是调用了<code>execPendingActions()</code>，即把 mPendingActions 中所有积压的没被执行的事务全部执行。执行队列中的事务会怎样被执行呢？就是调用<code>BackStackRecord的run()</code>方法，<code>run()</code>方法就是执行 Fragment 的生命周期函数，还有将视图添加进 container 中。</p>
<p>与<code>addToBackStack()</code>对应的是<code>popBackStack()</code>，有以下几种变种：</p>
<ul>
<li>popBackStack()：将回退栈的栈顶弹出，并回退该事务。</li>
<li>popBackStack(String name, int flag)：name 为 addToBackStack(String name) 的参数，通过 name 能找到回退栈的特定元素，flag 可以为0或者 FragmentManager.POP_BACK_STACK_INCLUSIVE ，0表示只弹出该元素以上的所有元素，POP_BACK_STACK_INCLUSIVE 表示弹出包含该元素及以上的所有元素。这里说的弹出所有元素包含回退这些事务。</li>
<li>popBackStack() 是异步执行的，是丢到主线程的 MessageQueue 执行，popBackStackImmediate() 是同步版本。</li>
</ul>
<p><code>getSupportFragmentManager().findFragmentByTag()</code>是经常用到的方法，是 FragmentManager 的方法，FragmentManager是抽象类，FragmentManagerImpl 是继承 FragmentManager 的实现类，他的内部实现是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FragmentManagerImpl</span> <span class="keyword">extends</span> <span class="title">FragmentManager</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Fragment&gt; mActive;</span><br><span class="line">    ArrayList&lt;Fragment&gt; mAdded;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fragment <span class="title">findFragmentByTag</span><span class="params">(String tag)</span> </span>&#123; </span><br><span class="line">           <span class="keyword">if</span> (mAdded != <span class="keyword">null</span> &amp;&amp; tag != <span class="keyword">null</span>) &#123; </span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i=mAdded.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                Fragment f = mAdded.get(i);</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">null</span> &amp;&amp; tag.equals(f.mTag)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> f;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">          <span class="keyword">if</span> (mActive != <span class="keyword">null</span> &amp;&amp; tag != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i=mActive.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                    Fragment f = mActive.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (f != <span class="keyword">null</span> &amp;&amp; tag.equals(f.mTag)) &#123;</span><br><span class="line">                          <span class="keyword">return</span> f;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面看到，先从 mAdded 中查找是否有该 Fragment，如果没找到，再从 mActive 中查找是否有该 Fragment。mAdded 是已经添加到 Activity 的 Fragment 的集合，mActive 不仅包含 mAdded，还包含虽然不在 Activity 中，但还在回退栈中的 Fragment。</p>
<h4 id="五、Fragment通信"><a href="#五、Fragment通信" class="headerlink" title="五、Fragment通信"></a>五、Fragment通信</h4><h5 id="Fragment向Activity传递数据"><a href="#Fragment向Activity传递数据" class="headerlink" title="Fragment向Activity传递数据"></a>Fragment向Activity传递数据</h5><p>首先，在 Fragment 中定义接口，并让 Activity 实现该接口（具体实现省略）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnFragmentInteractionListener</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(String str)</span></span>;  <span class="comment">//将str从Fragment传递给Activity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Fragment 的 onAttach() 中，将参数 Context 强转为 OnFragmentInteractionListener 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onAttach(context);</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> OnFragmentInteractionListener) &#123;</span><br><span class="line">        mListener = (OnFragmentInteractionListener) context;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(context.toString()</span><br><span class="line">                + <span class="string">" must implement OnFragmentInteractionListener"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在 Fragment 合适的地方调用<code>mListener.onItemClick(&quot;hello&quot;)</code>将”hello”从 Fragment 传递给 Activity。</p>
<h5 id="Activity向Fragment传递数据"><a href="#Activity向Fragment传递数据" class="headerlink" title="Activity向Fragment传递数据"></a>Activity向Fragment传递数据</h5><p>在 Fragment 初次创建时可通过 <code>fragment.setArguments(bundle)</code> 方法传递数据，其他时候，可以获取Fragment 对象，并调用 Fragment 的方法即可，比如要将一个字符串传递给 Fragment，则在 Fragment 中定义方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setString</span><span class="params">(String str)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.str = str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在 Activity 中调用<code>fragment.setString(&quot;hello&quot;)</code>即可。</p>
<h5 id="Fragment之间通信"><a href="#Fragment之间通信" class="headerlink" title="Fragment之间通信"></a>Fragment之间通信</h5><p>由于 Fragment 之间是没有任何依赖关系的，因此如果要进行 Fragment 之间的通信，建议通过 Activity 作为中介，不要 Fragment 之间直接通信。</p>
<h4 id="六、Fragment中的onActivityResult"><a href="#六、Fragment中的onActivityResult" class="headerlink" title="六、Fragment中的onActivityResult"></a>六、Fragment中的onActivityResult</h4><p>假设有一个 FragmentActivity 中嵌套一个 Fragment，它们各自使用 startActivityForResult 发起数据请求。<br>经测，目标所返回结果数据，能否被它们各自的 onActivityResult 方法所接收的情况如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghi3kbnbqwj30ks02tjrj.jpg" alt=""></p>
<ul>
<li>Fragment 和 FragmentActivity 都能接收到自己的发起的请求所返回的结果</li>
<li>FragmentActivity 发起的请求，Fragment 完全接收不到结果</li>
<li>Fragment 发起的请求，虽然在 FragmentActivity 中能获取到结果，但是requestCode完全对应不上</li>
</ul>
<blockquote>
<p>Fragment.startActivityForResult<br>↓<br>FragmentActivitymHost.HostCallbacks.onStartActivityFromFragment<br>↓<br>FragmentActivity.startActivityFromFragment</p>
</blockquote>
<p>从 Fragment 的 <code>startActivityForResult</code> 开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mHost == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fragment "</span> + <span class="keyword">this</span> + <span class="string">" not attached to Activity"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       mHost.onStartActivityFromFragment(<span class="keyword">this</span> <span class="comment">/*fragment*/</span>, intent, requestCode, options);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>调用了一个mHost.onStartActivityFromFragment 的方法。Fragment 被添加到一个 FragmentActivity 中之后，这里的 mHost 即是当前 FragmentActivity 的一个内部类 FragmentActivity.HostCallbacks，它持有对FragmentActivity 的引用，通过调用 <code>onStartActivityFromFragment</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartActivityFromFragment</span><span class="params">(@NonNull Fragment fragment, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">           FragmentActivity.<span class="keyword">this</span>.startActivityFromFragment(fragment, intent, requestCode, options);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>转发到当前 FragmentActivity 的 <code>startActivityFromFragment</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityFromFragment</span><span class="params">(Fragment fragment, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    mStartedActivityFromFragment = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode == -<span class="number">1</span>) &#123;</span><br><span class="line">            ActivityCompat.startActivityForResult(<span class="keyword">this</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((requestCode&amp;<span class="number">0xffff0000</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can only use lower 16 bits for requestCode"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> requestIndex = allocateRequestIndex(fragment);</span><br><span class="line">        ActivityCompat.startActivityForResult(</span><br><span class="line">            <span class="keyword">this</span>, intent, ((requestIndex+<span class="number">1</span>)&lt;&lt;<span class="number">16</span>) + (requestCode&amp;<span class="number">0xffff</span>), options);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mStartedActivityFromFragment = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析一下这段代码：<br>1.<code>mStartedActivityFromFragment = true</code>首先标记一下请求是来自于 Fragment。<br>2.<code>if(requestCode == -1)</code>的内容不用管，它是来自于 startActivity（没有ForResult）的情况。<br>3.然后的代码添加了对requestCode必须小于0xffff的限制 <code>if((requestCode&amp;0xffff0000) ！= 0){/*抛异常*/}</code><br>我们是从 Fragment.startActivityForResult 追踪到这里的，所以虽然文档没有明确说，但是从这里可以看出：<strong>Fragment.startActivityForResult的requestCode也是必须要&lt;=0xffff的。</strong></p>
<p><strong>然后，下面是关键点了：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ActivityCompat.startActivityForResult(</span><br><span class="line">            <span class="keyword">this</span>, intent, ((requestIndex+<span class="number">1</span>)&lt;&lt;<span class="number">16</span>) + (requestCode&amp;<span class="number">0xffff</span>), options);</span><br></pre></td></tr></table></figure>

<p>其中ActivityCompat是一个帮助类，ActivityCompat.startActivityForResult 最终还是调用的Activity.startActivityForResult。通过分析，得知 requestIndex 是请求的序号，值为从0递增的整数值。<br>又从前面得知，requestCode 的本身的值是小于0xffff的，所以<code>((requestIndex+1)&lt;&lt;16)+(requestCode&amp;0xffff)</code>简化一下就是：<code>(requestIndex+1)*65536+requestCode</code>——<strong>所以这个值是必定大于0xffff的。</strong></p>
<p>再看一下 <code>FragmentActivity.startActivityForResult</code> 的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If this was started from a Fragment we've already checked the upper 16 bits were not in</span></span><br><span class="line">    <span class="comment">// use, and then repurposed them for the Fragment's index.</span></span><br><span class="line">    <span class="keyword">if</span> (!mStartedActivityFromFragment) &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode != -<span class="number">1</span> &amp;&amp; (requestCode&amp;<span class="number">0xffff0000</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can only use lower 16 bits for requestCode"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.startActivityForResult(intent, requestCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，判断了一下如果请求不是来自于 Fragment，也就是来自于 FragmentActivity 自身，就限制 requestCode 不能大于0xffff。</p>
<p>再加上前文所说的，Fragment.startActivityForResult 最终映射的 requestCode 值必定大于0xffff，所以，现在可以得出了一个初步的结果：<br><strong>SDK 把 Fragment 和 FragmentActivity 的 requestCode 都限制在了0xffff以内，然后对于 Fragment 所发起的请求，都通过一个映射，把最终的 requestCode 变成了一个大于0xffff的值。</strong></p>
<p>可以推测到：<strong>在获取的结果的时候，也是会通过跟0xffff这个数值来比较，来区分是要把结果交给FragmentActivity 还是 Fragment 来处理。</strong></p>
<p>再来看一下 <code>FragmentActivity.onActivityResult</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    mFragments.noteStateNotSaved();</span><br><span class="line">    <span class="keyword">int</span> requestIndex = requestCode&gt;&gt;<span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestIndex != <span class="number">0</span>) &#123;</span><br><span class="line">        requestIndex--;</span><br><span class="line">        String who = mPendingFragmentActivityResults.get(requestIndex);</span><br><span class="line">        mPendingFragmentActivityResults.remove(requestIndex);</span><br><span class="line">        <span class="keyword">if</span> (who == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Activity result delivered for unknown Fragment."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Fragment targetFragment = mFragments.findFragmentByWho(who);</span><br><span class="line">        <span class="keyword">if</span> (targetFragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Activity result no fragment exists for who: "</span> + who);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            targetFragment.onActivityResult(requestCode&amp;<span class="number">0xffff</span>, resultCode, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>果然，证实了我们上面的推论。在FragmentActivity.onActivityResult 中，只有 <code>requestCode&gt;0xffff</code> 时，这里得到的 requestIndex 才能满足<code>requestIndex != 0</code>，然后进入下面的逻辑：把 requestCode 通过反向之前的映射关系，还原成最初 Fragment 所指定的 requestCode，交给 Fragment.onActivityResult 进行处理。</p>
<p><strong>注意：</strong>通过 FragementActivity 源码可以发现，源码里没有处理嵌套 Fragment 的情况，也就是说回调只到第一级Fragment，就没有继续分发。所以在第二级或者更深级别的 Fragment 调用 startActivityForResult 方法时，将无法收到 onActivityResult 回调。</p>
<ul>
<li><p><strong>使用 startActivityForResult 的时候，requestCode 一定不要大于 0xffff(65535)</strong>。</p>
</li>
<li><p>嵌套一层 Fragment 时，要在 Fragment 的 onActivityResult 接收数据，在 Fragment 中要使用 <code>Fragment.startActivityForResult</code>，而不是 <code>Fragment.getActivity().startActivityForResult</code>，如果 activity 中重写了 onActivityResult，那么一定要加上<code>super.onActivityResult(requestCode, resultCode, data)</code>。</p>
</li>
<li><p>嵌套多层 Fragment 时，要在第二级或更深级别的 Fragment 获取回调，需要重写 activity 的 onActivityResult 方法，继续分发回调给 Fragment。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAppCompatActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"TAG"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写onactivityresult方法，使二个或多个fragment嵌套使用时能收到onactivityresut回调</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        FragmentManager fm = getSupportFragmentManager();</span><br><span class="line">        <span class="keyword">int</span> index = requestCode &gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (fm.getFragments() == <span class="keyword">null</span> || index &lt; <span class="number">0</span></span><br><span class="line">                    || index &gt;= fm.getFragments().size()) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Activity result fragment index out of range: 0x"</span></span><br><span class="line">                        + Integer.toHexString(requestCode));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Fragment frag = fm.getFragments().get(index);</span><br><span class="line">            <span class="keyword">if</span> (frag == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Activity result no fragment exists for index: 0x"</span></span><br><span class="line">                        + Integer.toHexString(requestCode));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handleResult(frag, requestCode, resultCode, data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归调用，对所有子Fragement生效</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> frag</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(Fragment frag, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Intent data)</span> </span>&#123;</span><br><span class="line">        frag.onActivityResult(requestCode &amp; <span class="number">0xffff</span>, resultCode, data);</span><br><span class="line">        List&lt;Fragment&gt; frags = frag.getChildFragmentManager().getFragments();</span><br><span class="line">        <span class="keyword">if</span> (frags != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Fragment f : frags) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">null</span>)</span><br><span class="line">                    handleResult(f, requestCode, resultCode, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Fragment 中调用 startActivityForResult 时，一定要调用根 Fragment 的启动方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 得到根Fragment</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Fragment <span class="title">getRootFragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Fragment fragment = getParentFragment();</span><br><span class="line">  <span class="keyword">while</span> (fragment.getParentFragment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">   fragment = fragment.getParentFragment();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fragment;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 启动Activity</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onClickTextViewRemindAdvancetime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">  intent.setClass(getActivity(), YourActivity<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  intent.putExtra(<span class="string">"TAG"</span>,<span class="string">"TEST"</span>); </span><br><span class="line">  getRootFragment().startActivityForResult(intent, <span class="number">1000</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="七、ViewPager-Fragment相关"><a href="#七、ViewPager-Fragment相关" class="headerlink" title="七、ViewPager+Fragment相关"></a>七、ViewPager+Fragment相关</h4><p>ViewPager 是 android 中提供界面滑动的类，继承自 ViewGroup。PagerAdapter 是 ViewPager 的适配器类，为ViewPager提供界面。但是一般来说，通常都会使用 PagerAdapter 的两个子类：FragmentPagerAdapter和FragmentStatePagerAdapter 作为 ViewPager 的适配器，他们的特点是界面是 Fragment 。</p>
<p>ViewPager 默认会缓存当前页相邻的<code>DEFAULT_OFFSCREEN_PAGES</code>(默认1)个界面，比如当滑动到第2页时，会初始化第1页和第3页的界面（即 Fragmen t对象，且生命周期函数运行到<code>onResume()</code>），可以通过<code>setOffscreenPageLimit(count)</code>设置离线缓存的界面个数。</p>
<p>FragmentPagerAdapter 和 FragmentStatePagerAdapter 需要重写的方法都一样，常见的重写方法如下：</p>
<ul>
<li>public FragmentPagerAdapter(FragmentManager fm)：构造函数，参数为 FragmentManager。如果是嵌套 Fragment 场景，子 PagerAdapter的参数传入 getChildFragmentManager()。</li>
<li>Fragment getItem(int position)：返回第 position 位置的 Fragment，必须重写。</li>
<li>int getCount(): 返回 ViewPager 的页数，必须重写。</li>
<li>Object instantiateItem(ViewGroup container, int position)：container 是 ViewPager 对象，返回第 position位置的 Fragment。</li>
<li>void destroyItem(ViewGroup container, int position, Object object)：container 是 ViewPager 对象，object 是 Fragment 对象。</li>
<li>getItemPosition(Object object)：object 是 Fragment 对象，如果返回 POSITION_UNCHANGED，则表示当前 Fragment 不刷新，如果返回 POSITION_NONE，则表示当前 Fragment 需要调用<code>destroyItem()</code>和<code>instantiateItem()</code>进行销毁和重建。 默认情况下返回 POSITION_UNCHANGED。</li>
</ul>
<p>FragmentPagerAdapter 和 FragmentStatePagerAdapter 的区别：</p>
<ul>
<li><strong>FragmentPagerAdapter</strong>：<strong>对Fragment的状态没有恢复和保存，对Fragment对象进行视图销毁</strong>。每个Fragment 会持久的保存在 FragmentManager 中，在 destroyItem() 中只是 detach，只是在页面上让 fragment 的UI脱离 Activity，但 fragment 仍然保存在内存里，并不会回收内存。因此适用于那些数据<strong>相对静态</strong>的页，Fragment <strong>数量也比较少</strong>的情况。</li>
<li><strong>FragmentStatePagerAdapter</strong>： <strong>对Fragment的状态进行了恢复和保存，对Fragment对象进行实例销毁</strong> 。只保留当前页面，当页面不可见时，在 destroyItem() 中会 remove 之前加载的 fragment，该 fragment 就会被消除，释放其内存资源。因此适用于那些<strong>数据动态性</strong>较大、<strong>占用内存</strong>较多，Fragment <strong>数量较多</strong>的情况。</li>
</ul>
<h4 id="八、懒加载"><a href="#八、懒加载" class="headerlink" title="八、懒加载"></a>八、懒加载</h4><h5 id="为什么要使用懒加载"><a href="#为什么要使用懒加载" class="headerlink" title="为什么要使用懒加载"></a>为什么要使用懒加载</h5><p>默认情况，ViewPager 会缓存当前页和左右相邻的界面。实现懒加载的主要原因是：用户没进入的界面需要有一系列的网络、数据库等耗资源、耗时的操作，预先做这些数据加载是不必要的。为了不做预先额外的数据加载，节省资源，就需要使用懒加载。</p>
<h5 id="什么是懒加载"><a href="#什么是懒加载" class="headerlink" title="什么是懒加载"></a>什么是懒加载</h5><p>当界面对用户可见时，才加载数据并更新UI，当界面对用户不可见时，停止加载数据等一切操作。</p>
<h5 id="如何实现懒加载"><a href="#如何实现懒加载" class="headerlink" title="如何实现懒加载"></a>如何实现懒加载</h5><p><strong>在 androidx 之前</strong>，懒加载主要依赖 Fragment 的<code>setUserVisibleHint(boolean isVisible)</code>方法，当Fragment变为可见时，会调用<code>setUserVisibleHint(true)</code>；当Fragment变为不可见时，会调用<code>setUserVisibleHint(false)</code>，且该方法调用时机：</p>
<ul>
<li>onAttach() 之前，调用<code>setUserVisibleHint(false)</code>。</li>
<li>onCreateView() 之前，如果该界面为当前页，则调用<code>setUserVisibleHint(true)</code>，否则调用<code>setUserVisibleHint(false)</code>。</li>
<li>界面变为可见时，调用<code>setUserVisibleHint(true)</code>。</li>
<li>界面变为不可见时，调用<code>setUserVisibleHint(false)</code>。</li>
</ul>
<p>懒加载 Fragment 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> View mRootView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsPrepared; <span class="comment">//表示UI是否准备好</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsInited;  <span class="comment">//表示是否已经做过数据加载</span></span><br><span class="line">                                            </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        mRootView = inflater.inflate(R.layout.fragment_lazy, container, <span class="keyword">false</span>);</span><br><span class="line">        mIsPrepared = <span class="keyword">true</span>;</span><br><span class="line">        lazyLoad();<span class="comment">// 解决第一次数据显示</span></span><br><span class="line">        <span class="keyword">return</span> mRootView;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lazyLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (getUserVisibleHint() &amp;&amp; mIsPrepared &amp;&amp; !mIsInited) &#123; </span><br><span class="line">           <span class="comment">//异步初始化，在初始化后显示正常UI</span></span><br><span class="line">           <span class="comment">//1. 加载数据  2. 更新UI  3. mIsInited = true</span></span><br><span class="line">           loadData();</span><br><span class="line">           mIsInited = <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//子类可重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加载数据</span></span><br><span class="line">    &#125;   </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserVisibleHint</span><span class="params">(<span class="keyword">boolean</span> isVisibleToUser)</span> </span>&#123; </span><br><span class="line">           <span class="keyword">super</span>.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">           <span class="keyword">if</span> (isVisibleToUser) &#123;</span><br><span class="line">             lazyLoad();</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyFragment <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> LazyFragment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>mIsPrepared：表示UI是否准备好，因为数据加载后需要更新UI，如果UI还没有inflate，就不需要做数据加载，因为setUserVisibleHint()会在onCreateView()之前调用一次，如果此时调用，UI还没有inflate，因此不能加载数据。</li>
<li>mIsInited：表示是否已经做过数据加载，如果做过了就不需要做了。因为 setUserVisibleHint(true) 在界面可见时都会调用，如果滑到该界面做过数据加载后，滑走，再滑回来，还是会调用 setUserVisibleHint(true)，此时由于mIsInited=true，因此不会再做一遍数据加载。</li>
<li>lazyLoad()：懒加载的核心类，在该方法中，只有界面可见（getUserVisibleHint()==true）、UI准备好（mIsPrepared==true）、过去没做过数据加载（mIsInited==false）时，才需要调loadData()做数据加载，数据加载做完后把mIsInited置为true。</li>
</ul>
<p><strong>在 androidx 之后</strong>，<code>setUserVisibleHint()</code>方法已经过时了，官方提出了<code>setMaxLifecycle()</code>方法来替代<code>setUserVisibleHint()</code>方法。</p>
<p><strong>setMaxLifecycle()方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set a ceiling for the state of an active fragment in this FragmentManager. If fragment is</span></span><br><span class="line"><span class="comment">     * already above the received state, it will be forced down to the correct state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The fragment provided must currently be added to the FragmentManager to have it's</span></span><br><span class="line"><span class="comment">     * Lifecycle state capped, or previously added as part of this transaction. The</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Lifecycle.State&#125; passed in must at least be &#123;<span class="doctag">@link</span> Lifecycle.State#CREATED&#125;, otherwise</span></span><br><span class="line"><span class="comment">     * an &#123;<span class="doctag">@link</span> IllegalArgumentException&#125; will be thrown.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragment the fragment to have it's state capped.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state the ceiling state for the fragment.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the same FragmentTransaction instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">setMaxLifecycle</span><span class="params">(@NonNull Fragment fragment,</span></span></span><br><span class="line"><span class="function"><span class="params">            @NonNull Lifecycle.State state)</span> </span>&#123;</span><br><span class="line">  addOp(<span class="keyword">new</span> Op(OP_SET_MAX_LIFECYCLE, fragment, state));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setMaxLifecycle()</code>方法定义在<strong>FragmentTransaction</strong>类中，它的内部逻辑很简单，其实我们经常使用的<code>add()</code>、<code>remove()</code>、<code>show()</code>、<code>hide()</code>等方法也是类似的逻辑，将操作封装为一个Op对象，最后调用<code>commit()</code>方法时再根据Op对象执行对应的操作。</p>
<p>注释中提到<code>setMaxLifecycle()</code>方法的作用是为 Fragment 的状态设置上限，如果当前 Fragment 的状态已经超过了设置的上限，就会强制被降到相应状态。在弄清楚上面这段文字的意义之前我首先要介绍两个相关概念：<strong>Fragment的状态</strong>和<strong>Lifecycle的状态</strong>。</p>
<ul>
<li><strong>Fragment的状态</strong></li>
</ul>
<p>在Fragment类中定义了5个int常量，表示Fragment的状态值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIALIZING = <span class="number">0</span>;     <span class="comment">// Not yet created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATED = <span class="number">1</span>;          <span class="comment">// Created.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTIVITY_CREATED = <span class="number">2</span>; <span class="comment">// Fully created, not started.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STARTED = <span class="number">3</span>;          <span class="comment">// Created and started, not resumed.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESUMED = <span class="number">4</span>;          <span class="comment">// Created started and resumed.</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Lifecycle的状态</strong></li>
</ul>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">Lifecycle</a>是 Android Jetpack 中的架构组件之一，用于帮助我们方便地管理 Activity 和 Fragment 的生命周期，关于 Lifecycle 的详细介绍和使用网上有很多文章，我这里就不说了，如果此前没有接触过可以自行了解一下哈。<br>在 Lifecycle 定义了一个枚举类<strong>State</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    DESTROYED,</span><br><span class="line">    INITIALIZED,</span><br><span class="line">    CREATED,</span><br><span class="line">    STARTED,</span><br><span class="line">    RESUMED;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAtLeast</span><span class="params">(@NonNull State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 Lifecycle 中同样定义了5个状态，不过这里的状态和 Fragment中 定义的状态还是有一些区别的。</p>
<p>回到<code>setMaxLifecycle()</code>方法，需要传入的参数有两个：fragment和state。fragment不用多说，就是要设置的目标Fragment，不过需要注意的是<strong>此时Fragment必须已经被添加到了FragmentManager中，也就是调用了<code>add()</code>方法</strong>，否则会抛出异常。state就是Lifecycle中定义的枚举类型，同样需要注意<strong>传入的state应该至少为CREATED，换句话说就是只能传入CREATED、STARTED和RESUMED</strong>，否则同样会抛出异常。</p>
<p>下面就以我们最熟悉的生命周期方法来说明这个状态的限制，先上一张图总结一下结论：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghkm2rcvpcj32bg0u0tn8.jpg" alt=""></p>
<p>图中展示了 Fragment 状态间切换会执行的生命周期方法以及 Lifecycle.State 对应的 Fragment 状态，由于<code>setMaxLifecycle()</code>方法要求传入的state至少为<strong>CREATED</strong>，因此我们只需研究<strong>CREATED</strong>、<strong>STARTED</strong>和<strong>RESUMED</strong>这三个状态，结合上图解释一下<code>setMaxLifecycle()</code>方法的作用。</p>
<ul>
<li><strong>参数传入Lifecycle.State.CREATED</strong></li>
</ul>
<p><strong>Lifecycle.State.CREATED</strong>对应Fragment的<strong>CREATED</strong>状态，如果当前Fragment状态低于<strong>CREATED</strong>，也就是<strong>INITIALIZING</strong>，那么Fragment的状态会变为<strong>CREATED</strong>，依次执行<code>onAttach()</code>、<code>onCreate()</code>方法；如果当前Fragment状态高于<strong>CREATED</strong>，那么Fragment的状态会被强制降为<strong>CREATED</strong>，以当前Fragment状态为<strong>RESUMED</strong>为例，接下来会依次执行<code>onPause()</code>、<code>onStop()</code>和<code>onDestoryView()</code>方法。如果当前Fragment的状态恰好为<strong>CREATED</strong>，那么就什么都不做。</p>
<ul>
<li><strong>参数传入Lifecycle.State.STARTED</strong></li>
</ul>
<p><strong>Lifecycle.State.STARTED</strong>对应Fragment的<strong>STARTED</strong>状态，如果当前Fragment状态低于<strong>STARTED</strong>，那么Fragment的状态会变为<strong>STARTED</strong>，以当前Fragment状态为<strong>CREATED</strong>为例，接下来会依次执行<code>onCreateView()</code>、<code>onActivityCreate()</code>和<code>onStart()</code>方法；如果当前Fragment状态高于<strong>STARTED</strong>，也就是<strong>RESUMED</strong>，那么Fragment的状态会被强制降为<strong>STARTED</strong>，接下来会执行<code>onPause()</code>方法。如果当前Fragment的状态恰好为<strong>STARTED</strong>，那么就什么都不做。</p>
<ul>
<li><strong>参数传入Lifecycle.State.RESUMED</strong></li>
</ul>
<p><strong>Lifecycle.State.RESUMED</strong>对应Fragment的<strong>RESUMED</strong>状态，如果当前Fragment状态低于<strong>RESUMED</strong>，那么Fragment的状态会变为<strong>RESUMED</strong>，以当前Fragment状态为<strong>STARTED</strong>为例，接下来会执行<code>onResume()</code>方法。如果当前Fragment的状态恰好为<strong>RESUMED</strong>，那么就什么都不做。</p>
<p>那么 androidx 之后懒加载的新方案，这次的切入点在 <strong>FragmentPagerAdapter</strong> 中，我们会发现之前继承自 FragmentPagerAdapter 的构造方法同样过时了。提供了新的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FragmentPagerAdapter</span><span class="params">(@NonNull FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @Behavior <span class="keyword">int</span> behavior)</span> </span>&#123;</span><br><span class="line">    mFragmentManager = fm;</span><br><span class="line">    mBehavior = behavior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多了一个 int 类型的参数 behavior，可选的值有以下两个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BEHAVIOR_SET_USER_VISIBLE_HINT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出一个参数的构造方法默认传入<strong>BEHAVIOR_SET_USER_VISIBLE_HINT</strong>，将其赋值给mBehavior，那么这个mBehavior在什么地方用到了呢。在<strong>FragmentPagerAdapter.java</strong>文件中全局搜索一下，发现只有两个地方用到了mBehavior：<code>instantiateItem()</code>方法和<code>setPrimaryItem()</code>方法。<code>instantiateItem()</code>方法我们很熟悉，是初始化ViewPager中每个Item的方法，<code>setPrimaryItem()</code>方法我此前没有接触过，简单地看了一下源码发现它的作用是设置ViewPager将要显示的Item，在ViewPager切换时会调用该方法，我们来看一下FragmentPagerAdapter中的<code>setPrimaryItem()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrimaryItem</span><span class="params">(@NonNull ViewGroup container, <span class="keyword">int</span> position, @NonNull Object object)</span> </span>&#123;</span><br><span class="line">        Fragment fragment = (Fragment)object;</span><br><span class="line">        <span class="keyword">if</span> (fragment != mCurrentPrimaryItem) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCurrentPrimaryItem != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mCurrentPrimaryItem.setMenuVisibility(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mCurrentPrimaryItem.setUserVisibleHint(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fragment.setMenuVisibility(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCurTransaction == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mCurTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">                &#125;</span><br><span class="line">                mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fragment.setUserVisibleHint(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mCurrentPrimaryItem = fragment;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果 mBehavior 的值为<strong>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</strong>，那么就调用<code>setMaxLifecycle()</code>方法将上一个Fragment的状态设置为<strong>STARTED</strong>，将当前要显示的Fragment的状态设置为<strong>RESUMED</strong>；反之如果mBehavior的值为<strong>BEHAVIOR_SET_USER_VISIBLE_HINT</strong>，那么依然使用<code>setUserVisibleHint()</code>方法设置Fragment的可见性，相应地可以根据<code>getUserVisibleHint()</code>方法获取到Fragment是否可见，从而实现懒加载，具体做法：</p>
<ul>
<li><p>在构造 Adapter 对象的时候 behavior 参数传入 <strong>FragmentPagerAdapter.BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</strong>；</p>
</li>
<li><p>将 Fragment 加载数据的逻辑放到 onResume() 方法中，这样就保证了 Fragment 可见时才会加载数据。</p>
</li>
<li><p>声明一个变量标记是否是首次执行<code>onResume()</code>方法，因为每次 Fragment 由不可见变为可见都会执行<code>onResume()</code>方法，需要防止数据的重复加载。此外，如果我们使用的是 FragmentPagerAdapter，切换导致Fragment被销毁时是不会执行<code>onDestory()</code>和<code>onDetach()</code>方法的，只会执行到<code>onDestroyView()</code>方法，因此在<code>onDestroyView()</code>方法中我们还需要将这个变量重置，否则当Fragment再次可见时就不会重新加载数据了。</p>
</li>
</ul>
<p>以上几点我们就可以封装出新的懒加载 Fragment 了，完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NewLazyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isFirstLoad = <span class="keyword">true</span>; <span class="comment">// 是否第一次加载</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mContext = getActivity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View view = inflater.inflate(getLayoutRes(),container,<span class="keyword">false</span>);</span><br><span class="line">        initView(view);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroyView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroyView();</span><br><span class="line">        isFirstLoad = <span class="keyword">true</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        <span class="keyword">if</span> (isFirstLoad) &#123;</span><br><span class="line">            <span class="comment">// 将数据加载逻辑放到onResume()方法中</span></span><br><span class="line">            initData();</span><br><span class="line">            isFirstLoad = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置布局资源id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getLayoutRes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化视图</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文记录 Android 中 Fragment 的相关知识点，包括 Fragment 的基本定义及使用、生命周期、回退栈的内部实现、Fragment 通信、ViewPager+Fragment 的使用、AndroidX前、后的懒加载等，加深了对 Fragment 的理解和学习。</p>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/dUuGSVhWinAnN9uMiBaXgw" target="_blank" rel="noopener">Android基础：Fragment，看这篇就够了</a></p>
<p><a href="https://www.jianshu.com/p/ca91fa528d5c" target="_blank" rel="noopener">彻底搞懂startActivityForResult在FragmentActivity和Fragment中的异同</a></p>
<p><a href="https://www.cnblogs.com/xjx22/p/5263658.html" target="_blank" rel="noopener">Android的Fragment中onActivityResult不被调用的解决方案</a></p>
<p><a href="https://blog.csdn.net/qq_36486247/article/details/102531304" target="_blank" rel="noopener">androidx中的Fragment懒加载方案</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Service必备基础</title>
    <url>/2020/07/25/Service%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文是介绍Android的四大组件之一的Service。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="一、什么是Service"><a href="#一、什么是Service" class="headerlink" title="一、什么是Service"></a>一、什么是Service</h4><p>Service 是一个应用程序组件，它能在后台执行一些耗时较长的操作，并且不提供用户界面。服务能被其他应用程序的组件启动，即使用户切换到另外的应用时还能保持后台运行。此外，应用程序组件还能与服务绑定，并与服务进行交互，甚至能进行进程间通信（IPC）。 比如，服务可以处理网络传输、音乐播放、执行文件I/O、或者与 content provider 进行交互，所有这些都是后台进行的。</p>
<a id="more"></a>

<ul>
<li><p>运行完全不依赖UI的，只要进程还在，Service 就可以继续运行，可以和其他组件组件交互；</p>
</li>
<li><p>一般运行在与创建服务时所在的应用程序进程中，要运行在单独的进程当中，在声明时需指定 <code>android:process</code>；</p>
</li>
<li><p>服务不会自动开启线程，我们需要在服务的内部手动创建子线程，并在这里执行具体的耗时任务。</p>
</li>
</ul>
<h4 id="二、Service分类"><a href="#二、Service分类" class="headerlink" title="二、Service分类"></a>二、Service分类</h4><h5 id="按运行分类"><a href="#按运行分类" class="headerlink" title="按运行分类"></a>按运行分类</h5><p><strong>前台服务</strong>：指那些经常会被用户关注的服务，因此内存过低时它不会成为被杀的对象。 前台服务必须提供一个状态栏通知，比较不容易被系统回收。</p>
<p><strong>后台服务</strong>：指在后台默默工作，提供数据运算等的服务，它优先级还是比较低的，当系统出现内存不足情况时，就有可能会回收掉正在后台运行的Service。</p>
<h5 id="按使用分类"><a href="#按使用分类" class="headerlink" title="按使用分类"></a>按使用分类</h5><p><strong>本地服务</strong>：用于应用程序内部，实现一些耗时任务，并不占用应用程序所属线程，而是单开线程后台执行。 </p>
<p><strong>远程服务</strong>：用于 Android 系统内部的应用程序之间，可被其他应用程序复用，比如天气预报服务，其他应用程序不需要再写这样的服务，调用已有的即可。</p>
<h4 id="三、Service启动状态"><a href="#三、Service启动状态" class="headerlink" title="三、Service启动状态"></a>三、Service启动状态</h4><h5 id="启动状态-Started"><a href="#启动状态-Started" class="headerlink" title="启动状态(Started)"></a>启动状态(Started)</h5><p>当应用组件（如 Activity）通过调用 <strong>startService()</strong> 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响，除非外部手动调用 <strong>stopService()</strong> 或内部调用 <strong>stopSelf()</strong> 才能停止服务， 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。</p>
<h5 id="绑定状态-Bound"><a href="#绑定状态-Bound" class="headerlink" title="绑定状态(Bound)"></a>绑定状态(Bound)</h5><p>当应用组件通过调用 <strong>bindService()</strong> 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器 <strong>IBinder</strong> 接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</p>
<h4 id="四、Service生命周期"><a href="#四、Service生命周期" class="headerlink" title="四、Service生命周期"></a>四、Service生命周期</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh7ysawqzfj30at0e3abt.jpg" alt=""></p>
<p><strong>onCreate()</strong>：首次创建服务时，将调用此方法，如果服务已在运行，则不会调用此方法，该方法只调用一次；</p>
<p><strong>onStartComand()</strong>：服务通过 <strong>startService()</strong> 启动时会调用，多次执行 <strong>startService()</strong> 方法，该方法也会相应的多次调用；</p>
<p><strong>onBind()</strong>：服务通过 <strong>bindService()</strong> 启动且服务是第一次创建时会调用，在此方法必须返回 一个 IBinder 接口的实现类对象，供客户端用来与服务进行通信，服务在启动状态的情况下可返回 null ；</p>
<p><strong>onUnBind()</strong>：服务通过 <strong>unbindService()</strong> 被解绑时调用；</p>
<p><strong>onDestroy()</strong>：服务停止或被解绑后调用；</p>
<h4 id="五、Service使用"><a href="#五、Service使用" class="headerlink" title="五、Service使用"></a>五、Service使用</h4><h5 id="Service在清单文件中的声明"><a href="#Service在清单文件中的声明" class="headerlink" title="Service在清单文件中的声明"></a>Service在清单文件中的声明</h5><p>通过继承Service基类自定义而来，都需要在AndroidManifest.xml中声明，Service在AndroidManifest.xml中的声明语法，其格式如下(不是所有都必填)：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;service android:enabled=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:exported=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:icon=<span class="string">"drawable resource"</span></span><br><span class="line">    android:isolatedProcess=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:label=<span class="string">"string resource"</span></span><br><span class="line">    android:name=<span class="string">"string"</span></span><br><span class="line">    android:permission=<span class="string">"string"</span></span><br><span class="line">    android:process=<span class="string">"string"</span> &gt;</span><br><span class="line">    . . .</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>android:exported：代表是否能被其他应用隐式调用，其默认值是由 service 中有无 intent-filter 决定的，如果有 intent-filter ，默认值为 true ，否则为 false 。为 false 的情况下，即使有 intent-filter 匹配，也无法打开，即无法被其他应用隐式调用。</li>
<li>android:name：对应 Service 类名，唯一必需的属性。</li>
<li>android:permission：申明此服务的权限。</li>
<li>android:process：是否需要在单独的进程中运行，当设置为 android:process=”:remote” 时，代表Service 在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以 “remote” 和 ”:remote” 不是同一个意思，前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。</li>
<li>android:isolatedProcess ：设置 true 意味着，服务会在一个特殊的进程下运行，这个进程与系统其他进程分开且没有自己的权限。与其通信的唯一途径是通过服务的API(bind and start)。</li>
<li>android:enabled：是否可以被系统实例化，默认为 true因为父标签 也有 enable 属性，所以必须两个都为默认值 true 的情况下服务才会被激活，否则不会激活。</li>
</ul>
<h5 id="通过startService启动"><a href="#通过startService启动" class="headerlink" title="通过startService启动"></a>通过startService启动</h5><ul>
<li><p>service 会一直无限期运行下去，只有外部调用了 stopService() 或 stopSelf() 方法时，该 Service 才会停止运行并销毁。</p>
</li>
<li><p>多次 startService 不会重复执行onCreate回调，但每次都会执行 onStartCommand 回调</p>
</li>
<li><p><strong>onStartCommand()</strong> 方法的返回值int类型才值得注意的，它有三种可选值：</p>
<p>START_STICKY：“黏性的”，当 Service 因内存不足而被系统 kill 后，一段时间后内存再次空闲时，系统将会尝试重新创建此 Service ，一旦创建成功后将回调 onStartCommand 方法，但其中的 Intent 将是null，除非有挂起的Intent，如pendingintent，比较适用于不执行命令、但无限期运行并等待作业的媒体播放器或类似服务。</p>
<p>START_NOT_STICKY：“非黏性的”，当 Service 因内存不足而被系统kill后，即使系统内存再次空闲时，系统也不会尝试重新创建此Service。</p>
<p>START_REDELIVER_INTENT：当 Service 因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，任何挂起 Intent 均依次传递。与 START_STICKY 不同的是，其中的传递的 Intent 将是非空，是最后一次调用 startService 中的 intent 。这个值适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</p>
</li>
</ul>
<h5 id="通过bindService启动"><a href="#通过bindService启动" class="headerlink" title="通过bindService启动"></a>通过bindService启动</h5><ul>
<li><p>该启动方式的调用者和服务之间是典型的 <strong>client-server</strong> 模式。调用者是 client ，service 则是 server 端。<strong>service 只有一个</strong>，但绑定到 service 上面的 client 可以有一个或很多个。这里所提到的 client 指的是组件，比如某个Activity。</p>
</li>
<li><p><strong>client 可以通过 IBinder 接口获取 Service 实例</strong>，从而实现在 client 端直接调用 Service 中的方法以实现交互。</p>
</li>
<li><p>启动服务的生命周期与其绑定的 client 息息相关。当 client 销毁时，client 会自动与 Service 解除绑定。当然，client 也可以明确调用 Context的 <strong>unbindService()</strong> 方法与 Service 解除绑定。<strong>当没有任何 client 与 Service 绑定时，Service 会自行销毁</strong>。</p>
</li>
<li><p><strong>onBind()</strong> 方法必须返回一个 IBinder接口的实现类对象，该类用以提供客户端用来与服务进行交互的编程接口，该接口可以通过三种方法定义接口：</p>
<p><strong>扩展 Binder 类</strong> ：如果服务是提供给自有应用专用的，并且 Service (服务端)与客户端相同的进程中运行，即客户端和服务位于<strong>同一应用和进程</strong>内才有效。通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中以及 Service 中可用的公共方法。如果我们的服务只是自有应用的后台工作线程，则优先采用这种方法。不采用该方式创建接口的唯一原因是，服务被其他应用或不同的进程调用。</p>
<p><strong>使用 Messenger</strong> ：通过它可以在<strong>不同的进程</strong>中共传递Message对象(Handler中的Messager，因此 Handler 是 Messenger 的基础)，在Message中可以存放我们需要传递的数据，然后在进程间传递。因为 Messenger 会在单一线程中创建包含所有请求的队列，也就是说Messenger是以串行的方式处理客户端发来的消息，这样我们就不必对服务进行线程安全设计了。</p>
<p><strong>使用 AIDL</strong> ：由于 Messenger 是以串行的方式处理客户端发来的消息，如果当前有大量消息同时发送到Service(服务端)，Service 仍然只能一个个处理，这也就是 Messenger 跨进程通信的缺点了，因此如果有大量并发请求，Messenger 就会显得力不从心了，这时 AIDL（Android Interface Definition Language） Android 接口定义语言就派上用场了，但实际上 Messenger 的跨进程方式其底层实现就是AIDL，只不过 android 系统帮我们封装成透明的 Messenger 罢了。如果我们想让服务同时处理多个请求，则应该使用 AIDL。它可以用于让某个 Service 与多个应用程序组件之间进行跨进程通信，从而可以实现<strong>多个应用程序共享同一个 Service</strong> 的功能。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务端LocalService部分代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> MyBinder mBinder = <span class="keyword">new</span> MyBinder();</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//建Binder对象，返回给客户端使用，提供数据交换的接口</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line"> 	    <span class="comment">// 声明一个方法，getService。（提供给客户端调用）</span></span><br><span class="line">    <span class="function">LocalService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回当前对象LocalService,这样我们就可在客户端调用Service的公共方法了</span></span><br><span class="line">      <span class="keyword">return</span> LocalService.<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//定义交互方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端--绑定服务实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BindActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ServiceConnection conn;</span><br><span class="line">  <span class="keyword">private</span> LocalService.MyBinder mBinder;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Overrid</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_bind);</span><br><span class="line">        btnBind = (Button) findViewById(R.id.BindService);</span><br><span class="line">        btnUnBind = (Button) findViewById(R.id.unBindService);</span><br><span class="line">        btnGetDatas = (Button) findViewById(R.id.getServiceDatas);</span><br><span class="line">        <span class="comment">//创建绑定对象</span></span><br><span class="line">        <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LocalService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 开启绑定</span></span><br><span class="line">        btnBind.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"绑定调用：bindService"</span>);</span><br><span class="line">                <span class="comment">//调用绑定方法</span></span><br><span class="line">                bindService(intent, conn, Service.BIND_AUTO_CREATE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 解除绑定</span></span><br><span class="line">        btnUnBind.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"解除绑定调用：unbindService"</span>);</span><br><span class="line">                <span class="comment">// 解除绑定</span></span><br><span class="line">                <span class="keyword">if</span>(mBinder!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    mBinder = <span class="keyword">null</span>;</span><br><span class="line">                    unbindService(conn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="comment">// 获取数据</span></span><br><span class="line">        btnGetDatas.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mBinder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 通过绑定服务传递的Binder对象，获取Binder暴露出来的数据</span></span><br><span class="line">                    Log.d(TAG, <span class="string">"从服务端获取数据："</span> + mBinder.getCount());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"还没绑定呢，先绑定,无法从服务端获取数据"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">       conn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 与服务器端交互的接口方法 绑定服务的时候被回调，在这个方法获取绑定Service传递过来的IBinder对象，</span></span><br><span class="line"><span class="comment">             * 通过这个IBinder对象，实现宿主和Service的交互。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"绑定成功调用：onServiceConnected"</span>);</span><br><span class="line">                <span class="comment">// 获取Binder</span></span><br><span class="line">                mBinder = (LocalService.LocalBinder) service;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当取消绑定的时候被回调。但正常情况下是不被调用的，它的调用时机是当Service服务被意外销毁时，</span></span><br><span class="line"><span class="comment">             * 例如内存的资源不足时这个方法才被自动调用。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">                mBinder = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>onServiceConnected(ComponentName name, IBinder service)</strong><br>服务绑定成功后系统会调用该方法以传递服务的 onBind() 方法返回的 IBinder。其中 service 便是服务端返回的 IBinder 实现类对象，ComponentName 是一个封装了组件信息的类。</p>
</li>
<li><p><strong>onServiceDisconnected(ComponentName name)</strong><br>系统会在与服务的连接意外中断时（例如<strong>当服务崩溃或被终止</strong>时）调用该方法。<span style="color:red">注意:当客户端取消绑定时，系统“绝对不会”调用该方法</span>。</p>
</li>
<li><p><strong>bindService(Intent service, ServiceConnection conn, int flags)</strong></p>
<p>其中 Intent 是我们要绑定的服务的意图，而 ServiceConnection 代表与服务的连接，它只有两个方法，前面已分析过，flags 则是指定绑定时是否自动创建 Service 。0代表不自动创建、BIND_AUTO_CREATE 则代表自动创建。</p>
</li>
<li><p><strong>unbindService(ServiceConnection conn)</strong><br>该方法执行解除绑定的操作，其中 ServiceConnection 代表与服务的连接。</p>
</li>
</ul>
<h4 id="六、启动服务与绑定服务间的转换问题"><a href="#六、启动服务与绑定服务间的转换问题" class="headerlink" title="六、启动服务与绑定服务间的转换问题"></a>六、启动服务与绑定服务间的转换问题</h4><p>​        虽然服务的状态有启动和绑定两种，但实际上一个服务可以同时是这两种状态，它既可以是启动服务（以无限期运行），也可以是绑定服务。有点需要注意的是 Android 系统仅会为一个 Service 创建一个实例对象，所以不管是启动服务还是绑定服务，操作的是同一个 Service 实例，而且由于绑定服务或者启动服务执行顺序问题将会出现以下两种情况：<strong>（启动服务的优先级比绑定服务高一些）</strong></p>
<ul>
<li><p><strong>先绑定服务后启动服务</strong></p>
<p>如果当前 Service 实例先以绑定状态运行，然后再以启动状态运行，那么绑定服务将会转为启动服务运行，这时如果之前绑定的宿主（Activity）被销毁了，也不会影响服务的运行，服务还是会一直运行下去，指定收到调用停止服务或者内存不足时才会销毁该服务。</p>
</li>
<li><p><strong>先启动服务后绑定服务</strong></p>
<p>如果当前 Service 实例先以启动状态运行，然后再以绑定状态运行，当前启动服务并不会转为绑定服务，但是还是会与宿主绑定，只是即使宿主解除绑定后，服务依然按启动服务的生命周期在后台运行，直到有 Context调用了 stopService() 或是服务本身调用了 stopSelf() 方法抑或内存不足时才会销毁服务。</p>
</li>
</ul>
<h4 id="七、前台服务"><a href="#七、前台服务" class="headerlink" title="七、前台服务"></a>七、前台服务</h4><p>前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。前台服务必须为状态栏提供通知，设置服务运行于前台的方法。</p>
<h5 id="设置服务运行于前台"><a href="#设置服务运行于前台" class="headerlink" title="设置服务运行于前台"></a>设置服务运行于前台</h5><ul>
<li><p><strong>startForeground(int id, Notification notification)</strong></p>
<p>在 Service 创建 onCreate 时调用，该方法的作用是把当前服务设置为前台服务，其中id参数代表唯一标识通知的整型数，需要注意的是提供给 startForeground() 的整型 ID 不得为 0，而notification是一个状态栏的通知。Android 8.0之后对于通知栏也进行了整改，增加了通知渠道，通知组的概念。</p>
</li>
<li><p><strong>stopForeground(boolean removeNotification)</strong> </p>
<p>在 Service 销毁时调用，该方法是用来从前台删除服务，removeNotification 是否也删除状态栏通知。</p>
</li>
</ul>
<h5 id="启动前台服务"><a href="#启动前台服务" class="headerlink" title="启动前台服务"></a>启动前台服务</h5><p>在Android 8.0 之后需要使用 <strong>startForegroundService()</strong> 启动前台服务，并在清单文件中添加前</p>
<p>台服务权限 <code>android.permission.FOREGROUND_SERVICE</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">       startForegroundService(mForegroundService);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       startService(mForegroundService);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="八、如何提高服务在后台运行时间"><a href="#八、如何提高服务在后台运行时间" class="headerlink" title="八、如何提高服务在后台运行时间"></a>八、如何提高服务在后台运行时间</h4><p>关于 Service 保活后期会整理一篇主流的具体解决方案，主要思路是：</p>
<p>1.<strong>用 startService 方式启动 Service ，onStartCommand 方式中，返回 START_STICKY</strong> 。</p>
<p>2.<strong>提高 Service 的优先级</strong>，在清单文件中对于 intent-filter 可以通过 android:priority = “1000” 属性设置，1000是最高值，如果数字越小则优先级越低。</p>
<p>3.<strong>提升 Service 进程的优先级</strong>，使用前台服务。</p>
<p>4.<strong>设置应用白名单和电量管理</strong>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Service 实例对象同一应用中同时只会有一个。</li>
<li>Service默认并不会运行在子线程中，也不运行在一个独立的进程中，它同样执行在主线程中（UI线程）。换句话说，不要在Service里执行耗时操作，除非手动打开一个子线程，否则有可能出现主线程被阻塞（ANR）的情况。</li>
<li>使用了远程 Service 后，Service 已经在另外一个进程当中运行了，所以只会阻塞该进程中的主线程，并不会影响到当前的应用程序。</li>
<li>默认 Service 和创建者在同一个进程内，如果将 Service 的 android:process 属性指定成” :remote”，表示Service 是在单独的进程创建远程服务。调用 startService 可以启动服务，但不能调用 bindService 绑定服务，因为创建者和 Service 运行在两个不同的进程中，不能再使用传统的建立关联的方式，需要使用 AIDL 来跨进程通信才可以绑定。</li>
<li>只有Activity、Service、Content Provider 能够绑定服务；BroadcastReceiver 广播接收器不能绑定服务</li>
</ul>
<p><a href="https://github.com/prsuit/Android-Learn-Sample" target="_blank" rel="noopener">Demo</a></p>
<p>引用文章：</p>
<blockquote>
<p><a href="https://blog.csdn.net/hdhhd/article/details/80612726" target="_blank" rel="noopener">安卓Service 详解</a></p>
<p><a href="https://www.jianshu.com/p/4c798c91a613" target="_blank" rel="noopener">Android Service两种启动方式详解</a></p>
<p><a href="http://blog.csdn.net/guolin_blog/article/details/11952435" target="_blank" rel="noopener">Android Service完全解析，关于服务你所需知道的一切</a></p>
<p><a href="https://blog.csdn.net/lmj623565791/article/details/47017485" target="_blank" rel="noopener">Android 基于Message的进程间通信 Messenger完全解析</a></p>
<p><a href="https://blog.csdn.net/lmj623565791/article/details/38461079" target="_blank" rel="noopener">Android aidl Binder框架浅析</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
</search>
